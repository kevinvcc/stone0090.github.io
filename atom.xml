<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>劼哥舍(＞﹏＜)</title>
  <subtitle>越简单越快乐，越努力越幸运...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shisb.com/"/>
  <updated>2017-09-24T12:16:54.000Z</updated>
  <id>http://shisb.com/</id>
  
  <author>
    <name>劼哥stone</name>
    <email>stone0090@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《JavaScript闯关记》视频版硬广</title>
    <link href="http://shisb.com/2017/09/24/wechat-url-004/"/>
    <id>http://shisb.com/2017/09/24/wechat-url-004/</id>
    <published>2017-09-24T12:30:00.000Z</published>
    <updated>2017-09-24T12:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>《JavaScript闯关记》视频版已经在极客学院上线啦，你只需花一张电影票的钱（29元），就可以观赏总时长3小时12分的 JavaScript 大片，真的不要太划算哦~</p>
<a id="more"></a> 
<script>
  location.href = "https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&amp;mid=2650101235&amp;idx=1&amp;sn=9c4e6b8305bc0ff824a9ad71b4769a5d&amp;chksm=f07509dbc70280cdc71faa9b24dfb7a27ac11fed8d5df07402771f5c041f91f16f83ac93aa5d#rd";
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《JavaScript闯关记》视频版已经在极客学院上线啦，你只需花一张电影票的钱（29元），就可以观赏总时长3小时12分的 JavaScript 大片，真的不要太划算哦~&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="微信公众号" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号：想提高团队技术，来试试这个套路！</title>
    <link href="http://shisb.com/2017/07/25/wechat-url-003/"/>
    <id>http://shisb.com/2017/07/25/wechat-url-003/</id>
    <published>2017-07-25T15:00:00.000Z</published>
    <updated>2017-08-31T14:25:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>读完本文约 3 分钟。</p>
<p>我加入阿里影业 3 个月，成功转为正式员工。新的开始，leader 给我新的要求，让我给组里的同学们带带节奏，帮助大家提高技术水平。</p>
<p>正好我最近参加了大胡子的游戏空间交流会，学习到游戏规则设计的要点，便结合实际情况制定了「技术提高三部曲」，希望能给大家带来启发。</p>
<a id="more"></a> 
<script>
  location.href = "https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101232&idx=1&sn=feaae7a1ff2438b3eea8818a306bd35c&chksm=f07509d8c70280ce5442b3c4c0fb083547e322944e315121f56df51d45b3e42211045a226c8e#rd";
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读完本文约 3 分钟。&lt;/p&gt;
&lt;p&gt;我加入阿里影业 3 个月，成功转为正式员工。新的开始，leader 给我新的要求，让我给组里的同学们带带节奏，帮助大家提高技术水平。&lt;/p&gt;
&lt;p&gt;正好我最近参加了大胡子的游戏空间交流会，学习到游戏规则设计的要点，便结合实际情况制定了「技术提高三部曲」，希望能给大家带来启发。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term=".NET" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/NET/"/>
    
    
      <category term="微信公众号" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="阿里影业" scheme="http://shisb.com/tags/%E9%98%BF%E9%87%8C%E5%BD%B1%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号：从国企到阿里的面试经历（二）</title>
    <link href="http://shisb.com/2017/06/24/wechat-url-002/"/>
    <id>http://shisb.com/2017/06/24/wechat-url-002/</id>
    <published>2017-06-24T15:00:00.000Z</published>
    <updated>2017-08-31T14:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>读完本文需要 3 分钟。</p>
<p>安逸舒适是一种生活态度，挑战自己是另一种生活态度，我躁动不安的性格注定会选第二条路。突破舒适区，才有可能改变，能不能变得好，就交由给老天爷来决定。</p>
<p>「一入阿里深似海，从此家人是路人」这句话真不假，任务多得做不完，承受的压力也比较大，特别感谢一直支持鼓励我的家人，是你们给予我源源不断的动力。</p>
<p>比较遗憾的是没时间写博客了555。不过，时间就像乳沟，挤挤还是会有的。这不，真的挤出来一篇，接上篇 从国企到阿里的面试经历（一），各位朋友趁热看~</p>
<a id="more"></a> 
<script>
  location.href = "https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101229&idx=1&sn=1e6ab19ce22cd53d0b6ec7bd19ca9cd4&chksm=f07509c5c70280d3e5330cea947e224c36792903c77303e617ef75e90c585000e4b098e0d338#rd";
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读完本文需要 3 分钟。&lt;/p&gt;
&lt;p&gt;安逸舒适是一种生活态度，挑战自己是另一种生活态度，我躁动不安的性格注定会选第二条路。突破舒适区，才有可能改变，能不能变得好，就交由给老天爷来决定。&lt;/p&gt;
&lt;p&gt;「一入阿里深似海，从此家人是路人」这句话真不假，任务多得做不完，承受的压力也比较大，特别感谢一直支持鼓励我的家人，是你们给予我源源不断的动力。&lt;/p&gt;
&lt;p&gt;比较遗憾的是没时间写博客了555。不过，时间就像乳沟，挤挤还是会有的。这不，真的挤出来一篇，接上篇 从国企到阿里的面试经历（一），各位朋友趁热看~&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term=".NET" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/NET/"/>
    
    
      <category term="微信公众号" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="阿里影业" scheme="http://shisb.com/tags/%E9%98%BF%E9%87%8C%E5%BD%B1%E4%B8%9A/"/>
    
      <category term="面试" scheme="http://shisb.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号：从国企到阿里的面试经历（一）</title>
    <link href="http://shisb.com/2017/05/01/wechat-url-001/"/>
    <id>http://shisb.com/2017/05/01/wechat-url-001/</id>
    <published>2017-05-01T15:00:00.000Z</published>
    <updated>2017-08-31T14:24:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>读完本文需要 3 分钟。</p>
<p>首先，跟大家说声抱歉，年后实在是太忙，带娃、录视频、换工作，大堆事情挤在一起，一不小心就断更了 4 个月，实在是对不起一直以来支持我的朋友们。</p>
<p>从今天开始，我尽量坚持月更，分享最干的干货给大家，老斯基又要开始飙车了，请坐稳！！！（其实我的内心是想周更的，但阿里工作实在太忙，连月更都挤不出时间，好在加班使我快乐，555）</p>
<a id="more"></a> 
<script>
  location.href = "https://mp.weixin.qq.com/s?__biz=MzIyNjE0MzU1OQ==&mid=2650101224&idx=1&sn=1fb7f3268e34d7983fb57ab2a1e0eb31&chksm=f07509c0c70280d68a91622bf445c85ed7f331cc3dccf054626cb9c863f00fcaeed2e11e91bd#rd";
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读完本文需要 3 分钟。&lt;/p&gt;
&lt;p&gt;首先，跟大家说声抱歉，年后实在是太忙，带娃、录视频、换工作，大堆事情挤在一起，一不小心就断更了 4 个月，实在是对不起一直以来支持我的朋友们。&lt;/p&gt;
&lt;p&gt;从今天开始，我尽量坚持月更，分享最干的干货给大家，老斯基又要开始飙车了，请坐稳！！！（其实我的内心是想周更的，但阿里工作实在太忙，连月更都挤不出时间，好在加班使我快乐，555）&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term=".NET" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/NET/"/>
    
    
      <category term="微信公众号" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
      <category term="阿里影业" scheme="http://shisb.com/tags/%E9%98%BF%E9%87%8C%E5%BD%B1%E4%B8%9A/"/>
    
      <category term="面试" scheme="http://shisb.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之垃圾回收和内存管理</title>
    <link href="http://shisb.com/2016/12/29/javascript-lesson-2.6-GC&amp;MemoryManagement/"/>
    <id>http://shisb.com/2016/12/29/javascript-lesson-2.6-GC&amp;MemoryManagement/</id>
    <published>2016-12-29T13:00:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收和内存管理"><a href="#垃圾回收和内存管理" class="headerlink" title="垃圾回收和内存管理"></a>垃圾回收和内存管理</h1><p>JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。</p>
<p>在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：<strong>找出那些不再继续使用的变量，然后释放其占用的内存。</strong>为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</p>
<p>正因为垃圾回收器的存在，许多人认为 JavaScript 不用太关心内存管理的问题，但如果不了解 JavaScript 的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p>
<a id="more"></a> 
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="内存的分配场景"><a href="#内存的分配场景" class="headerlink" title="内存的分配场景"></a>内存的分配场景</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.对象</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(); </div><div class="line"><span class="keyword">new</span> MyConstructor(); </div><div class="line">&#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">5</span> &#125; </div><div class="line"><span class="built_in">Object</span>.create();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2.数组 </span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(); </div><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ];</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3.字符串，JavaScript 的字符串和 .NET 一样，使用资源池和 copy on write 方式管理字符串。</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello hyddd"</span>); </div><div class="line"><span class="string">"&lt;p&gt;"</span> + e.innerHTML + <span class="string">"&lt;/p&gt;"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 4.函数</span></div><div class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125; </div><div class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(code);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 5.闭包 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> x = name; </div><div class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123; </div><div class="line">        <span class="keyword">return</span> <span class="string">"Hi, "</span> + name; </div><div class="line">     &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3><p>下面我们来分析一下函数中局部变量的正常生命周期。</p>
<ul>
<li>内存分配：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。</li>
<li>内存使用：然后在函数中使用这些变量，直至函数执行结束。</li>
<li>内存回收：此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。</li>
</ul>
<p>通常，很容易判断变量是否还有存在的必要，但并非所有情况下都这么容易就能得出结论（例如：使用闭包的时）。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：<strong>标记清除</strong> 和 <strong>引用计数</strong>。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是 <strong>标记清除</strong>（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span> ; <span class="comment">// 被标记 ，进入环境 </span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">20</span> ; <span class="comment">// 被标记 ，进入环境 </span></div><div class="line">&#125; </div><div class="line">test(); <span class="comment">// 执行完毕 之后 a、b又被标离开环境，被回收。</span></div></pre></td></tr></table></figure>
<p>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（例如，闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<p>这种方式的主要缺点就是如果某些对象被清理后，内存是不连续的，那么就算内存占用率不高，例如只有50%，但是由于内存空隙太多，后来的大对象甚至无法存储到内存之中。一般的处理方式都是在垃圾回收后进行整理操作，这种方法也叫 <strong>标记整理</strong>，整理的过程就是将不连续的内存向一端复制，使不连续的内存连续起来。</p>
<p>目前，IE9+、Firefox、Opera、Chrome 和 Safari 的 JavaScript 实现使用的都是 <strong>标记清除</strong> 式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>另一种不太常见的垃圾收集策略叫做 <strong>引用计数</strong>（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">// a的引用次数为0 </span></div><div class="line">    <span class="keyword">var</span> b = a ; <span class="comment">// a的引用次数加1，为1 </span></div><div class="line">    <span class="keyword">var</span> c = a; <span class="comment">// a的引用次数再加1，为2 </span></div><div class="line">    <span class="keyword">var</span> b = &#123;&#125;; <span class="comment">// a的引用次数减1，为1 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>早期很多浏览器使用引用计数策略，但很快它就遇到了一个严重的问题：<strong>循环引用</strong>。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">    objectA.someOtherObject = objectB;</div><div class="line">    objectB.anotherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用 <strong>标记清除</strong> 策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用 <strong>引用计数</strong> 策略的实现中，当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，新一代浏览器都放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。</p>
<p>我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</div><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">myObject.element = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure>
<p>这个例子在一个 DOM 元素（element）与一个原生 JavaScript 对象（myObject）之间创建了循环引用。其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myObject。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。</p>
<p>为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myObject.element = <span class="literal">null</span>;</div><div class="line">element.someObject = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>将变量设置为 <code>null</code> 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。</p>
<p>为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。</p>
<h3 id="IE6-的性能问题"><a href="#IE6-的性能问题" class="headerlink" title="IE6 的性能问题"></a>IE6 的性能问题</h3><p>IE6 的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，那么垃圾回收器会一直工作，这样浏览器就没法儿玩儿了。</p>
<p>微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和 IE6 相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE7 在运行包含大量 JavaScript 的页面时的性能。</p>
<h3 id="编码注意-解除引用"><a href="#编码注意-解除引用" class="headerlink" title="编码注意 - 解除引用"></a>编码注意 - 解除引用</h3><p>使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 <code>null</code> 来释放其引用——这个做法叫做 <strong>解除引用</strong>（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    localPerson.name = name;</div><div class="line">    <span class="keyword">return</span> localPerson;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> globalPerson = createPerson(<span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 手工解除globalPerson的引用</span></div><div class="line">globalPerson = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>由于局部变量 <code>localPerson</code> 在 <code>createPerson()</code> 函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。但是对于全局变量 <code>globalPerson</code> 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。</p>
<p>不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
<h2 id="垃圾回收的优化策略"><a href="#垃圾回收的优化策略" class="headerlink" title="垃圾回收的优化策略"></a>垃圾回收的优化策略</h2><p>和其他语言一样，JavaScript 的垃圾回收策略也无法避免一个问题：垃圾回收时，会停止响应其他操作，这是为了安全考虑。而 JavaScript 的垃圾回收在 100ms 甚至以上，对一般的应用还好，但对于 JavaScript 游戏和动画，这种对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免垃圾回收造成的长时间停止响应。</p>
<p>David 大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了： </p>
<h3 id="分代回收（Generation-GC）"><a href="#分代回收（Generation-GC）" class="headerlink" title="分代回收（Generation GC）"></a>分代回收（Generation GC）</h3><p>这个和 Java 回收策略思想是一致的。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（young generation），少回收「持久对象区」（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。<strong>Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。</strong>如图： </p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.6-GC&amp;MemoryManagement/WechatIMG124.jpg" alt=""></p>
<h3 id="增量回收（Incremental-GC）"><a href="#增量回收（Incremental-GC）" class="headerlink" title="增量回收（Incremental GC）"></a>增量回收（Incremental GC）</h3><p>这个方案的思想很简单，就是「每次处理一点，下次再处理一点，如此类推」。这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。<strong>Firefox 浏览器所使用的  JavaScript 引擎就是采用的增量回收策略。</strong>如图： </p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.6-GC&amp;MemoryManagement/WechatIMG125.jpg" alt=""></p>
<p>因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。例如：如果大量对象都是长期「存活」，则分代处理优势也不大。</p>
<blockquote>
<p>原文链接：Know Your Engines: How to Make Your JavaScript Fast<br><a href="http://conferences.oreilly.com/velocity/velocity2011/public/schedule/detail/18087" target="_blank" rel="external">http://t.cn/RIROY1W</a></p>
</blockquote>
<h3 id="查看-Chrome-浏览器下的-CG-过程"><a href="#查看-Chrome-浏览器下的-CG-过程" class="headerlink" title="查看 Chrome 浏览器下的 CG 过程"></a>查看 Chrome 浏览器下的 CG 过程</h3><ol>
<li>使用快捷键 <code>F12</code> 或者 <code>Ctrl+Shift+J</code> 打开 Chrome 浏览器的「开发者工具」。</li>
<li>选择 <code>Timeline</code> 选项卡，在 <code>Capture</code> 选项中，只勾选 <code>Memory</code>。</li>
<li>设置完成后，点击最左边的 <code>Record</code> 按钮，然后就可以访问网页了。</li>
<li>打开一个网站，例如：<a href="http://www.taobao.com" target="_blank" rel="external">http://www.taobao.com</a>，当网页加载完成后，点击 <code>Stop</code>，等待分析结果。</li>
<li>然后在 <code>Chart View</code> 上寻找内存急速下降的部分，查看对应的 <code>Event Log</code>，可以从中找到 GC 的日志。</li>
</ol>
<p>具体过程如下图所示：<br><img src="http://qn.shisb.com/blog/javascript-lesson/2.6-GC&amp;MemoryManagement/WechatIMG127.jpg" alt=""></p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><ul>
<li>挑战一，尝试写一段小程序，触发 IE6 的无限 CG。</li>
<li>挑战二，参考「查看 Chrome 浏览器下的 CG 过程」，尝试查看 Firefox  浏览器下的 CG 过程。</li>
</ul>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾回收和内存管理&quot;&gt;&lt;a href=&quot;#垃圾回收和内存管理&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收和内存管理&quot;&gt;&lt;/a&gt;垃圾回收和内存管理&lt;/h1&gt;&lt;p&gt;JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。&lt;/p&gt;
&lt;p&gt;在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：&lt;strong&gt;找出那些不再继续使用的变量，然后释放其占用的内存。&lt;/strong&gt;为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。&lt;/p&gt;
&lt;p&gt;正因为垃圾回收器的存在，许多人认为 JavaScript 不用太关心内存管理的问题，但如果不了解 JavaScript 的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之原型及原型链</title>
    <link href="http://shisb.com/2016/12/21/javascript-lesson-2.5-Prototype/"/>
    <id>http://shisb.com/2016/12/21/javascript-lesson-2.5-Prototype/</id>
    <published>2016-12-21T15:55:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <code>__proto__</code> 属性指向创建它的构造函数的 <code>prototype</code>（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从<strong>函数对象</strong>、<code>constructor</code>、<code>new</code>、<code>prototype</code>、<code>__proto__</code> 这五个概念入手。</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。下面示例代码对「普通对象」和「函数对象」进行了区分。</p>
<p>普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<p>函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</div></pre></td></tr></table></figure>
<p>简单的说，凡是使用 <code>function</code> 关键字或 <code>Function</code> 构造函数创建的对象都是函数对象。而且，只有函数对象才拥有  <code>prototype</code> （原型）属性。</p>
<h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。像 <code>Object</code> 和 <code>Array</code> 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Stone"</span>, <span class="number">28</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Sophie"</span>, <span class="number">29</span>, <span class="string">"English Teacher"</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个自定义构造函数 <code>Person()</code>，并通过该构造函数创建了两个普通对象 <code>person1</code> 和 <code>person2</code>，这两个普通对象均包含3个属性和1个方法。</p>
<p>你应该注意到函数名 <code>Person</code> 使用的是大写字母 <code>P</code>。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他面向对象语言，主要是为了区别于 JavaScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p>
<a id="more"></a> 
<h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h2><p>要创建 <code>Person</code> 的新实例，必须使用 <code>new</code> 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 <code>this</code> 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象。</li>
</ol>
<h3 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h3><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 <code>new</code> 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 <code>new</code> 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的 <code>Person()</code> 函数可以通过下列任何一种方式来调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Stone"</span>, <span class="number">28</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person.sayName(); <span class="comment">// "Stone"</span></div><div class="line"></div><div class="line"><span class="comment">// 作为普通函数调用</span></div><div class="line">Person(<span class="string">"Sophie"</span>, <span class="number">29</span>, <span class="string">"English Teacher"</span>); <span class="comment">// 添加到 window</span></div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// "Sophie"</span></div><div class="line"></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"Tommy"</span>, <span class="number">3</span>, <span class="string">"Baby"</span>);</div><div class="line">o.sayName(); <span class="comment">// "Tommy"</span></div></pre></td></tr></table></figure>
<p>这个例子中的前两行代码展示了构造函数的典型用法，即使用 <code>new</code> 操作符来创建一个新对象。接下来的两行代码展示了不使用 <code>new</code> 操作符调用 <code>Person()</code> 会出现什么结果，属性和方法都被添加给 <code>window</code> 对象了。当在全局作用域中调用一个函数时，<code>this</code> 对象总是指向 <code>Global</code> 对象（在浏览器中就是 <code>window</code> 对象）。因此，在调用完函数之后，可以通过 <code>window</code> 对象来调用 <code>sayName()</code> 方法，并且还返回了 <code>&quot;Sophie&quot;</code> 。最后，也可以使用 <code>call()</code>（或者 <code>apply()</code>）在某个特殊对象的作用域中调用 <code>Person()</code> 函数。这里是在对象 <code>o</code> 的作用域中调用的，因此调用后 <code>o</code> 就拥有了所有属性和 <code>sayName()</code> 方法。</p>
<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，<code>person1</code> 和 <code>person2</code> 都有一个名为 <code>sayName()</code> 的方法，但那两个方法不是同一个 <code>Function</code> 的实例。因为 JavaScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(this.name)"</span>); <span class="comment">// 与声明函数在逻辑上是等价的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个角度上来看构造函数，更容易明白每个 <code>Person</code> 实例都包含一个不同的 <code>Function</code> 实例（<code>sayName()</code> 方法）。说得明白些，以这种方式创建函数，虽然创建 <code>Function</code> 新实例的机制仍然是相同的，但是不同实例上的同名函数是不相等的，以下代码可以证明这一点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>然而，创建两个完成同样任务的 <code>Function</code> 实例的确没有必要；况且有 <code>this</code> 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Stone"</span>, <span class="number">28</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Sophie"</span>, <span class="number">29</span>, <span class="string">"English Teacher"</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中，我们把 <code>sayName()</code> 函数的定义转移到了构造函数外部。而在构造函数内部，我们将 <code>sayName</code> 属性设置成等于全局的 <code>sayName</code> 函数。这样一来，由于 <code>sayName</code> 包含的是一个指向函数的指针，因此 <code>person1</code> 和 <code>person2</code> 对象就共享了在全局作用域中定义的同一个 <code>sayName()</code> 函数。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了，在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是，如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型来解决。</p>
<h2 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a><code>prototype</code> 原型</h2><p>我们创建的每个函数都有一个 <code>prototype</code>（原型）属性。使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Stone"</span>;</div><div class="line">Person.prototype.age = <span class="number">28</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName();   <span class="comment">// "Stone"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName();   <span class="comment">// "Stone"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在此，我们将 <code>sayName()</code> 方法和所有属性直接添加到了 <code>Person</code> 的 <code>prototype</code> 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与前面的例子不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，<code>person1</code> 和 <code>person2</code> 访问的都是同一组属性和同一个 <code>sayName()</code> 函数。</p>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在函数的指针。就拿前面的例子来说，<code>Person.prototype.constructor</code> 指向 <code>Person</code>。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Stone"</span>;</div><div class="line">Person.prototype.age = <span class="number">28</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.name = <span class="string">"Sophie"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);     <span class="comment">// "Sophie"，来自实例</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);     <span class="comment">// "Stone"，来自原型</span></div></pre></td></tr></table></figure>
<p>在这个例子中，<code>person1</code> 的 <code>name</code> 被一个新值给屏蔽了。但无论访问 <code>person1.name</code> 还是访问 <code>person2.name</code> 都能够正常地返回值，即分别是 <code>&quot;Sophie&quot;</code>（来自对象实例）和 <code>&quot;Stone&quot;</code>（来自原型）。当访问 <code>person1.name</code> 时，需要读取它的值，因此就会在这个实例上搜索一个名为 <code>name</code> 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当访问 <code>person2. name</code> 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 <code>name</code> 属性。</p>
<p>当为对象实例添加一个属性时，这个属性就会<strong>屏蔽</strong>原型中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 <code>null</code> ，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 <code>delete</code> 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Stone"</span>;</div><div class="line">Person.prototype.age = <span class="number">28</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.name = <span class="string">"Sophie"</span>;</div><div class="line"><span class="built_in">console</span>.log(person1.name);     <span class="comment">// "Sophie"，来自实例</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);     <span class="comment">// "Stone"，来自原型</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line"><span class="built_in">console</span>.log(person1.name);     <span class="comment">// "Stone"，来自原型</span></div></pre></td></tr></table></figure>
<p>在这个修改后的例子中，我们使用 <code>delete</code> 操作符删除了 <code>person1.name</code>，之前它保存的 <code>&quot;Sophie&quot;</code> 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 <code>name</code> 属性的连接。因此，接下来再调用 <code>person1.name</code> 时，返回的就是原型中 <code>name</code> 属性的值了。</p>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>前面例子中每添加一个属性和方法就要敲一遍 <code>Person.prototype</code>。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"Stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在上面的代码中，我们将 <code>Person.prototype</code> 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：<code>constructor</code> 属性不再指向 <code>Person</code> 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 <code>prototype</code> 对象，这个对象也会自动获得 <code>constructor</code> 属性。而我们在这里使用的语法，本质上完全重写了默认的 <code>prototype</code> 对象，因此 <code>constructor</code> 属性也就变成了新对象的 <code>constructor</code> 属性（指向 <code>Object</code> 构造函数），不再指向 <code>Person</code> 函数。此时，尽管 <code>instanceof</code> 操作符还能返回正确的结果，但通过 <code>constructor</code> 已经无法确定对象的类型了，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person);        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(friend.constructor === Person);    <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(friend.constructor === <span class="built_in">Object</span>);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在此，用 <code>instanceof</code> 操作符测试 <code>Object</code> 和 <code>Person</code> 仍然返回 <code>true</code>，但 <code>constructor</code> 属性则等于 <code>Object</code> 而不等于 <code>Person</code> 了。如果 <code>constructor</code> 的值真的很重要，可以像下面这样特意将它设置回适当的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span> : Person,</div><div class="line">    <span class="attr">name</span> : <span class="string">"Stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码特意包含了一个 <code>constructor</code> 属性，并将它的值设置为 <code>Person</code> ，从而确保了通过该属性能够访问到适当的值。</p>
<p>注意，以这种方式重设 <code>constructor</code> 属性会导致它的 <code>[[Enumerable]]</code> 特性被设置为 <code>true</code>。默认情况下，原生的 <code>constructor</code> 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 <code>Object.defineProperty()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"Stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span>,</div><div class="line">    <span class="attr">job</span> : <span class="string">"Software Engineer"</span>,</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="comment">// 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayHi();   <span class="comment">// "hi"（没有问题！）</span></div></pre></td></tr></table></figure>
<p>以上代码先创建了 <code>Person</code> 的一个实例，并将其保存在 <code>friend</code> 中。然后，下一条语句在 <code>Person.prototype</code> 中添加了一个方法 <code>sayHi()</code>。即使 <code>person</code> 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 <code>friend.sayHi()</code> 时，首先会在实例中搜索名为 <code>sayHi</code> 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 <code>sayHi</code> 属性并返回保存在那里的函数。</p>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 <code>[[Prototype]]</code> 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span> : <span class="string">"Stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span>,</div><div class="line">    <span class="attr">job</span> : <span class="string">"Software Engineer"</span>,</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName();   <span class="comment">// Uncaught TypeError: friend.sayName is not a function</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们先创建了 <code>Person</code> 的一个实例，然后又重写了其原型对象。然后在调用 <code>friend.sayName()</code> 时发生了错误，因为 <code>friend</code> 指向的是重写前的原型对象，其中并不包含以该名字命名的属性。</p>
<h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>原型的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（<code>Object</code>、<code>Array</code>、<code>String</code>，等等）都在其构造函数的原型上定义了方法。例如，在 <code>Array.prototype</code> 中可以找到 <code>sort()</code> 方法，而在 <code>String.prototype</code> 中可以找到 <code>substring()</code> 方法，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);       <span class="comment">// "function"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring); <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 <code>String</code> 添加了一个名为 <code>startsWith()</code> 的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</div><div class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这里新定义的 <code>startsWith()</code> 方法会在传入的文本位于一个字符串开始时返回 <code>true</code>。既然方法被添加给了 <code>String.prototype</code> ，那么当前环境中的所有字符串就都可以调用它。由于 <code>msg</code> 是字符串，而且后台会调用 <code>String</code> 基本包装函数创建这个字符串，因此通过 <code>msg</code> 就可以调用 <code>startsWith()</code> 方法。</p>
<p>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。</p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。</p>
<p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span> : <span class="string">"Stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span>,</div><div class="line">    <span class="attr">job</span> : <span class="string">"Software Engineer"</span>,</div><div class="line">    <span class="attr">friends</span> : [<span class="string">"ZhangSan"</span>, <span class="string">"LiSi"</span>],</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"WangWu"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.friends);    <span class="comment">// "ZhangSan,LiSi,WangWu"</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);    <span class="comment">// "ZhangSan,LiSi,WangWu"</span></div><div class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在此，<code>Person.prototype</code> 对象有一个名为 <code>friends</code> 的属性，该属性包含一个字符串数组。然后，创建了 <code>Person</code> 的两个实例。接着，修改了 <code>person1.friends</code> 引用的数组，向数组中添加了一个字符串。由于 <code>friends</code> 数组存在于 <code>Person.prototype</code> 而非 <code>person1</code> 中，所以刚刚提到的修改也会通过 <code>person2.friends</code>（与 <code>person1.friends</code> 指向同一个数组）反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。</p>
<h3 id="构造函数和原型结合"><a href="#构造函数和原型结合" class="headerlink" title="构造函数和原型结合"></a>构造函数和原型结合</h3><p>所以，构造函数用于定义实例属性，而原型用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。下面的代码重写了前面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"ZhangSan"</span>, <span class="string">"LiSi"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span> : Person,</div><div class="line">    <span class="attr">sayName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Stone"</span>, <span class="number">28</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Sophie"</span>, <span class="number">29</span>, <span class="string">"English Teacher"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"WangWu"</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.friends);    <span class="comment">// "ZhangSan,LiSi,WangWu"</span></div><div class="line"><span class="built_in">console</span>.log(person2.friends);    <span class="comment">// "ZhangSan,LiSi"</span></div><div class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends);    <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 <code>constructor</code> 和方法 <code>sayName()</code> 则是在原型中定义的。而修改了 <code>person1.friends</code>（向其中添加一个新字符串），并不会影响到 <code>person2.friends</code>，因为它们分别引用了不同的数组。</p>
<p>这种构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><p>为什么在构造函数的 <code>prototype</code> 中定义了属性和方法，它的实例中就能访问呢？</p>
<p>那是因为当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <code>__proto__</code>，指向构造函数的原型。Firefox、Safari 和 Chrome 的每个对象上都有这个属性 ，而在其他浏览器中是完全不可见的（为了确保浏览器兼容性问题，不要直接使用 <code>__proto__</code> 属性，此处只为解释原型链而演示）。让我们来看下面代码和图片：</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.5/2.jpg?1" alt=""></p>
<p>图中展示了 <code>Person</code> 构造函数、<code>Person</code> 的原型属性以及 <code>Person</code> 现有的两个实例之间的关系。在此，<code>Person.prototype.constructor</code> 指回了 <code>Person</code>。<code>Person.prototype</code> 中除了包含 <code>constructor</code> 属性之外，还包括后来添加的其他属性。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 <code>person1.sayName()</code>。这是因为内部指针 <code>__proto__</code> 指向 <code>Person.prototype</code>，而在 <code>Person.prototype</code> 中能找到 <code>sayName()</code> 方法。</p>
<p>我们来证实一下，<code>__proto__</code> 是不是真的指向 <code>Person.prototype</code> 的？如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>既然，<code>__proto__</code> 确实是指向 <code>Person.prototype</code>，那么使用 <code>new</code> 操作符创建对象的过程可以演变为，为实例对象的 <code>__proto__</code> 赋值的过程。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// var person = new Person(); </span></div><div class="line"><span class="comment">// 上一行代码等同于以下过程 ==&gt; </span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.__proto__ = Person.prototype;</div><div class="line">Person.call(person);</div></pre></td></tr></table></figure>
<p>这个例子中，我先创建了一个空对象 <code>person</code>，然后把 <code>person.__proto__</code> 指向了 <code>Person</code> 的原型对象，便继承了 <code>Person</code> 原型对象中的所有属性和方法，最后又以 <code>person</code> 为作用域执行了 <code>Person</code> 函数，<code>person</code> 便就拥有了 <code>Person</code> 的所有属性和方法。这个过程和 <code>var person = new Person();</code> 完全一样。</p>
<p>简单来说，当我们访问一个对象的属性时，如果这个属性不存在，那么就会去 <code>__proto__</code> 里找，这个 <code>__proto__</code> 又会有自己的 <code>__proto__</code>，于是就这样一直找下去，直到找到为止。在找不到的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>JavaScript 中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如下图所示：（图源：<a href="https://segmentfault.com/q/1010000005182807?_ea=1284630" target="_blank" rel="external">segmentfault.com</a>，作者：<a href="https://segmentfault.com/u/manxisuo" target="_blank" rel="external">manxisuo</a>）</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.5/3.png" alt=""></p>
<p>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<p>上面这段话比较绕口，代码更容易理解，让我们来看看实现原型链的基本模式。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">Father.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value2 = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 继承了 Father</span></div><div class="line">Son.prototype = <span class="keyword">new</span> Father();</div><div class="line"></div><div class="line">Son.prototype.getValue2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</div><div class="line"><span class="built_in">console</span>.log(son.getValue());  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>以上代码定义了两个类型：<code>Father</code> 和 <code>Son</code>。每个类型分别有一个属性和一个方法。它们的主要区别是 <code>Son</code> 继承了 <code>Father</code>，而继承是通过创建 <code>Father</code> 的实例，并将该实例赋给 <code>Son.prototype</code> 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 <code>Father</code> 的实例中的所有属性和方法，现在也存在于 <code>Son.prototype</code> 中了。在确立了继承关系之后，我们给 <code>Son.prototype</code> 添加了一个方法，这样就在继承了 <code>Father</code> 的属性和方法的基础上又添加了一个新方法。</p>
<p>我们再用 <code>__proto__</code> 重写上面代码，更便于大家的理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">Father.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.value2 = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 继承了 Father</span></div><div class="line"><span class="comment">// Son.prototype = new Father(); ==&gt;</span></div><div class="line">Son.prototype = &#123;&#125;;</div><div class="line">Son.prototype.__proto__ = Father.prototype;</div><div class="line">Father.call(Son.prototype);</div><div class="line"></div><div class="line">Son.prototype.getValue2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// var son = new Son(); ==&gt;</span></div><div class="line"><span class="keyword">var</span> son = &#123;&#125;;</div><div class="line">son.__proto__ = Son.prototype;</div><div class="line">Son.call(son);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(son.getValue()); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(son.getValue === son.__proto__.__proto__.getValue); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>从以上代码可以看出，实例 <code>son</code> 调用 <code>getValue()</code> 方法，实际是经过了 <code>son.__proto__.__proto__.getValue</code> 的过程的，其中 <code>son.__proto__</code> 等于 <code>Son.prototype</code>，而 <code>Son.prototype.__proto__</code> 又等于 <code>Father.prototype</code>，所以 <code>son.__proto__.__proto__.getValue</code> 其实就是 <code>Father.prototype.getValue</code>。</p>
<p>事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默然都继承了 <code>Obeject</code>，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 <code>Object</code> 的实例，因此默认原型都会包含一个内部指针 <code>__proto__</code>，指向 <code>Object.prototype</code>。这也正是所有自定义类型都会继承 <code>toString()</code>、<code>valueOf()</code> 等默认方法的根本原因。</p>
<p>下图展示了原型链实现继承的全部过程。（图源：<a href="https://segmentfault.com/q/1010000005182807?_ea=1284630" target="_blank" rel="external">segmentfault.com</a>，作者：<a href="https://segmentfault.com/u/manxisuo" target="_blank" rel="external">manxisuo</a>）</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.5/4.png" alt=""></p>
<p>上图中，<code>p</code> 指 <code>prototype</code> 属性，<code>[p]</code> 即 <code>__proto__</code> 指对象的原型，<code>[p]</code> 形成的链（虚线部分）就是<strong>原型链</strong>。从图中可以得出以下信息：</p>
<ul>
<li><code>Object.prototype</code> 是顶级对象，所有对象都继承自它。</li>
<li><code>Object.prototype.__proto__ === null</code> ，说明原型链到 <code>Object.prototype</code> 终止。</li>
<li><code>Function.__proto__</code> 指向 <code>Function.prototype</code>。</li>
</ul>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>根据描述写出对应的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一</span></div><div class="line"><span class="comment">// 1.定义一个构造函数 Animal，它有一个 name 属性，以及一个 eat() 原型方法。</span></div><div class="line"><span class="comment">// 2.eat() 的方法体为：console.log(this.name + " is eating something.")。</span></div><div class="line"><span class="comment">// 3.new 一个 Animal 的实例 tiger，然后调用 eat() 方法。</span></div><div class="line"><span class="comment">// 4.用 __proto__ 模拟 new Animal() 的过程，然后调用 eat() 方法。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Animal = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待补充的代码</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> tiger = <span class="keyword">new</span> Animal(<span class="string">"tiger"</span>);</div><div class="line"><span class="comment">// 待补充的代码</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> tiger2 = &#123;&#125;;</div><div class="line"><span class="comment">// 待补充的代码</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二</span></div><div class="line"><span class="comment">// 1.定义一个构造函数 Bird，它继承自 Animal，它有一个 name 属性，以及一个 fly() 原型方法。</span></div><div class="line"><span class="comment">// 2.fly() 的方法体为：console.log(this.name + " want to fly higher.");。</span></div><div class="line"><span class="comment">// 3.new 一个 Bird 的实例 pigeon，然后调用 eat() 和 fly() 方法。</span></div><div class="line"><span class="comment">// 4.用 __proto__ 模拟 new Bird() 的过程，然后用代码解释 pigeon2 为何能调用 eat() 方法。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Bird = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待补充的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> pigeon = <span class="keyword">new</span> Bird(<span class="string">"pigeon"</span>);</div><div class="line"><span class="comment">// 待补充的代码</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pigeon2 = &#123;&#125;;</div><div class="line"><span class="comment">// 待补充的代码</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三</span></div><div class="line"><span class="comment">// 1.定义一个构造函数 Swallow，它继承自 Bird，它有一个 name 属性，以及一个 nesting() 原型方法。</span></div><div class="line"><span class="comment">// 2.nesting() 的方法体为：console.log(this.name + " is nesting now.");。</span></div><div class="line"><span class="comment">// 3.new 一个 Swallow 的实例 yanzi，然后调用 eat()、fly() 和 nesting() 方法。</span></div><div class="line"><span class="comment">// 4.用 __proto__ 模拟 new Swallow() 的过程，然后用代码解释 yanzi2 为何能调用 eat() 方法。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Swallow = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待补充的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> yanzi = <span class="keyword">new</span> Swallow(<span class="string">"yanzi"</span>);</div><div class="line"><span class="comment">// 待补充的代码</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> yanzi2 = &#123;&#125;;</div><div class="line"><span class="comment">// 待补充的代码</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 &lt;code&gt;__proto__&lt;/code&gt; 属性指向创建它的构造函数的 &lt;code&gt;prototype&lt;/code&gt;（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从&lt;strong&gt;函数对象&lt;/strong&gt;、&lt;code&gt;constructor&lt;/code&gt;、&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;prototype&lt;/code&gt;、&lt;code&gt;__proto__&lt;/code&gt; 这五个概念入手。&lt;/p&gt;
&lt;h2 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h2&gt;&lt;p&gt;前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。下面示例代码对「普通对象」和「函数对象」进行了区分。&lt;/p&gt;
&lt;p&gt;普通对象：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o1 = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数对象：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f2 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;console.log(str)&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单的说，凡是使用 &lt;code&gt;function&lt;/code&gt; 关键字或 &lt;code&gt;Function&lt;/code&gt; 构造函数创建的对象都是函数对象。而且，只有函数对象才拥有  &lt;code&gt;prototype&lt;/code&gt; （原型）属性。&lt;/p&gt;
&lt;h2 id=&quot;constructor-构造函数&quot;&gt;&lt;a href=&quot;#constructor-构造函数&quot; class=&quot;headerlink&quot; title=&quot;constructor 构造函数&quot;&gt;&lt;/a&gt;&lt;code&gt;constructor&lt;/code&gt; 构造函数&lt;/h2&gt;&lt;p&gt;函数还有一种用法，就是把它作为构造函数使用。像 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Stone&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Sophie&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;English Teacher&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，我们创建了一个自定义构造函数 &lt;code&gt;Person()&lt;/code&gt;，并通过该构造函数创建了两个普通对象 &lt;code&gt;person1&lt;/code&gt; 和 &lt;code&gt;person2&lt;/code&gt;，这两个普通对象均包含3个属性和1个方法。&lt;/p&gt;
&lt;p&gt;你应该注意到函数名 &lt;code&gt;Person&lt;/code&gt; 使用的是大写字母 &lt;code&gt;P&lt;/code&gt;。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他面向对象语言，主要是为了区别于 JavaScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之作用域和闭包</title>
    <link href="http://shisb.com/2016/12/13/javascript-lesson-2.4-Scope&amp;Closure/"/>
    <id>http://shisb.com/2016/12/13/javascript-lesson-2.4-Scope&amp;Closure/</id>
    <published>2016-12-13T15:00:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p>
<h3 id="全局作用域（Global-Scope）"><a href="#全局作用域（Global-Scope）" class="headerlink" title="全局作用域（Global Scope）"></a>全局作用域（Global Scope）</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：</p>
<p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"global"</span>;     <span class="comment">// 显式声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> global;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);       <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>global</code> 是全局变量，不管是在 <code>checkscope()</code> 函数内部还是外部，都能访问到全局变量 <code>global</code>。</p>
<p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>; <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    global = <span class="string">"global"</span>;   <span class="comment">// 隐式声明一个全局变量(不好的写法)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);     <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);      <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>global</code> 未用 <code>var</code> 关键字定义就直接赋值，所以隐式的创建了全局变量 <code>global</code>，但这种写法容易造成误解，应尽量避免这种写法。</p>
<p>3.所有 <code>window</code> 对象的属性拥有全局作用域</p>
<p>一般情况下，<code>window</code> 对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p>
<a id="more"></a> 
<h3 id="局部作用域（Local-Scope）"><a href="#局部作用域（Local-Scope）" class="headerlink" title="局部作用域（Local Scope）"></a>局部作用域（Local Scope）</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> local;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，在函数体内定义了变量 <code>local</code>，在函数体内是可以访问了，在函数外访问就报错了。</p>
<h3 id="全局和局部作用域的关系"><a href="#全局和局部作用域的关系" class="headerlink" title="全局和局部作用域的关系"></a>全局和局部作用域的关系</h3><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;      <span class="comment">// 声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;   <span class="comment">// 声明一个同名的局部变量</span></div><div class="line">    <span class="keyword">return</span> scope;          <span class="comment">// 返回局部变量的值，而不是全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "local"</span></div></pre></td></tr></table></figure>
<p>尽管在全局作用域编写代码时可以不写 <code>var</code> 语句，但声明局部变量时则必须使用 <code>var</code> 语句。思考一下如果不这样做会怎样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scope = <span class="string">"global"</span>;           <span class="comment">// 声明一个全局变量，甚至不用 var 来声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    scope = <span class="string">"local"</span>;        <span class="comment">// 糟糕！我们刚修改了全局变量</span></div><div class="line">    myscope = <span class="string">"local"</span>;      <span class="comment">// 这里显式地声明了一个新的全局变量</span></div><div class="line">    <span class="keyword">return</span> [scope, myscope];<span class="comment">// 返回两个值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope2()); <span class="comment">// ["local", "local"]，产生了副作用</span></div><div class="line"><span class="built_in">console</span>.log(scope);         <span class="comment">// "local"，全局变量修改了</span></div><div class="line"><span class="built_in">console</span>.log(myscope);       <span class="comment">// "local"，全局命名空间搞乱了</span></div></pre></td></tr></table></figure>
<p>函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;         <span class="comment">// 全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;      <span class="comment">//局部变量 </span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> scope = <span class="string">"nested scope"</span>; <span class="comment">// 嵌套作用域内的局部变量</span></div><div class="line">        <span class="keyword">return</span> scope;               <span class="comment">// 返回当前作用域内的值</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nested();</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(checkscope());          <span class="comment">// "nested scope"</span></div></pre></td></tr></table></figure>
<h3 id="函数作用域和声明提前"><a href="#函数作用域和声明提前" class="headerlink" title="函数作用域和声明提前"></a>函数作用域和声明提前</h3><p>在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>
<p>在如下所示的代码中，在不同位置定义了变量 <code>i</code>、<code>j</code> 和 <code>k</code>，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>; <span class="comment">// i在整个函数体内均是有定义的</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">"object"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> j = <span class="number">0</span>; <span class="comment">// j在函数体内是有定义的，不仅仅是在这个代码段内</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123; <span class="comment">// k在函数体内是有定义的，不仅仅是在循环内</span></div><div class="line">            <span class="built_in">console</span>.log(k); <span class="comment">// 输出数字0~9</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(k); <span class="comment">// k已经定义了，输出10</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(j); <span class="comment">// j已经定义了，但可能没有初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line">    <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可能会误以为函数中的第一行会输出 <code>&quot;global&quot;</code>，因为代码还没有执行到 <code>var</code> 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 <code>var</code> 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope;          <span class="comment">// 在函数顶部声明了局部变量</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 变量存在，但其值是"undefined"</span></div><div class="line">    scope = <span class="string">"local"</span>;    <span class="comment">// 这里将其初始化并赋值</span></div><div class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 这里它具有了我们所期望的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 <code>arguments</code> 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>请看下面的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (color === <span class="string">"blue"</span>)&#123;</div><div class="line">        color = <span class="string">"red"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        color = <span class="string">"blue"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(changeColor());</div></pre></td></tr></table></figure>
<p>在这个简单的例子中，函数 <code>changeColor()</code> 的作用域链包含两个对象：它自己的变量对象（其中定义着 <code>arguments</code> 对象）和全局环境的变量对象。可以在函数内部访问变量 <code>color</code>，就是因为可以在这个作用域链中找到它。</p>
<p>此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line"></div><div class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这里可以访问color和anotherColor，但不能访问tempColor</span></div><div class="line">    swapColors();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这里只能访问color</span></div><div class="line">changeColor();</div></pre></td></tr></table></figure>
<p>以上代码共涉及3个执行环境：全局环境、<code>changeColor()</code> 的局部环境和 <code>swapColors()</code> 的局部环境。全局环境中有一个变量 <code>color</code> 和一个函数 <code>changeColor()</code>。<code>changeColor()</code> 的局部环境中有一个名为 <code>anotherColor</code> 的变量和一个名为 <code>swapColors()</code> 的函数，但它也可以访问全局环境中的变量 <code>color</code>。<code>swapColors()</code> 的局部环境中有一个变量 <code>tempColor</code>，该变量只能在这个环境中访问到。无论全局环境还是 <code>changeColor()</code> 的局部环境都无权访问 <code>tempColor</code>。然而，在 <code>swapColors()</code> 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.41.jpg" alt=""></p>
<p>上图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 <code>swapColors()</code> 而言，其作用域链中包含3个对象：<code>swapColors()</code> 的变量对象、<code>changeColor()</code> 的变量对象和全局变量对象。<code>swapColors()</code> 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。<code>changeColor()</code> 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 <code>swapColors()</code> 的环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>MDN 对闭包的定义：</p>
<blockquote>
<p>闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。</p>
</blockquote>
<p>《JavaScript 权威指南(第6版)》对闭包的定义：</p>
<blockquote>
<p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
</blockquote>
<p>《JavaScript 高级程序设计(第3版)》对闭包的定义：</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p>上面这些定义都比较晦涩难懂，<a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a>的解释稍微好理解一些：</p>
<blockquote>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。</p>
</blockquote>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;　　　</div><div class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line"></div><div class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        n += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fun2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = fun();　　</div><div class="line">result(); <span class="comment">// 1</span></div><div class="line">add();</div><div class="line">result(); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>在这段代码中，<code>result</code> 实际上就是函数 <code>fun2</code>。它一共运行了两次，第一次的值是 <code>1</code>，第二次的值是 <code>2</code>。这证明了，函数 <code>fun</code> 中的局部变量 <code>n</code> 一直保存在内存中，并没有在 <code>fun</code> 调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于 <code>fun</code> 是 <code>fun2</code> 的父函数，而 <code>fun2</code> 被赋给了一个全局变量，这导致 <code>fun2</code> 始终在内存中，而 <code>fun2</code> 的存在依赖于 <code>fun</code>，因此 <code>fun</code> 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是 <code>add = function() { n += 1 }</code> 这一行。首先，变量 <code>add</code> 前面没有使用 <code>var</code> 关键字，因此 <code>add</code> 是一个全局变量，而不是局部变量。其次，<code>add</code> 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 <code>fun2</code> 处于同一作用域，所以 <code>add</code> 相当于是一个 <code>setter</code>，可以在函数外部对函数内部的局部变量进行操作。</p>
<h3 id="计数器的困境"><a href="#计数器的困境" class="headerlink" title="计数器的困境"></a>计数器的困境</h3><p>我们再来看一个经典例子「计数器的困境」，假设你想统计一些数值，且该计数器在所有函数中都是可用的。你可以定义一个全局变量 <code>counter</code> 当做计数器，再定义一个 <code>add()</code> 函数来设置计数器递增。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 计数器现在为 3</span></div></pre></td></tr></table></figure>
<p>计数器数值在执行 <code>add()</code> 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器 <code>counter</code>，即便没有调用 <code>add()</code> 函数。如果我们将计数器 <code>counter</code> 定义在 <code>add()</code> 函数内部，就不会被外部脚本随意修改到计数器的值了。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> counter += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="built_in">console</span>.log(add());</div><div class="line"><span class="comment">// 本意是想输出 3, 但事与愿违，输出的都是 1</span></div></pre></td></tr></table></figure>
<p>因为每次调用 <code>add()</code> 函数，计数器都会被重置为 0，输出的都是 1，这并不是我们想要的结果。闭包正好可以解决这个问题，我们在 <code>add()</code> 函数内部，再定义一个 <code>plus()</code> 内嵌函数（闭包），内嵌函数 <code>plus()</code> 可以访问父函数的 <code>counter</code> 变量。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;counter += <span class="number">1</span>;&#125;</div><div class="line">    plus();</div><div class="line">    <span class="keyword">return</span> counter; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，只要我们能在外部访问 <code>plus()</code> 函数，并且确保 <code>counter = 0</code> 只执行一次，就能解决计数器的困境。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</div><div class="line">    <span class="keyword">return</span> plus;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> puls2 = add();</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="built_in">console</span>.log(puls2());</div><div class="line"><span class="comment">// 计数器为 3</span></div></pre></td></tr></table></figure>
<p>计数器 <code>counter</code> 受 <code>add()</code> 函数的作用域保护，只能通过 <code>puls2</code> 方法修改。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 <code>null</code>，断开变量和内存的联系。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<p>JavaScript 闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量，理解闭包有助于编写出更有效也更简洁的代码。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a><code>this</code> 关键字</h2><p>谈到作用域和闭包就不得不说 <code>this</code> 关键字，虽然它们之间关联不大，但是它们一起使用却容易让人产生疑惑。下面列出了使用 <code>this</code> 的大部分场景，带大家一探究竟。</p>
<p><code>this</code> 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，<code>this</code> 的值会发生变化。但是有一个总的原则，那就是 <code>this</code> 指代的是调用函数的那个对象。</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>在全局上下文中，也就是在任何函数体外部，<code>this</code> 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中，this 指代全局对象 window</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在函数上下文中，也就是在任何函数体内部，<code>this</code> 指代调用函数的那个对象。</p>
<h4 id="函数调用中的-this"><a href="#函数调用中的-this" class="headerlink" title="函数调用中的 this"></a>函数调用中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，直接定义一个函数 <code>f1()</code>，相当于为 <code>window</code> 对象定义了一个属性。直接执行函数 <code>f1()</code>，相当于执行 <code>window.f1()</code>。所以函数 <code>f1()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是 <code>window</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>; <span class="comment">// 这里是严格模式</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f2() === <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如上代码所示，在「严格模式」下，禁止 <code>this</code> 关键字指向全局对象（在浏览器环境中也就是 <code>window</code> 对象），<code>this</code> 的值将维持 <code>undefined</code> 状态。</p>
<h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 <code>this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>如上代码所示，对象 <code>o</code> 中包含一个属性 <code>name</code> 和一个方法 <code>f()</code>。当我们执行 <code>o.f()</code> 时，方法 <code>f()</code> 中的 <code>this</code> 指代调用函数的那个对象，也就是对象 <code>o</code>，所以 <code>this.name</code> 也就是 <code>o.name</code>。</p>
<p>注意，在何处定义函数完全不会影响到 <code>this</code> 的行为，我们也可以首先定义函数，然后再将其附属到 <code>o.f</code>。这样做 <code>this</code> 的行为也一致。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">name</span>: <span class="string">"stone"</span> &#125;;</div><div class="line">o.f = fun;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<p>类似的，<code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 <code>g()</code> 当作对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code>。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">o.b = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"sophie"</span></div><div class="line">    g: fun,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(o.b.g()); <span class="comment">// "sophie"</span></div></pre></td></tr></table></figure>
<h4 id="eval-方法中的-this"><a href="#eval-方法中的-this" class="headerlink" title="eval() 方法中的 this"></a><code>eval()</code> 方法中的 <code>this</code></h4><p><code>eval()</code> 方法可以将字符串转换为 JavaScript 代码，使用 <code>eval()</code> 方法时，<code>this</code> 指向哪里呢？答案很简单，看谁在调用 <code>eval()</code> 方法，调用者的执行环境中的 <code>this</code> 就被 <code>eval()</code> 方法继承下来了。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 函数上下文</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">f</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">"this.name"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// "stone"</span></div></pre></td></tr></table></figure>
<h4 id="call-和-apply-方法中的-this"><a href="#call-和-apply-方法中的-this" class="headerlink" title="call() 和 apply() 方法中的 this"></a><code>call()</code> 和 <code>apply()</code> 方法中的 <code>this</code></h4><p><code>call()</code> 和 <code>apply()</code> 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，<code>this</code> 指代的就是这两个方法的第一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">0</span>;　　</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;　　　　</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);　　</div><div class="line">&#125;　　</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;　　</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.m = f;　　</div><div class="line">o.m.apply(); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p><code>call()</code> 和 <code>apply()</code> 的参数为空时，默认调用全局对象。因此，这时的运行结果为 <code>0</code>，证明 <code>this</code> 指的是全局对象。如果把最后一行代码修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.m.apply(o); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>运行结果就变成了 <code>1</code>，证明了这时 <code>this</code> 指代的是对象 <code>o</code>。</p>
<h4 id="bind-方法中的-this"><a href="#bind-方法中的-this" class="headerlink" title="bind() 方法中的 this"></a><code>bind()</code> 方法中的 <code>this</code></h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f.bind(&#123;</div><div class="line">    <span class="attr">a</span>: <span class="string">"stone"</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// stone</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">28</span>,</div><div class="line">    <span class="attr">f</span>: f,</div><div class="line">    <span class="attr">g</span>: g</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 28, stone</span></div></pre></td></tr></table></figure>
<h4 id="DOM-事件处理函数中的-this"><a href="#DOM-事件处理函数中的-this" class="headerlink" title="DOM 事件处理函数中的 this"></a>DOM 事件处理函数中的 <code>this</code></h4><p>一般来讲，当函数使用 <code>addEventListener</code>，被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">this</span>.style.backgroundColor = <span class="string">"#A5D9F3"</span>;</div><div class="line">        &#125;, <span class="literal">false</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但在 IE 浏览器中，当函数使用 <code>attachEvent</code> ，被用作事件处理函数时，它的 <code>this</code> 却指向 <code>window</code>。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</div><div class="line">        btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="内联事件处理函数中的-this"><a href="#内联事件处理函数中的-this" class="headerlink" title="内联事件处理函数中的 this"></a>内联事件处理函数中的 <code>this</code></h4><p>当代码被内联处理函数调用时，它的 <code>this</code> 指向监听器所在的 DOM 元素。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></div><div class="line">  Show this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的 <code>alert</code> 会显示 <code>button</code>，注意只有外层代码中的 <code>this</code> 是这样设置的。如果 <code>this</code> 被包含在匿名函数中，则又是另外一种情况了。如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></div><div class="line">  Show inner this</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这种情况下，<code>this</code> 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 <code>window</code> 对象。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>仔细想想，下面代码块会输出什么结果呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func2;</div><div class="line">&#125;</div><div class="line">func1()();  <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(scope);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> inner;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(scope);</div><div class="line">    &#125;</div><div class="line">    scope = <span class="string">"tommy"</span>;</div><div class="line">    <span class="keyword">return</span> inner;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战四</span></div><div class="line">scope = <span class="string">"stone"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(scope);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"sophie"</span>;</div><div class="line">    <span class="keyword">return</span> Bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ret = Func();</div><div class="line">ret();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战五</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;　　</div><div class="line"><span class="keyword">var</span> object = &#123;　　　　</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　　　</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;　　　　　　</div><div class="line">        &#125;;　　　　</div><div class="line">    &#125;　　</div><div class="line">&#125;;　　</div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()());    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战六</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;　　</div><div class="line"><span class="keyword">var</span> object = &#123;　　　　</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　</div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;　　　　　　</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;　　　　　　　　</div><div class="line">            <span class="keyword">return</span> that.name;　　　　　　</div><div class="line">        &#125;;　　　　</div><div class="line">    &#125;　　</div><div class="line">&#125;;　　</div><div class="line"><span class="built_in">console</span>.log(object.getNameFunc()());    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。&lt;/p&gt;
&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域（Global-Scope）&quot;&gt;&lt;a href=&quot;#全局作用域（Global-Scope）&quot; class=&quot;headerlink&quot; title=&quot;全局作用域（Global Scope）&quot;&gt;&lt;/a&gt;全局作用域（Global Scope）&lt;/h3&gt;&lt;p&gt;在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：&lt;/p&gt;
&lt;p&gt;1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; global = &lt;span class=&quot;string&quot;&gt;&quot;global&quot;&lt;/span&gt;;     &lt;span class=&quot;comment&quot;&gt;// 显式声明一个全局变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkscope&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; local = &lt;span class=&quot;string&quot;&gt;&quot;local&quot;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 显式声明一个局部变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; global;         &lt;span class=&quot;comment&quot;&gt;// 返回全局变量的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(global);       &lt;span class=&quot;comment&quot;&gt;// &quot;global&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(checkscope()); &lt;span class=&quot;comment&quot;&gt;// &quot;global&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(local);        &lt;span class=&quot;comment&quot;&gt;// error: local is not defined.&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，&lt;code&gt;global&lt;/code&gt; 是全局变量，不管是在 &lt;code&gt;checkscope()&lt;/code&gt; 函数内部还是外部，都能访问到全局变量 &lt;code&gt;global&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;checkscope&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; local = &lt;span class=&quot;string&quot;&gt;&quot;local&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 显式声明一个局部变量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    global = &lt;span class=&quot;string&quot;&gt;&quot;global&quot;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 隐式声明一个全局变量(不好的写法)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(global);     &lt;span class=&quot;comment&quot;&gt;// &quot;global&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(local);      &lt;span class=&quot;comment&quot;&gt;// error: local is not defined.&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码中，变量 &lt;code&gt;global&lt;/code&gt; 未用 &lt;code&gt;var&lt;/code&gt; 关键字定义就直接赋值，所以隐式的创建了全局变量 &lt;code&gt;global&lt;/code&gt;，但这种写法容易造成误解，应尽量避免这种写法。&lt;/p&gt;
&lt;p&gt;3.所有 &lt;code&gt;window&lt;/code&gt; 对象的属性拥有全局作用域&lt;/p&gt;
&lt;p&gt;一般情况下，&lt;code&gt;window&lt;/code&gt; 对象的内置属性都拥有全局作用域，例如 &lt;code&gt;window.name&lt;/code&gt;、&lt;code&gt;window.location&lt;/code&gt;、&lt;code&gt;window.top&lt;/code&gt; 等等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何排版 微信公众号「代码块」之 MarkEditor</title>
    <link href="http://shisb.com/2016/12/04/wechat-public-platform-layout-designer2/"/>
    <id>http://shisb.com/2016/12/04/wechat-public-platform-layout-designer2/</id>
    <published>2016-12-04T13:30:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间写过一篇文章 <a href="http://www.jianshu.com/p/ffeb5ceac32b" target="_blank" rel="external">如何排版微信公众号「代码块」</a>，讲的是如何使用浏览器插件 <a href="http://markdown-here.com/index.html" target="_blank" rel="external">Markdown Here</a> 来排版代码块。虽然用 <a href="http://markdown-here.com/index.html" target="_blank" rel="external">Markdown Here</a> 排版出来的样式还不错，但存在一个问题，就是代码之间的换行会全部丢失，需要手动进行调整。如果文章中代码较多的话，调整起来还是挺费劲的。</p>
<p>而我近期写的文章，常常会罗列大量代码，导致每次在公众号发文，都要花1个多小时来调整样式，真是难受想哭。</p>
<p>双11期间，看到 <a href="https://www.zhihu.com/people/sagacity" target="_blank" rel="external">池建强老师</a> 公众号 <code>MacTalk</code> 的文章 <a href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MjM5ODQ2MDIyMA==#wechat_webview_type=1&amp;wechat_redirect" target="_blank" rel="external">如何优雅的购买 Mac 软件</a>。不出我意料，他果然推荐了一家专卖正版 Mac 软件的淘宝店铺 <a href="https://digitalychee.taobao.com/?spm=a1z10.1-c-s.0.0.Lc7ddI" target="_blank" rel="external">数码荔枝</a>。秉承「老池推荐必精品」的原则，我如愿的淘到了微信公众号排版神器 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a>。当时，该软件有着「双11特惠」和「老池特惠」双重加持，我仅用了 76.5 就拿下了官网售价 128 的 Pro 版本（得意的笑）。</p>
<p><img src="http://qn.shisb.com/blog/wechat-public-platform-layout-designer2/WechatIMG98.jpeg" alt=""></p>
<a id="more"></a>
<p>促使我购买 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a> 的原因是，它官方介绍能「支持导出为微信公众号文章格式」。我实在是被微信公众号的「代码块」排版折磨得不行，看到任何希望都想试试。</p>
<p><img src="http://qn.shisb.com/blog/wechat-public-platform-layout-designer2/WechatIMG99.jpeg" alt=""></p>
<p>而 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a> 没有令我失望，默认的3套微信样式都非常美观，最重要的是「代码块」直接就能正常展示，不用再去手工调整。如果你会CSS，那么你还可以给 Markdown 设计多套样式，以适应不同类型的文章。</p>
<p>下图是 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a>（左）和 <a href="http://markdown-here.com/index.html" target="_blank" rel="external">Markdown Here</a>（右）的排版对比效果。用 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a> 排版一次到位；而用 <a href="http://markdown-here.com/index.html" target="_blank" rel="external">Markdown Here</a> 排版，我不仅重新调整了「代码块」的换行问题，还调整了全文的间距及字号。为此它又浪费了我5分钟，好在今后能被 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a> 解放。</p>
<p><img src="http://qn.shisb.com/blog/wechat-public-platform-layout-designer2/demo.jpg" alt=""></p>
<p><a href="https://item.taobao.com/item.htm?id=535492270773&amp;_fb=MjluZTdwNnwxMWk3MnwxfDUzNTQ5MjI3MDc3M3xncWF8ODg5ODUw&amp;spm=a310v.4.1100002.2474057510&amp;_g=s2&amp;_g=a1100002&amp;_n=2474057510&amp;_t=item&amp;_tk=535492270773&amp;tracelog=frsinazt&amp;from=frsinazt" target="_blank" rel="external">MarkEditorPro版 淘宝购买链接 119元</a>，<a href="http://markeditor.com/buy?app=markeditor&amp;default_type=pro" target="_blank" rel="external">MarkEditorPro版 官网购买链接 128元</a>。（可惜我影响力卑微，联系过淘宝店铺 <a href="https://digitalychee.taobao.com/?spm=a1z10.1-c-s.0.0.Lc7ddI" target="_blank" rel="external">数码荔枝</a>，想给大家争取点优惠，不过没有成功。）</p>
<p>为了感谢长期支持我的朋友们，我无论如何都要给大家发放福利。挥泪把自己的 License 提供给大家使用，只有15个名额（因为每个 License 最多只能注册20次），规则如下：</p>
<ul>
<li>从12月5号开始，每天中午12点整，在微信公众号「劼哥舍」后台留言「MarkEditor」，前5名即可获得 License，连续发放3天，总计送出15个名额。</li>
<li>同一个微信账户，多次回复「MarkEditor」只算第一次，所以大家卡好点再回复，用不着刷屏。</li>
<li>每晚8点左右，我会在公众号后回复 License 给幸运的你。请拿到 License 的同学，只在自己常用的电脑上使用一次就好，把更多的机会留给有需要的人。</li>
</ul>
<p>最后，没拿到 License 的朋友也不要遗憾，如果 <a href="http://markeditor.com/app/markeditor" target="_blank" rel="external">MarkEditor</a> 同样能帮到你，花100多块大幅节省时间，绝对是超值。</p>
<p>关注我的微信公众号「劼哥舍」，更多干货等着你！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间写过一篇文章 &lt;a href=&quot;http://www.jianshu.com/p/ffeb5ceac32b&quot;&gt;如何排版微信公众号「代码块」&lt;/a&gt;，讲的是如何使用浏览器插件 &lt;a href=&quot;http://markdown-here.com/index.html&quot;&gt;Markdown Here&lt;/a&gt; 来排版代码块。虽然用 &lt;a href=&quot;http://markdown-here.com/index.html&quot;&gt;Markdown Here&lt;/a&gt; 排版出来的样式还不错，但存在一个问题，就是代码之间的换行会全部丢失，需要手动进行调整。如果文章中代码较多的话，调整起来还是挺费劲的。&lt;/p&gt;
&lt;p&gt;而我近期写的文章，常常会罗列大量代码，导致每次在公众号发文，都要花1个多小时来调整样式，真是难受想哭。&lt;/p&gt;
&lt;p&gt;双11期间，看到 &lt;a href=&quot;https://www.zhihu.com/people/sagacity&quot;&gt;池建强老师&lt;/a&gt; 公众号 &lt;code&gt;MacTalk&lt;/code&gt; 的文章 &lt;a href=&quot;http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MjM5ODQ2MDIyMA==#wechat_webview_type=1&amp;amp;wechat_redirect&quot;&gt;如何优雅的购买 Mac 软件&lt;/a&gt;。不出我意料，他果然推荐了一家专卖正版 Mac 软件的淘宝店铺 &lt;a href=&quot;https://digitalychee.taobao.com/?spm=a1z10.1-c-s.0.0.Lc7ddI&quot;&gt;数码荔枝&lt;/a&gt;。秉承「老池推荐必精品」的原则，我如愿的淘到了微信公众号排版神器 &lt;a href=&quot;http://markeditor.com/app/markeditor&quot;&gt;MarkEditor&lt;/a&gt;。当时，该软件有着「双11特惠」和「老池特惠」双重加持，我仅用了 76.5 就拿下了官网售价 128 的 Pro 版本（得意的笑）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn.shisb.com/blog/wechat-public-platform-layout-designer2/WechatIMG98.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="CSS" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/CSS/"/>
    
    
      <category term="CSS" scheme="http://shisb.com/tags/CSS/"/>
    
      <category term="微信公众号" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之事件</title>
    <link href="http://shisb.com/2016/11/29/javascript-lesson-2.3-Event/"/>
    <id>http://shisb.com/2016/11/29/javascript-lesson-2.3-Event/</id>
    <published>2016-11-28T23:00:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web 浏览器就会产生事件（event）。例如，当 Web 浏览器加载完文档、用户把鼠标指针移到超链接上或敲击键盘时，Web 浏览器都会产生事件。如果 JavaScript 应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于 Web 编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事情发生（即，它们等待事件发生），然后它们响应。</p>
<p>请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情，这种在传统软件工程中被称为观察员模式。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>当浏览器发展到第四代时（IE4 及 Netscape Communicator 4），浏览器开发团队遇到了一个很有意思的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。</p>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序。但有意思的是，IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 的事件流叫做<strong>事件冒泡</strong>（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你单击了页面中的 <code>&lt;div&gt;</code> 元素，那么这个 <code>click</code> 事件会按照如下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<p>也就是说，<code>click</code> 事件首先在 <code>&lt;div&gt;</code> 元素上发生，而这个元素就是我们单击的元素。然后，<code>click</code> 事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 <code>document</code> 对象。下图展示了事件冒泡的过程。</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.3/1.jpg" alt=""></p>
<a id="more"></a> 
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>Netscape Communicator 团队提出的另一种事件流叫做<strong>事件捕获</strong>（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击 <code>&lt;div&gt;</code> 元素就会以下列顺序触发 <code>click</code> 事件。</p>
<ol>
<li><code>document</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;div&gt;</code></li>
</ol>
<p>在事件捕获过程中，<code>document</code> 对象首先接收到 <code>click</code> 事件，然后事件沿 DOM 树依次向下，一直传播到事件的实际目标，即 <code>&lt;div&gt;</code> 元素。下图展示了事件捕获的过程。</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.3/2.jpg" alt=""></p>
<p>由于老版本的浏览器不支持，因此很少有人使用事件捕获。我们也建议大家放心地使用事件冒泡，在有特殊需要时再使用事件捕获。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>事件就是用户或浏览器自身执行的某种动作。诸如 <code>click</code>、<code>load</code> 和 <code>mouseover</code>，都是事件的名字。而响应某个事件的函数就叫做<strong>事件处理程序</strong>（或<strong>事件侦听器</strong>）。事件处理程序的名字以 <code>&quot;on&quot;</code> 开头，因此 <code>click</code> 事件的事件处理程序就是 <code>onclick</code>，<code>load</code> 事件的事件处理程序就是 <code>onload</code>。为事件指定处理程序的方式有好几种。</p>
<h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的 HTML 特性来指定。这个特性的值应该是能够执行的 JavaScript 代码。例如，要在按钮被单击时执行一些 JavaScript，可以像下面这样编写代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log('Clicked')"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>当单击这个按钮时，就会在控制台打印 <code>&quot;Clicked&quot;</code>。这个操作是通过指定 <code>onclick</code> 特性并将一些 JavaScript 代码作为它的值来定义的。由于这个值是 JavaScript，因此不能在其中使用未经转义的 HTML 语法字符，例如和号（&amp;）、双引号（””）、小于号（&lt;）或大于号（&gt;）。为了避免使用 HTML 实体，这里使用了单引号。如果想要使用双引号，那么就要将代码改写成如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(&amp;quot;Clicked&amp;quot;)"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>在 HTML 中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其他地方定义的脚本，如下面的例子所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    function showMessage()&#123;</div><div class="line">        console.log("Hello world!");</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;input type="button" value="Click Me" onclick="showMessage()" /&gt;</div></pre></td></tr></table></figure>
<p>在这个例子中，单击按钮就会调用 <code>showMessage()</code> 函数。这个函数是在一个独立的 <code>&lt;script&gt;</code> 元素中定义的，当然也可以被包含在一个外部文件中。事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。</p>
<p>这样指定事件处理程序具有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量 <code>event</code>，也就是事件对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "click" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(event.type)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>通过 <code>event</code> 变量，可以直接访问事件对象，你不用自己定义它，也不用从函数的参数列表中读取。</p>
<p>在这个函数内部，<code>this</code> 值等于事件的目标元素，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(this.value)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如此一来，事件处理程序要访问自己的属性就简单多了。下面这行代码与前面的例子效果相同：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 输出 "Click Me" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(value)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>不过，在 HTML 中指定事件处理程序有三个缺点。首先，存在一个时差问题。因为用户可能会在 HTML 元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。以前面的例子来说明，假设 <code>showMessage()</code> 函数是在按钮下方、页面的最底部定义的。如果用户在页面解析 <code>showMessage()</code> 函数之前就单击了按钮，就会引发错误。为此，很多HTML事件处理程序都会被封装在一个 <code>try-catch</code> 块中，以便错误不会浮出水面，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样，如果在 <code>showMessage()</code> 函数有定义之前单击了按钮，用户将不会看到 JavaScript 错误，因为在浏览器有机会处理错误之前，错误就被捕获了。</p>
<p>第二个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同 JavaScript 引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错。</p>
<p>第三个缺点是，HTML 与 JavaScript 代码紧密耦合。如果要更换事件处理程序，就要改动两个地方：HTML 代码和 JavaScript 代码。而这正是许多开发人员摒弃 HTML 事件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。</p>
<h3 id="DOM1-级事件处理程序"><a href="#DOM1-级事件处理程序" class="headerlink" title="DOM1 级事件处理程序"></a>DOM1 级事件处理程序</h3><p>通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种为事件处理程序赋值的方法是在第四代Web浏览器中出现的，而且至今仍然为所有现代浏览器所支持。原因一是简单，二是具有跨浏览器的优势。要使用 JavaScript 指定事件处理程序，首先必须取得一个要操作的对象的引用。</p>
<p>每个元素（包括 <code>window</code> 和 <code>document</code>）都有自己的事件处理程序属性，这些属性通常全部小写，例如 <code>onclick</code>。将这种属性的值设置为一个函数，就可以指定事件处理程序，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在此，我们通过文档对象取得了一个按钮的引用，然后为它指定了 <code>onclick</code> 事件处理程序。但要注意，在这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。</p>
<p>使用 DOM1 级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行；换句话说，程序中的 <code>this</code> 引用当前元素。来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);    <span class="comment">// "myBtn"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>单击按钮显示的是元素的 ID，这个 ID 是通过 <code>this.id</code> 取得的。不仅仅是 ID，实际上可以在事件处理程序中通过 <code>this</code> 访问元素的任何属性和方法。以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</p>
<p>也可以删除通过 DOM1 级方法指定的事件处理程序，只要像下面这样将事件处理程序属性的值设置为 <code>null</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="literal">null</span>;     <span class="comment">// 删除事件处理程序</span></div></pre></td></tr></table></figure>
<p>将事件处理程序设置为 <code>null</code> 之后，再单击按钮将不会有任何动作发生。</p>
<h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><p>DOM2 级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：<code>addEventListener()</code> 和 <code>removeEventListener()</code>。所有 DOM 节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 <code>true</code>，表示在捕获阶段调用事件处理程序；如果是 <code>false</code>，表示在冒泡阶段调用事件处理程序。</p>
<p>要在按钮上为 <code>click</code> 事件添加事件处理程序，可以使用下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>上面的代码为一个按钮添加了 <code>onclick</code> 事件处理程序，而且该事件会在冒泡阶段被触发（因为最后一个参数是 <code>false</code>）。与 DOM1 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行。使用 DOM2 级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>这里为按钮添加了两个事件处理程序。这两个事件处理程序会按照添加它们的顺序触发，因此首先会显示元素的 ID，其次会显示 <code>&quot;Hello world!&quot;</code> 消息。</p>
<p>通过 <code>addEventListener()</code> 添加的事件处理程序只能使用 <code>removeEventListener()</code> 来移除；移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过 <code>addEventListener()</code> 添加的匿名函数将无法移除，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line">btn.removeEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 没有用！</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 <code>addEventListener()</code> 添加了一个事件处理程序。虽然调用 <code>removeEventListener()</code> 时看似使用了相同的参数，但实际上，第二个参数与传入 <code>addEventListener()</code> 中的那一个是完全不同的函数。而传入 <code>removeEventListener()</code> 中的事件处理程序函数必须与传 入<code>addEventListener()</code> 中的相同，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">&#125;;</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>);</div><div class="line">btn.removeEventListener(<span class="string">"click"</span>, handler, <span class="literal">false</span>); <span class="comment">// 有效！</span></div></pre></td></tr></table></figure>
<p>重写后的这个例子没有问题，是因为在 <code>addEventListener()</code> 和 <code>removeEventListener()</code> 中使用了相同的函数。</p>
<p>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。如果不是特别需要，我们不建议在事件捕获阶段注册事件处理程序。</p>
<blockquote>
<p>IE9、Firefox、Safari、Chrome 和 Opera 支持 DOM2 级事件处理程序。</p>
</blockquote>
<h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><p>IE 实现了与 DOM 中类似的两个方法：<code>attachEvent()</code> 和 <code>detachEvent()</code>。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于 IE8 及更早版本只支持事件冒泡，所以通过 <code>attachEvent()</code> 添加的事件处理程序都会被添加到冒泡阶段。</p>
<p>要使用 <code>attachEvent()</code> 为按钮添加一个事件处理程序，可以使用以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意，<code>attachEvent()</code> 的第一个参数是 <code>&quot;onclick&quot;</code>，而非 DOM 的 <code>addEventListener()</code> 方法中的 <code>&quot;click&quot;</code>。</p>
<p>在 IE 中使用 <code>attachEvent()</code> 与使用 DOM1 级方法的主要区别在于事件处理程序的作用域。在使用 DOM1 级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用 <code>attachEvent()</code> 方法的情况下，事件处理程序会在全局作用域中运行，因此 <code>this</code> 等于 <code>window</code>。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);    <span class="comment">// true</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在编写跨浏览器的代码时，牢记这一区别非常重要。</p>
<p>与 <code>addEventListener()</code> 类似，<code>attachEvent()</code> 方法也可以用来为一个元素添加多个事件处理程序。不过，与 DOM 方法不同的是，这些事件处理程序不是以添加它们的顺序执行，而是以相反的顺序被触发。</p>
<p>使用 <code>attachEvent()</code> 添加的事件可以通过 <code>detachEvent()</code> 来移除，条件是必须提供相同的参数。与 DOM 方法一样，这也意味着添加的匿名函数将不能被移除。不过，只要能够将对相同函数的引用传给 <code>detachEvent()</code>，就可以移除相应的事件处理程序。</p>
<blockquote>
<p>支持 IE 事件处理程序的浏览器有 IE 和 Opera。</p>
</blockquote>
<h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>为了以跨浏览器的方式处理事件，不少开发人员会使用能够隔离浏览器差异的 JavaScript 库，还有一些开发人员会自己开发最合适的事件处理的方法。自己编写代码其实也不难，只要恰当地使用能力检测即可。要保证处理事件的代码能在大多数浏览器下一致地运行，只需关注冒泡阶段。</p>
<p>第一个要创建的方法是 <code>addHandler()</code>，它的职责是视情况分别使用 DOM1 级方法、DOM2 级方法或 IE 方法来添加事件。这个方法属于一个名叫 <code>EventUtil</code> 的对象，本书将使用这个对象来处理浏览器间的差异。<code>addHandler()</code> 方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。</p>
<p>与 <code>addHandler()</code> 对应的方法是 <code>removeHandler()</code>，它也接受相同的参数。这个方法的职责是移除之前添加的事件处理程序——无论该事件处理程序是采取什么方式添加到元素中的，如果其他方法无效，默认采用 DOM1 级方法。</p>
<p><code>EventUtil</code> 的用法如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener)&#123;</div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</div><div class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123;</div><div class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123;</div><div class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这两个方法首先都会检测传入的元素中是否存在 DOM2 级方法。如果存在 DOM2 级方法，则使用该方法：传入事件类型、事件处理程序函数和第三个参数 <code>false</code>（表示冒泡阶段）。如果存在的是 IE 的方法，则采取第二种方案。注意，为了在 IE8 及更早版本中运行，此时的事件类型必须加上 <code>&quot;on&quot;</code> 前缀。最后一种可能就是使用 DOM1 级方法（在现代浏览器中，应该不会执行这里的代码）。此时，我们使用的是方括号语法来将属性名指定为事件处理程序，或者将属性设置为 <code>null</code>。</p>
<p>可以像下面这样使用 <code>EventUtil</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div><div class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, handler);</div><div class="line">EventUtil.removeHandler(btn, <span class="string">"click"</span>, handler);</div></pre></td></tr></table></figure>
<p><code>addHandler()</code> 和 <code>removeHandler()</code> 没有考虑到所有的浏览器问题，例如在 IE 中的作用域问题。不过，使用它们添加和移除事件处理程序还是足够了。</p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 <code>event</code>，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 <code>event</code> 对象，但支持方式不同。</p>
<h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>兼容 DOM 的浏览器会将一个 <code>event</code> 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM1 级或 DOM2 级），都会传入 <code>event</code> 对象。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);     <span class="comment">// "click"</span></div><div class="line">&#125;;</div><div class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);     <span class="comment">// "click"</span></div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>这个例子中的两个事件处理程序都会弹出一个警告框，显示由 <code>event.type</code> 属性表示的事件类型。这个属性始终都会包含被触发的事件类型，例如 <code>&quot;click&quot;</code>（与传入 <code>addEventListener()</code> 和 <code>removeEventListener()</code> 中的事件类型一致）。</p>
<p>在通过 HTML 特性指定事件处理程序时，变量 <code>event</code> 中保存着 <code>event</code> 对象。请看下面的例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(event.type)"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>以这种方式提供 <code>event</code> 对象，可以让 HTML 特性事件处理程序与 JavaScript 函数执行相同的操作。</p>
<p><code>event</code> 对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过，所有事件都会有下表列出的成员。</p>
<ul>
<li><code>bubbles</code>，表明事件是否冒泡。</li>
<li><code>cancelable</code>，表明是否可以取消事件的默认行为。</li>
<li><code>currentTarget</code>，其事件处理程序当前正在处理事件的那个元素。</li>
<li><code>defaultPrevented</code>，为 <code>true</code> 表示已经调用了 <code>preventDefault()</code>（DOM3 级事件中新增）。</li>
<li><code>detail</code>，与事件相关的细节信息。</li>
<li><code>eventPhase</code>，调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段。</li>
<li><code>preventDefault()</code>，取消事件的默认行为。如果 <code>cancelable</code> 是 <code>true</code>，则可以使用这个方法。</li>
<li><code>stopImmediatePropagation()</code>，取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3 级事件中新增）。</li>
<li><code>stopPropagation()</code>，取消事件的进一步捕获或冒泡。如果 <code>bubbles</code> 为 <code>true</code>，则可以使用这个方法。</li>
<li><code>target</code>，事件的目标。</li>
<li><code>trusted</code>，为 <code>true</code> 表示事件是浏览器生成的。为 <code>false</code> 表示事件是由开发人员通过 JavaScript 创建的（DOM3 级事件中新增）。</li>
<li><code>type</code>，被触发的事件的类型。</li>
<li><code>view</code>，与事件关联的抽象视图，等同于发生事件的 <code>window</code> 对象。</li>
</ul>
<p>在事件处理程序内部，对象 <code>this</code> 始终等于 <code>currentTarget</code> 的值，而 <code>target</code> 则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则 <code>this</code>、<code>currentTarget</code> 和 <code>target</code> 包含相同的值。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.currentTarget === <span class="keyword">this</span>);    <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(event.target === <span class="keyword">this</span>);           <span class="comment">// true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个例子检测了 <code>currentTarget</code> 和 <code>target</code> 与 <code>this</code> 的值。由于 <code>click</code> 事件的目标是按钮，因此这三个值是相等的。如果事件处理程序存在于按钮的父节点中（例如 <code>document.body</code>），那么这些值是不相同的。再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.currentTarget === <span class="built_in">document</span>.body);  <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">document</span>.body);                 <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(event.target === <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>));  <span class="comment">// true</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当单击这个例子中的按钮时，<code>this</code> 和 <code>currentTarget</code> 都等于<code>document.body</code>，因为事件处理程序是注册到这个元素上的。然而，<code>target</code> 元素却等于按钮元素，因为它是 <code>click</code> 事件真正的目标。由于按钮上并没有注册事件处理程序，结果 <code>click</code> 事件就冒泡到了 <code>document.body</code>，在那里事件才得到了处理。</p>
<p>在需要通过一个函数处理多个事件时，可以使用 <code>type</code> 属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(event.type)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"click"</span>:</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"mouseover"</span>:</div><div class="line">            event.target.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"mouseout"</span>:</div><div class="line">            event.target.style.backgroundColor = <span class="string">""</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">btn.onclick = handler;</div><div class="line">btn.onmouseover = handler;</div><div class="line">btn.onmouseout = handler;</div></pre></td></tr></table></figure>
<p>这个例子定义了一个名为 <code>handler</code> 的函数，用于处理3种事件：<code>click</code>、<code>mouseover</code> 和 <code>mouseout</code>。当单击按钮时，会出现一个与前面例子中一样的警告框。当按钮移动到按钮上面时，背景颜色应该会变成红色，而当鼠标移动出按钮的范围时，背景颜色应该会恢复为默认值。这里通过检测 <code>event.type</code> 属性，让函数能够确定发生了什么事件，并执行相应的操作。</p>
<p>要阻止特定事件的默认行为，可以使用 <code>preventDefault()</code> 方法。例如，链接的默认行为就是在被单击时会导航到其 <code>href</code> 特性指定的 URL。如果你想阻止链接导航这一默认行为，那么通过链接的 <code>onclick</code> 事件处理程序可以取消它，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event.preventDefault();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只有 <code>cancelable</code> 属性设置为 <code>true</code> 的事件，才可以使用 <code>preventDefault()</code> 来取消其默认行为。</p>
<p>另外，<code>stopPropagation()</code> 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用 <code>stopPropagation()</code>，从而避免触发注册在 <code>document.body</code> 上面的事件处理程序，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">    event.stopPropagation();</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于这个例子而言，如果不调用 <code>stopPropagation()</code>，就会在单击按钮时出现两个警告框。可是，由于 <code>click</code> 事件根本不会传播到 <code>document.body</code>，因此就不会触发注册在这个元素上的 <code>onclick</code> 事件处理程序。</p>
<p>事件对象的 <code>eventPhase</code> 属性，可以用来确定事件当前正位于事件流的哪个阶段。如果是在捕获阶段调用的事件处理程序，那么 <code>eventPhase</code> 等于 <code>1</code>；如果事件处理程序处于目标对象上，则 <code>eventPhase</code> 等于 <code>2</code>；如果是在冒泡阶段调用的事件处理程序，<code>eventPhase</code> 等于 <code>3</code>。这里要注意的是，尽管“处于目标”发生在冒泡阶段，但 <code>eventPhase</code> 仍然一直等于 <code>2</code>。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 2</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 1</span></div><div class="line">&#125;, <span class="literal">true</span>);</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.eventPhase); <span class="comment">// 3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当单击这个例子中的按钮时，首先执行的事件处理程序是在捕获阶段触发的添加到 <code>document.body</code> 中的那一个，结果会弹出一个警告框显示表示 <code>eventPhase</code> 的 <code>1</code>。接着，会触发在按钮上注册的事件处理程序，此时的 <code>eventPhase</code> 值为 <code>2</code>。最后一个被触发的事件处理程序，是在冒泡阶段执行的添加到 <code>document.body</code> 上的那一个，显示 <code>eventPhase</code> 的值为 <code>3</code>。而当 <code>eventPhase</code> 等于 <code>2</code> 时，<code>this</code>、<code>target</code> 和 <code>currentTarget</code> 始终都是相等的。</p>
<blockquote>
<p>只有在事件处理程序执行期间，<strong>event</strong>对象才会存在；一旦事件处理程序执行完成，<strong>event</strong>对象就会被销毁。</p>
</blockquote>
<h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><p>与访问 DOM 中的 <code>event</code> 对象不同，要访问IE中的 <code>event</code> 对象有几种不同的方式，取决于指定事件处理程序的方法。在使用 DOM1 级方法添加事件处理程序时，<code>event</code> 对象作为 <code>window</code> 对象的一个属性存在。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</div><div class="line">    <span class="built_in">console</span>.log(event.type);     <span class="comment">// "click"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在此，我们通过 <code>window.event</code> 取得了 <code>event</code> 对象，并检测了被触发事件的类型（IE 中的 <code>type</code> 属性与 DOM 中的 <code>type</code> 属性是相同的）。可是，如果事件处理程序是使用 <code>attachEvent()</code> 添加的，那么就会有一个 <code>event</code> 对象作为参数被传入事件处理程序函数中，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);     <span class="comment">// "click"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在像这样使用 <code>attachEvent()</code> 的情况下，也可以通过 <code>window</code> 对象来访问 <code>event</code> 对象，就像使用 DOM1 级方法时一样。不过为方便起见，同一个对象也会作为参数传递。</p>
<p>如果是通过 HTML 特性指定的事件处理程序，那么还可以通过一个名叫 <code>event</code> 的变量来访问 <code>event</code> 对象（与 DOM 中的事件模型相同）。再看一个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"console.log(event.type)"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>IE 的 <code>event</code> 对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的或者相关的 DOM 属性和方法。与 DOM 的 <code>event</code> 对象一样，这些属性和方法也会因为事件类型的不同而不同，但所有事件对象都会包含下表所列的属性和方法。</p>
<ul>
<li><code>cancelBubble</code>，默认值为 <code>false</code>，但将其设置为 <code>true</code> 就可以取消事件冒泡（与 DOM 中的 <code>stopPropagation()</code> 方法的作用相同）。</li>
<li><code>returnValue</code>，默认值为 <code>true</code>，但将其设置为 <code>false</code> 就可以取消事件的默认行为（与 DOM 中的 <code>preventDefault()</code> 方法的作用相同） 。</li>
<li><code>srcElement</code>，事件的目标（与 DOM 中的 <code>target</code> 属性相同） 。</li>
<li><code>type</code>，被触发的事件的类型 。</li>
</ul>
<p>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为 <code>this</code> 会始终等于事件目标。故而，最好还是使用 <code>event.srcElement</code> 比较保险。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>);  <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.srcElement === <span class="keyword">this</span>);         <span class="comment">// false</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在第一个事件处理程序中（使用 DOM1 级方法指定的），<code>srcElement</code> 属性等于 <code>this</code>，但在第二个事件处理程序中，这两者的值不相同。</p>
<p>如前所述，<code>returnValue</code> 属性相当于 DOM 中的 <code>preventDefault()</code> 方法，它们的作用都是取消给定事件的默认行为。只要将 <code>returnValue</code> 设置为 <code>false</code>，就可以阻止默认行为。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个例子在 <code>onclick</code> 事件处理程序中使用 <code>returnValue</code> 达到了阻止链接默认行为的目的。与 DOM 不同的是，在此没有办法确定事件是否能被取消。</p>
<p>相应地，<code>cancelBubble</code> 属性与 DOM 中的 <code>stopPropagation()</code> 方法作用相同，都是用来停止事件冒泡的。由于IE不支持事件捕获，因而只能取消事件冒泡；但 <code>stopPropagatioin()</code> 可以同时取消事件捕获和冒泡。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过在 <code>onclick</code> 事件处理程序中将 <code>cancelBubble</code> 设置为 <code>true</code>，就可阻止事件通过冒泡而触发 <code>document.body</code> 中注册的事件处理程序。结果，在单击按钮之后，只会显示一个警告框。</p>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><p>虽然 DOM 和 IE 中的 <code>event</code> 对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。IE中 <code>event</code> 对象的全部信息和方法 DOM 对象中都有，只不过实现方式不一样。不过，这种对应关系让实现两种事件模型之间的映射非常容易。可以对前面介绍的 <code>EventUtil</code> 对象加以增强，添加如下方法以求同存异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="comment">// 省略的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.preventDefault)&#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="comment">// 省略的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.stopPropagation)&#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码显示，我们为 <code>EventUtil</code> 添加了4个新方法。第一个是 <code>getEvent()</code>，它返回对 <code>event</code> 对象的引用。考虑到 IE 中事件对象的位置不同，可以使用这个方法来取得 <code>event</code> 对象，而不必担心指定事件处理程序的方式。在使用这个方法时，必须假设有一个事件对象传入到事件处理程序中，而且要把该变量传给这个方法，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在兼容 DOM 的浏览器中，<code>event</code> 变量只是简单地传入和返回。而在 IE 中，<code>event</code> 参数是未定义的  <code>undefined</code>，因此就会返回 <code>window.event</code>。将这一行代码添加到事件处理程序的开头，就可以确保随时都能使用 <code>event</code> 对象，而不必担心用户使用的是什么浏览器。</p>
<p>第二个方法是 <code>getTarget()</code>，它返回事件的目标。在这个方法内部，会检测 <code>event</code> 对象的 <code>target</code> 属性，如果存在则返回该属性的值；否则，返回 <code>srcElement</code> 属性的值。可以像下面这样使用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第三个方法是 <code>preventDefault()</code>，用于取消事件的默认行为。在传入 <code>event</code> 对象后，这个方法会检查是否存在 <code>preventDefault()</code> 方法，如果存在则调用该方法。如果 <code>preventDefault()</code> 方法不存在，则将 <code>returnValue</code> 设置为 <code>false</code>。下面是使用这个方法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"myLink"</span>);</div><div class="line">link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    EventUtil.preventDefault(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码可以确保在所有浏览器中单击该链接都不会打开另一个页面。首先，使用 <code>EventUtil.getEvent()</code> 取得 <code>event</code> 对象，然后将其传入到 <code>EventUtil.preventDefault()</code> 以取消默认行为。</p>
<p>第四个方法是 <code>stopPropagation()</code>，其实现方式类似。首先尝试使用DOM方法阻止事件流，否则就使用 <code>cancelBubble</code> 属性。下面看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">    event = EventUtil.getEvent(event);</div><div class="line">    EventUtil.stopPropagation(event);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Body clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在此，首先使用 <code>EventUtil.getEvent()</code> 取得了 <code>event</code> 对象，然后又将其传入到 <code>EventUtil.stopPropagation()</code>。别忘了由于 IE 不支持事件捕获，因此这个方法在跨浏览器的情况下，也只能用来阻止事件冒泡。</p>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>Web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信息，而 DOM3 级事件规定了以下几类事件。</p>
<ul>
<li>UI（User Interface，用户界面）事件，当用户与页面上的元素交互时触发；</li>
<li>焦点事件，当元素获得或失去焦点时触发；</li>
<li>鼠标事件，当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件，当使用鼠标滚轮（或类似设备）时触发；</li>
<li>文本事件，当在文档中输入文本时触发；</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件，当为IME（Input Method Editor，输入法编辑器）输入字符时触发；</li>
<li>变动（mutation）事件，当底层 DOM 结构发生变化时触发。</li>
<li>变动名称事件，当元素或属性名变动时触发。此类事件已经被废弃，没有任何浏览器实现它们，因此本章不做介绍。</li>
</ul>
<p>除了这几类事件之外，HTML5 也定义了一组事件，而有些浏览器还会在 DOM 和 BOM 中实现其他专有事件。这些专有的事件一般都是根据开发人员需求定制的，没有什么规范，因此不同浏览器的实现有可能不一致。</p>
<p>DOM3 级事件模块在 DOM2 级事件模块基础上重新定义了这些事件，也添加了一些新事件。包括 IE9 在内的所有主流浏览器都支持 DOM2 级事件。 IE9 也支持 DOM3 级事件。</p>
<blockquote>
<p>想要了解更多 DOM 和 HTML5 事件，请参见最新版的 W3C 规范：<br><a href="https://www.w3.org/TR/uievents/" target="_blank" rel="external">https://www.w3.org/TR/uievents/</a></p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>事件是将 JavaScript 与网页联系在一起的主要方式。DOM3 级事件规范和 HTML5 定义了常见的大多数事件。即使有规范定义了基本事件，但很多浏览器仍然在规范之外实现了自己的专有事件，从而为开发人员提供更多掌握用户交互的手段。有些专有事件与特定设备关联，例如移动 Safari 中的 <code>orientationchange</code> 事件就是特定关联 iOS 设备的。</p>
<p>在使用事件时，需要考虑如下一些内存与性能方面的问题。</p>
<ul>
<li>有必要限制一个页面中事件处理程序的数量，数量太多会导致占用大量内存，而且也会让用户感觉页面反应不够灵敏。</li>
<li>建立在事件冒泡机制之上的事件委托技术，可以有效地减少事件处理程序的数量。</li>
<li>建议在浏览器卸载页面之前移除页面中的所有事件处理程序。</li>
</ul>
<p>可以使用 JavaScript 在浏览器中模拟事件。DOM2 级事件和 DOM3 级事件规范规定了模拟事件的方法，为模拟各种有定义的事件提供了方便。此外，通过组合使用一些技术，还可以在某种程度上模拟键盘事件。IE8 及之前版本同样支持事件模拟，只不过模拟的过程有些差异。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>凭理解和记忆手写 <code>EventUtil</code> 通用类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="comment">// 待补充的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web 浏览器就会产生事件（event）。例如，当 Web 浏览器加载完文档、用户把鼠标指针移到超链接上或敲击键盘时，Web 浏览器都会产生事件。如果 JavaScript 应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于 Web 编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事情发生（即，它们等待事件发生），然后它们响应。&lt;/p&gt;
&lt;p&gt;请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情，这种在传统软件工程中被称为观察员模式。&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;当浏览器发展到第四代时（IE4 及 Netscape Communicator 4），浏览器开发团队遇到了一个很有意思的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件流&lt;/strong&gt;描述的是从页面中接收事件的顺序。但有意思的是，IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。&lt;/p&gt;
&lt;h3 id=&quot;事件冒泡&quot;&gt;&lt;a href=&quot;#事件冒泡&quot; class=&quot;headerlink&quot; title=&quot;事件冒泡&quot;&gt;&lt;/a&gt;事件冒泡&lt;/h3&gt;&lt;p&gt;IE 的事件流叫做&lt;strong&gt;事件冒泡&lt;/strong&gt;（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Event Bubbling Example&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myDiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Click Me&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你单击了页面中的 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 元素，那么这个 &lt;code&gt;click&lt;/code&gt; 事件会按照如下顺序传播：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，&lt;code&gt;click&lt;/code&gt; 事件首先在 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 元素上发生，而这个元素就是我们单击的元素。然后，&lt;code&gt;click&lt;/code&gt; 事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 &lt;code&gt;document&lt;/code&gt; 对象。下图展示了事件冒泡的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn.shisb.com/blog/javascript-lesson/2.3/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之 DOM（下）</title>
    <link href="http://shisb.com/2016/11/22/javascript-lesson-2.2-DOM-2/"/>
    <id>http://shisb.com/2016/11/22/javascript-lesson-2.2-DOM-2/</id>
    <published>2016-11-22T14:30:00.000Z</published>
    <updated>2016-11-22T12:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><p>除了 <code>Document</code> 类型之外，<code>Element</code> 类型就要算是 Web 编程中最常用的类型了。<code>Element</code> 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。<code>Element</code> 节点具有以下特征：</p>
<ul>
<li><code>nodeType</code> 的值为1；</li>
<li><code>nodeName</code> 的值为元素的标签名；</li>
<li><code>nodeValue</code> 的值为 <code>null</code>；</li>
<li><code>parentNode</code> 可能是 <code>Document</code> 或 <code>Element</code>；</li>
<li>其子节点可能是 <code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code> 或 <code>EntityReference</code>。</li>
</ul>
<p>要访问元素的标签名，可以使用 <code>nodeName</code> 属性，也可以使用 <code>tagName</code> 属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a> 
<p>可以像下面这样取得这个元素及其标签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.tagName); <span class="comment">// "DIV"</span></div><div class="line"><span class="built_in">console</span>.log(div.tagName === div.nodeName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这里的元素标签名是 <code>div</code>，它拥有一个值为 <code>&quot;myDiv&quot;</code> 的ID。可是，<code>div.tagName</code> 实际上输出的是 <code>&quot;DIV&quot;</code> 而非 <code>&quot;div&quot;</code>。在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不能这样比较，很容易出错！</span></div><div class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>)&#123; </div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这样最好（适用于任何文档）</span></div><div class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>)&#123; </div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h4><p>所有 HTML 元素都由 <code>HTMLElement</code> 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。<code>HTMLElement</code> 类型直接继承自 <code>Element</code> 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。</p>
<ul>
<li><code>id</code>，元素在文档中的唯一标识符。</li>
<li><code>title</code>，有关元素的附加说明信息，一般通过工具提示条显示出来。</li>
<li><code>lang</code>，元素内容的语言代码，很少使用。</li>
<li><code>dir</code>，语言的方向，值为 <code>&quot;ltr&quot;</code>（left-to-right，从左至右）或 <code>&quot;rtl&quot;</code>（right-to-left，从右至左），也很少使用。</li>
<li><code>className</code>，与元素的 <code>class</code> 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 <code>class</code>，是因为 <code>class</code> 是 JavaScript 的保留字。</li>
</ul>
<p>上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">class</span>=<span class="string">"bd"</span> <span class="attr">title</span>=<span class="string">"Body text"</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>元素中指定的所有信息，都可以通过下列 JavaScript 代码取得：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.id);         <span class="comment">// "myDiv""</span></div><div class="line"><span class="built_in">console</span>.log(div.className);  <span class="comment">// "bd"</span></div><div class="line"><span class="built_in">console</span>.log(div.title);      <span class="comment">// "Body text"</span></div><div class="line"><span class="built_in">console</span>.log(div.lang);       <span class="comment">// "en"</span></div><div class="line"><span class="built_in">console</span>.log(div.dir);        <span class="comment">// "ltr"</span></div></pre></td></tr></table></figure>
<p>当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.className = <span class="string">"ft"</span>;</div><div class="line">div.title = <span class="string">"Some other text"</span>;</div><div class="line">div.lang = <span class="string">"fr"</span>;</div><div class="line">div.dir =<span class="string">"rtl"</span>;</div></pre></td></tr></table></figure>
<p>并不是对所有属性的修改都会在页面中直观地表现出来。对 <code>id</code> 或 <code>lang</code> 的修改对用户而言是透明不可见的（假设没有基于它们的值设置的 CSS 样式），而对 <code>title</code> 的修改则只会在鼠标移动到这个元素之上时才会显示出来。对 <code>dir</code> 的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。修改 <code>className</code> 时，如果新类关联了与此前不同的 CSS 样式，那么就会立即应用新的样式。</p>
<h4 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的 DOM 方法主要有三个，分别是 <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code>。这三个方法可以针对任何特性使用，包括那些以 <code>HTMLElement</code> 类型属性的形式定义的特性。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"id"</span>));     <span class="comment">// "myDiv"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"class"</span>));  <span class="comment">// "bd"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"title"</span>));  <span class="comment">// "Body text"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"lang"</span>));   <span class="comment">// "en"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"dir"</span>));    <span class="comment">// "ltr"</span></div></pre></td></tr></table></figure>
<p>注意，传递给 <code>getAttribute()</code> 的特性名与实际的特性名相同。因此要想得到 <code>class</code> 特性值，应该传入 <code>&quot;class&quot;</code> 而不是 <code>&quot;className&quot;</code>，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，<code>getAttribute()</code> 返回 <code>null</code>。</p>
<p>通过 <code>getAttribute()</code> 方法也可以取得自定义特性（即标准 HTML 语言中没有的特性）的值，以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">my_special_attribute</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个元素包含一个名为 <code>my_special_attribute</code> 的自定义特性，它的值是 <code>&quot;hello!&quot;</code>。可以像取得其他特性一样取得这个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = div.getAttribute(<span class="string">"my_special_attribute"</span>);</div></pre></td></tr></table></figure>
<p>不过，特性的名称是不区分大小写的，即 <code>&quot;ID&quot;</code> 和 <code>&quot;id&quot;</code> 代表的都是同一个特性。另外也要注意，根据 HTML5 规范，自定义特性应该加上 <code>data-</code> 前缀以便验证。</p>
<p>任何元素的所有特性，也都可以通过 DOM 元素本身的属性来访问。当然，<code>HTMLElement</code> 也会有5个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到 DOM 对象中。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">align</span>=<span class="string">"left"</span> <span class="attr">my_special_attribute</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>因为 <code>id</code> 和 <code>align</code> 在 HTML 中是 <code>div</code> 的公认特性，因此该元素的 DOM 对象中也将存在对应的属性。不过，自定义特性 <code>my_special_attribute</code> 在 Safari、Opera、Chrome 及 Firefox 中是不存在的；但 IE 却会为自定义特性也创建属性，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(div.id);                      <span class="comment">// "myDiv"</span></div><div class="line"><span class="built_in">console</span>.log(div.my_special_attribute);    <span class="comment">// undefined（IE除外）</span></div><div class="line"><span class="built_in">console</span>.log(div.align);                   <span class="comment">// "left"</span></div></pre></td></tr></table></figure>
<p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过 <code>getAttribute()</code> 返回的值并不相同。第一类特性就是 <code>style</code>，用于通过 CSS 为元素指定样式。在通过 <code>getAttribute()</code> 访问时，返回的 <code>style</code> 特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。由于 <code>style</code> 属性是用于以编程方式访问元素样式的，因此并没有直接映射到 <code>style</code> 特性。</p>
<p>第二类与众不同的特性是 <code>onclick</code> 这样的事件处理程序。当在元素上使用时，<code>onclick</code> 特性中包含的是 JavaScript 代码，如果通过 <code>getAttribute()</code> 访问，则会返回相应代码的字符串。而在访问 <code>onclick</code> 属性时，则会返回一个 JavaScript 函数（如果未在元素中指定相应特性，则返回 null）。这是因为 <code>onclick</code> 及其他事件处理程序属性本身就应该被赋予函数值。</p>
<p>由于存在这些差别，在通过 JavaScript 以编程方式操作 DOM 时，开发人员经常不使用 <code>getAttribute()</code>，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用 <code>getAttribute()</code> 方法。</p>
<h4 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h4><p>与 <code>getAttribute()</code> 对应的方法是 <code>setAttribute()</code>，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，<code>setAttribute()</code> 会以指定的值替换现有的值；如果特性不存在，<code>setAttribute()</code> 则创建该属性并设置相应的值。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.setAttribute(<span class="string">"id"</span>, <span class="string">"someOtherId"</span>);</div><div class="line">div.setAttribute(<span class="string">"class"</span>, <span class="string">"ft"</span>);</div><div class="line">div.setAttribute(<span class="string">"title"</span>, <span class="string">"Some other text"</span>);</div><div class="line">div.setAttribute(<span class="string">"lang"</span>,<span class="string">"fr"</span>);</div><div class="line">div.setAttribute(<span class="string">"dir"</span>, <span class="string">"rtl"</span>);</div></pre></td></tr></table></figure>
<p>通过 <code>setAttribute()</code> 方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式，即 <code>&quot;ID&quot;</code> 最终会变成 <code>&quot;id&quot;</code>。</p>
<p>因为所有特性都是属性，所以直接给属性赋值可以设置特性的值，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.align = <span class="string">"left"</span>;</div></pre></td></tr></table></figure>
<p>不过，像下面这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.mycolor = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(div.mycolor); <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">// null（IE除外）</span></div></pre></td></tr></table></figure>
<p>这个例子添加了一个名为 <code>mycolor</code> 的属性并将它的值设置为 <code>&quot;red&quot;</code>。在大多数浏览器中，这个属性都不会自动变成元素的特性，因此想通过 <code>getAttribute()</code> 取得同名特性的值，结果会返回 <code>null</code>。可是，自定义属性在 IE 中会被当作元素的特性，反之亦然。</p>
<p>要介绍的最后一个方法是 <code>removeAttribute()</code>，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.removeAttribute(<span class="string">"class"</span>);</div></pre></td></tr></table></figure>
<p>这个方法并不常用，但在序列化 DOM 元素时，可以通过它来确切地指定要包含哪些特性。</p>
<h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用 <code>document.createElement()</code> 方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在 HTML 文档中不区分大小写。例如，使用下面的代码可以创建一个 <code>div</code> 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div></pre></td></tr></table></figure>
<p>在使用 <code>createElement()</code> 方法创建新元素的同时，也为新元素设置了 <code>ownerDocuemnt</code> 属性。此时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"myNewDiv"</span>;</div><div class="line">div.className = <span class="string">"box"</span>;</div></pre></td></tr></table></figure>
<p>在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用 <code>appendChild()</code>、<code>insertBefore()</code> 或 <code>replaceChild()</code> 方法。下面的代码会把新创建的元素添加到文档的 <code>&lt;body&gt;</code> 元素中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p>
<h4 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h4><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的 <code>childNodes</code> 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同，以下面的代码为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果是 IE8 来解析这些代码，那么 <code>&lt;ul&gt;</code> 元素会有3个子节点，分别是3个 <code>&lt;li&gt;</code> 元素。但如果是在其他浏览器中，<code>&lt;ul&gt;</code> 元素都会有7个元素，包括3个 <code>&lt;li&gt;</code> 元素和4个文本节点（表示 <code>&lt;li&gt;</code> 元素之间的空白符）。如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于这段代码，<code>&lt;ul&gt;</code> 元素在任何浏览器中都会包含3个子节点。如果需要通过 <code>childNodes</code> 属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下 <code>nodeTpye</code> 属性，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=element.childNodes.length; i &lt; len; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>)&#123;</div><div class="line">        <span class="comment">//执行某些操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子会循环遍历特定元素的每一个子节点，然后只在子节点的 <code>nodeType</code> 等于1（表示是元素节点）的情况下，才会执行某些操作。</p>
<p>如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持 <code>getElementsByTagName()</code> 方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过 <code>document</code> 调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面 <code>&lt;ul&gt;</code> 元素中包含的所有 <code>&lt;li&gt;</code> 元素，可以使用下列代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</div><div class="line"><span class="keyword">var</span> items = ul.getElementsByTagName(<span class="string">"li"</span>);</div></pre></td></tr></table></figure>
<p>要注意的是，这里 <code>&lt;ul&gt;</code> 的后代中只包含直接子元素。不过，如果它包含更多层次的后代元素，那么各个层次中包含的 <code>&lt;li&gt;</code> 元素也都会返回。</p>
<h3 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h3><p>文本节点由 <code>Text</code> 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码。<code>Text</code> 节点具有以下特征：</p>
<ul>
<li><code>nodeType</code> 的值为3；</li>
<li><code>nodeName</code> 的值为 <code>&quot;#text&quot;</code>；</li>
<li><code>nodeValue</code> 的值为节点所包含的文本；</li>
<li><code>parentNode</code> 是一个 <code>Element</code>；</li>
<li>不支持（没有）子节点。</li>
</ul>
<p>可以通过 <code>nodeValue</code> 属性或 <code>data</code> 属性访问 <code>Text</code> 节点中包含的文本，这两个属性中包含的值相同。对 <code>nodeValue</code>的修改也会通过 <code>data</code> 反映出来，反之亦然。使用下列方法可以操作节点中的文本。</p>
<ul>
<li><code>appendData(*text*)</code>：将 <code>*text*</code> 添加到节点的末尾。</li>
<li><code>deleteData(*offset*, *count*)</code>：从 <code>*offset*</code> 指定的位置开始删除 <code>*count*</code> 个字符。</li>
<li><code>insertData(*offset, text*)</code>：在 <code>*offset*</code> 指定的位置插入 <code>*text*</code>。</li>
<li><code>replaceData(*offset, count, text*)</code>：用 <code>*text*</code> 替换从 <code>*offset*</code> 指定的位置开始到 <code>*offset*+*count*</code> 为止处的文本。</li>
<li><code>splitText(*offset*)</code>：从 <code>*offset*</code> 指定的位置将当前文本节点分成两个文本节点。</li>
<li><code>substringData(*offset, count*)</code>：提取从 <code>*offset*</code> 指定的位置开始到 <code>*offset+count*</code> 为止处的字符串。</li>
</ul>
<p>除了这些方法之外，文本节点还有一个 <code>length</code> 属性，保存着节点中字符的数目。而且，<code>nodeValue.length</code> 和 <code>data.length</code> 中也保存着同样的值。</p>
<p>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。来看几个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 没有内容，也就没有文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 有空格，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 有内容，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面代码给出的第一个 <code>&lt;div&gt;</code> 元素没有内容，因此也就不存在文本节点。开始与结束标签之间只要存在内容，就会创建一个文本节点。因此，第二个 <code>&lt;div&gt;</code> 元素中虽然只包含一个空格，但仍然有一个文本子节点；文本节点的 <code>nodeValue</code> 值是一个空格。第三个 <code>div</code> 也有一个文本节点，其 <code>nodeValue</code> 的值为 <code>&quot;Hello World!&quot;</code>。可以使用以下代码来访问这些文本子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textNode = div.firstChild;  <span class="comment">// 或者div.childNodes[0]</span></div></pre></td></tr></table></figure>
<p>在取得了文本节点的引用后，就可以像下面这样来修改它了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.firstChild.nodeValue = <span class="string">"Some other message"</span>;</div></pre></td></tr></table></figure>
<p>如果这个文本节点当前存在于文档树中，那么修改文本节点的结果就会立即得到反映。另外，在修改文本节点时还要注意，此时的字符串会经过 HTML（或XML，取决于文档类型）编码。换句话说，小于号、大于号或引号都会像下面的例子一样被转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"</span></div><div class="line">div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</div></pre></td></tr></table></figure>
<p>应该说，这是在向 DOM 文档中插入文本之前，先对其进行 HTML 编码的一种有效方式。</p>
<blockquote>
<p>在 IE8、Firefox、Safari、Chrome 和 Opera中，可以通过脚本访问 <code>Text</code> 类型的构造函数和原型。</p>
</blockquote>
<h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>可以使用 <code>document.createTextNode()</code> 创建新文本节点，这个方法接受一个参数——要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照 HTML 或 XML 的格式进行编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world!"</span>);</div></pre></td></tr></table></figure>
<p>在创建新文本节点的同时，也会为其设置 <code>ownerDocument</code> 属性。不过，除非把新节点添加到文档树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个 <code>&lt;div&gt;</code> 元素并向其中添加一条消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure>
<p>这个例子创建了一个新 <code>&lt;div&gt;</code> 元素并为它指定了值为 <code>&quot;message&quot;</code> 的 <code>class</code> 特性。然后，又创建了一个文本节点，并将其添加到前面创建的元素中。最后一步，就是将这个元素添加到了文档的 <code>&lt;body&gt;</code> 元素中，这样就可以在浏览器中看到新创建的元素和文本节点了。</p>
<p>一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Yippee!"</span>);</div><div class="line">element.appendChild(anotherTextNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure>
<p>如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。</p>
<h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM 文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM 文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由 <code>Node</code> 类型定义的（因而在所有节点类型中都存在），名叫 <code>normalize()</code>。如果在一个包含两个或多个文本节点的父元素上调用 <code>normalize()</code> 方法，则会将所有文本节点合并成一个节点，结果节点的 <code>nodeValue</code> 等于将合并前每个文本节点的 <code>nodeValue</code> 值拼接起来的值。来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Yippee!"</span>);</div><div class="line">element.appendChild(anotherTextNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div><div class="line"><span class="built_in">console</span>.log(element.childNodes.length);    <span class="comment">// 2</span></div><div class="line"></div><div class="line">element.normalize();</div><div class="line"><span class="built_in">console</span>.log(element.childNodes.length);    <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(element.firstChild.nodeValue); <span class="comment">// "Hello world!Yippee!"</span></div></pre></td></tr></table></figure>
<p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</p>
<h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p><code>Text</code> 类型提供了一个作用与 <code>normalize()</code> 相反的方法 <code>splitText()</code>。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 <code>nodeValue</code> 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 <code>parentNode</code> 相同。</p>
<h3 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h3><p>注释在 DOM 中是通过 <code>Comment</code> 类型来表示的。<code>Comment</code> 节点具有下列特征：</p>
<ul>
<li><code>nodeType</code> 的值为8；</li>
<li><code>nodeName</code> 的值为 <code>&quot;#comment&quot;</code>；</li>
<li><code>nodeValue</code> 的值是注释的内容；</li>
<li><code>parentNode</code> 可能是 <code>Document</code> 或 <code>Element</code>；</li>
<li>不支持（没有）子节点。</li>
</ul>
<p><code>Comment</code> 类型与 <code>Text</code> 类型继承自相同的基类，因此它拥有除<code>splitText()</code> 之外的所有字符串操作方法。与 <code>Text</code> 类型相似，也可以通过 <code>nodeValue</code> 或 <code>data</code> 属性来取得注释的内容。</p>
<p>注释节点可以通过其父节点来访问，以下面的代码为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="comment">&lt;!--A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在此，注释节点是 <code>&lt;div&gt;</code> 元素的一个子节点，因此可以通过下面的代码来访问它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">var</span> comment = div.firstChild;</div><div class="line"><span class="built_in">console</span>.log(comment.data);    <span class="comment">// "A comment"</span></div></pre></td></tr></table></figure>
<p>另外，使用 <code>document.createComment()</code> 并为其传递注释文本也可以创建注释节点，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"A comment "</span>);</div></pre></td></tr></table></figure>
<p>显然，开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。此外，浏览器也不会识别位于 <code>&lt;/html&gt;</code> 标签后面的注释。如果要访问注释节点，一定要保证它们位于 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> 之间。</p>
<h3 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h3><p>元素的特性在 DOM 中以 <code>Attr</code> 类型来表示。在所有浏览器中（包括 IE8），都可以访问 <code>Attr</code> 类型的构造函数和原型。从技术角度讲，特性就是存在于元素的 <code>attributes</code> 属性中的节点。特性节点具有下列特征：</p>
<ul>
<li><code>nodeType</code> 的值为11；</li>
<li><code>nodeName</code> 的值是特性的名称；</li>
<li><code>nodeValue</code> 的值是特性的值；</li>
<li><code>parentNode</code> 的值为 <code>null</code>；</li>
<li>在 HTML 中不支持（没有）子节点；</li>
<li>在 XML 中子节点可以是 <code>Text</code>或 <code>EntityReference</code>。</li>
</ul>
<p>尽管它们也是节点，但特性却不被认为是 DOM 文档树的一部分。开发人员最常使用的是 <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>remveAttribute()</code> 方法，很少直接引用特性节点。</p>
<p><code>Attr</code> 对象有3个属性：<code>name</code>、<code>value</code> 和 <code>specified</code>。其中，<code>name</code> 是特性名称（与 <code>nodeName</code> 的值相同），<code>value</code> 是特性的值（与 <code>nodeValue</code> 的值相同），而 <code>specified</code> 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。</p>
<p>使用 <code>document.createAttribute()</code> 并传入特性的名称可以创建新的特性节点。例如，要为元素添加 <code>align</code> 特性，可以使用下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">"align"</span>);</div><div class="line">attr.value = <span class="string">"left"</span>;</div><div class="line">element.setAttributeNode(attr);</div><div class="line"><span class="built_in">console</span>.log(element.attributes[<span class="string">"align"</span>].value);       <span class="comment">// "left"</span></div><div class="line"><span class="built_in">console</span>.log(element.getAttributeNode(<span class="string">"align"</span>).value); <span class="comment">// "left"</span></div><div class="line"><span class="built_in">console</span>.log(element.getAttribute(<span class="string">"align"</span>));           <span class="comment">// "left"</span></div></pre></td></tr></table></figure>
<p>添加特性之后，可以通过下列任何方式访问该特性：<code>attributes</code> 属性、<code>getAttributeNode()</code> 方法以及 <code>getAttribute()</code> 方法。其中，<code>attributes</code> 和 <code>getAttributeNode()</code> 都会返回对应特性的 <code>Attr</code> 节点，而 <code>getAttribute()</code> 则只返回特性的值。</p>
<h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><p>很多时候，DOM 操作都比较简明，因此用 JavaScript 生成那些通常原本是用 HTML 代码生成的内容并不麻烦。不过，也有一些时候，操作 DOM 并不像表面上看起来那么简单。由于浏览器中充斥着隐藏的陷阱和不兼容问题，用 JavaScript 代码处理 DOM 的某些部分要比处理其他部分更复杂一些。</p>
<h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>使用 <code>&lt;script&gt;</code> 元素可以向页面中插入 JavaScript 代码，一种方式是通过其 <code>src</code> 特性包含外部文件，另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加的脚本。跟操作 HTML 元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入 JavaScript 代码。</p>
<p>动态加载的外部 JavaScript 文件能够立即运行，比如下面的 <code>&lt;script&gt;</code> 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"client.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>创建这个 DOM 节点的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    script.src = url;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是调用这个函数的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadScript(<span class="string">"client.js"</span>);</div></pre></td></tr></table></figure>
<p>另一种指定 JavaScript 代码的方式是行内方式，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>从逻辑上讲，下面操作的 DOM 代码是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>));</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<p>在 Firefox、Safari、Chrome 和 Opera 中，这些 DOM 代码可以正常运行。但在 IE 中，则会导致错误。IE 将 <code>&lt;script&gt;</code> 视为一个特殊的元素，不允许 DOM 访问其子节点。不过，可以使用 <code>&lt;script&gt;</code> 元素的<code>text</code> 属性来指定 JavaScript 代码，像下面的例子这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.text = <span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<p>整个过程可以用以下函数来表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        script.text = code;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是调用这个函数的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadScriptString(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>);</div></pre></td></tr></table></figure>
<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 <code>eval()</code> 是一样的。</p>
<h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>能够把 CSS 样式包含到 HTML 页面中的元素有两个。其中，<code>&lt;link&gt;</code> 元素用于包含来自外部的文件，而 <code>&lt;style&gt;</code> 元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。</p>
<p>我们以下面这个典型的 <code>&lt;link&gt;</code> 元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用 DOM 代码可以很容易地动态创建出这个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</div><div class="line">    link.rel = <span class="string">"stylesheet"</span>;</div><div class="line">    link.type = <span class="string">"text/css"</span>;</div><div class="line">    link.href = url;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(link);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码在所有主流浏览器中都可以正常运行。需要注意的是，必须将 <code>&lt;link&gt;</code> 元素添加到 <code>&lt;head&gt;</code> 而不是 <code>&lt;body&gt;</code> 元素，才能保证在所有浏览器中的行为一致。调用函数的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadStyles(<span class="string">"styles.css"</span>);</div></pre></td></tr></table></figure>
<p>加载外部样式文件的过程是异步的，也就是加载样式的过程没有固定的次序。一般来说，知不知道样式已经加载完成并不重要。</p>
<p>另一种定义样式的方式是使用 <code>&lt;style&gt;</code> 元素来包含嵌入式 CSS，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">background-color</span>: red; &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>按照相同的逻辑，下列 DOM 代码应该是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">style.type = <span class="string">"text/css"</span>;</div><div class="line">style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"body&#123;background-color:red&#125;"</span>)); </div><div class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">head.appendChild(style);</div></pre></td></tr></table></figure>
<p>以上代码可以在 Firefox、Safari、Chrome 和 Opera 中运行，在 IE 中则会报错。IE将 <code>&lt;style&gt;</code> 视为一个特殊的、与 <code>&lt;script&gt;</code> 类似的节点，不允许访问其子节点。事实上，IE 此时抛出的错误与向 <code>&lt;script&gt;</code> 元素添加子节点时抛出的错误相同。解决 IE 中这个问题的办法，就是访问元素的 <code>styleSheet</code> 属性，该属性又有一个 <code>cssText</code> 属性，可以接受 CSS 代码），如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">    style.type = <span class="string">"text/css"</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        style.styleSheet.cssText = css;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(style);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用这个函数的示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadStyleString(<span class="string">"body&#123;background-color:red&#125;"</span>);</div></pre></td></tr></table></figure>
<p>这种方式会实时地向页面中添加样式，因此能够马上看到变化。</p>
<h3 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h3><p>理解 <code>NodeList</code> 及其“近亲” <code>NamedNodeMap</code> 和 <code>HTMLCollection</code>，是从整体上透彻理解 DOM 的关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上说，所有 <code>NodeList</code> 对象都是在访问 DOM 文档时实时运行的查询。例如，下列代码会导致无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i,div,divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; divs.length; i++)&#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一行代码会取得文档中所有 <code>&lt;div&gt;</code> 元素的 <code>HTMLCollection</code>。由于这个集合是“动态的”，因此只要有新 <code>&lt;div&gt;</code> 元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。结果，在遇到上例中所示的循环代码时，就会导致一个有趣的问题。每次循环都要对条件 <code>i &lt; divs.length</code> 求值，意味着会运行取得所有 <code>&lt;div&gt;</code> 元素的查询。考虑到循环体每次都会创建一个新 <code>&lt;div&gt;</code> 元素并将其添加到文档中，因此 <code>divs.length</code> 的值在每次循环后都会递增。既然<code>i</code>和 <code>divs.length</code> 每次都会同时递增，结果它们的值永远也不会相等。</p>
<p>如果想要迭代一个 <code>NodeList</code>，最好是使用 <code>length</code> 属性初始化第二个变量，然后将迭代器与该变量进行比较，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i,len,div,divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=divs.length; i &lt; len; i++)&#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中初始化了第二个变量 <code>len</code>。由于 <code>len</code> 中保存着对 <code>divs.length</code> 在循环开始时的一个快照，因此就会避免上一个例子中出现的无限循环问题。在本章演示迭代 <code>NodeList</code> 对象的例子中，使用的都是这种更为保险的方式。</p>
<p>一般来说，应该尽量减少访问 <code>NodeList</code> 的次数。因为每次访问 <code>NodeList</code>，都会运行一次基于文档的查询。所以，可以考虑将从 <code>NodeList</code> 中取得的值缓存起来。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。</p>
<p>DOM 由各种节点构成，简要总结如下。</p>
<ul>
<li>最基本的节点类型是 <code>Node</code>，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自 <code>Node</code>。</li>
<li><code>Document</code> 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中，<code>document</code> 对象是 <code>Document</code> 的一个实例。使用 <code>document</code> 对象，有很多种方式可以查询和取得节点。</li>
<li><code>Element</code> 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。</li>
<li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。</li>
</ul>
<p>访问 DOM 的操作在多数情况下都很直观，不过在处理 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用 <code>innerHTML</code> 时，以及在创建新元素时的一些问题。</p>
<p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的部分，而因访问 <code>NodeList</code> 导致的问题为最多。<code>NodeList</code> 对象都是“动态的”，这就意味着每次访问 <code>NodeList</code> 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>仔细想想，下面代码块会输出什么结果呢？前3个挑战相比前一章节，代码仅仅是多了换行，结果会有什么不一样呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战一 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.firstChild.innerHTML);  <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.lastChild.innerHTML);   <span class="comment">// ???   </span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战二 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.childNodes[<span class="number">1</span>].innerHTML); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.parentNode.getAttribute(<span class="string">"name"</span>)); <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战三 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).childNodes[<span class="number">1</span>];  </div><div class="line">    <span class="built_in">document</span>.writeln(d.nextSibling.innerHTML);      <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.previousSibling.innerHTML);  <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战四 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"t"</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">style</span>=<span class="string">"background: red;"</span> <span class="attr">wife</span>=<span class="string">"sophie"</span> <span class="attr">onclick</span>=<span class="string">"alert('123');"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> t = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);    </div><div class="line">    <span class="built_in">console</span>.log(t.class);                   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"class"</span>));   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.className);               <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"className"</span>)); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.style);                   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"style"</span>));   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.style.background);        <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"style.background"</span>)); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.wife);                    <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"wife"</span>));    <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.onclick);                 <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"onclick"</span>)); <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Element-类型&quot;&gt;&lt;a href=&quot;#Element-类型&quot; class=&quot;headerlink&quot; title=&quot;Element 类型&quot;&gt;&lt;/a&gt;Element 类型&lt;/h3&gt;&lt;p&gt;除了 &lt;code&gt;Document&lt;/code&gt; 类型之外，&lt;code&gt;Element&lt;/code&gt; 类型就要算是 Web 编程中最常用的类型了。&lt;code&gt;Element&lt;/code&gt; 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。&lt;code&gt;Element&lt;/code&gt; 节点具有以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nodeType&lt;/code&gt; 的值为1；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodeName&lt;/code&gt; 的值为元素的标签名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodeValue&lt;/code&gt; 的值为 &lt;code&gt;null&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parentNode&lt;/code&gt; 可能是 &lt;code&gt;Document&lt;/code&gt; 或 &lt;code&gt;Element&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;其子节点可能是 &lt;code&gt;Element&lt;/code&gt;、&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;Comment&lt;/code&gt;、&lt;code&gt;ProcessingInstruction&lt;/code&gt;、&lt;code&gt;CDATASection&lt;/code&gt; 或 &lt;code&gt;EntityReference&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要访问元素的标签名，可以使用 &lt;code&gt;nodeName&lt;/code&gt; 属性，也可以使用 &lt;code&gt;tagName&lt;/code&gt; 属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。以下面的元素为例：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myDiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之 DOM（上）</title>
    <link href="http://shisb.com/2016/11/15/javascript-lesson-2.2-DOM-1/"/>
    <id>http://shisb.com/2016/11/15/javascript-lesson-2.2-DOM-1/</id>
    <published>2016-11-15T15:30:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>
<h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的 HTML 为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以将这个简单的 HTML 文档表示为一个层次结构，如图下图所示。</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.2/1.jpg" alt=""></p>
<p>在这个例子中，文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。</p>
<p>每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。</p>
<a id="more"></a> 
<h3 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h3><p>DOM1 级定义了一个 <code>Node</code> 接口，该接口将由 DOM 中的所有节点类型实现。这个 <code>Node</code> 接口在 JavaScript 中是作为 <code>Node</code> 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 <code>Node</code> 类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<p>每个节点都有一个 <code>nodeType</code> 属性，用于表明节点的类型。节点类型由在 <code>Node</code> 类型中定义的下列12个数值常量来表示，任何节点类型必居其一：</p>
<ul>
<li><code>Node.ELEMENT_NODE</code>(1)；</li>
<li><code>Node.ATTRIBUTE_NODE</code>(2)；</li>
<li><code>Node.TEXT_NODE</code>(3)；</li>
<li><code>Node.CDATA_SECTION_NODE</code>(4)；</li>
<li><code>Node.ENTITY_REFERENCE_NODE</code>(5)；</li>
<li><code>Node.ENTITY_NODE</code>(6)；</li>
<li><code>Node.PROCESSING_INSTRUCTION_NODE</code>(7)；</li>
<li><code>Node.COMMENT_NODE</code>(8)；</li>
<li><code>Node.DOCUMENT_NODE</code>(9)；</li>
<li><code>Node.DOCUMENT_TYPE_NODE</code>(10)；</li>
<li><code>Node.DOCUMENT_FRAGMENT_NODE</code>(11)；</li>
<li><code>Node.NOTATION_NODE</code>(12)。</li>
</ul>
<p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123;   <span class="comment">// 在IE中无效</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Node is an element."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子比较了 <code>someNode.nodeType</code> 与 <code>Node.ELEMENT_NODE</code> 常量。如果二者相等，则意味着 <code>someNode</code> 确实是一个元素。然而，由于 IE 没有公开 <code>Node</code> 类型的构造函数，因此上面的代码在 IE 中会导致错误。为了确保跨浏览器兼容，最好还是将 <code>nodeType</code> 属性与数字值进行比较，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;    <span class="comment">// 适用于所有浏览器</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Node is an element."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并不是所有节点类型都受到 Web 浏览器的支持。开发人员最常用的就是元素和文本节点。</p>
<h4 id="Node-属性概述"><a href="#Node-属性概述" class="headerlink" title="Node 属性概述"></a>Node 属性概述</h4><p>Node 常用属性主要有以下10个，接下来我们会着重讲解部分属性。</p>
<ul>
<li><code>nodeType</code>：显示节点的类型</li>
<li><code>nodeName</code>：显示节点的名称</li>
<li><code>nodeValue</code>：显示节点的值</li>
<li><code>attributes</code>：获取一个属性节点</li>
<li><code>firstChild</code>：表示某一节点的第一个节点</li>
<li><code>lastChild</code>：表示某一节点的最后一个子节点</li>
<li><code>childNodes</code>：表示所在节点的所有子节点</li>
<li><code>parentNode</code>：表示所在节点的父节点</li>
<li><code>nextSibling</code>：紧挨着当前节点的下一个节点</li>
<li><code>previousSibling</code>：紧挨着当前节点的上一个节点 </li>
</ul>
<h4 id="nodeName-和-nodeValue-属性"><a href="#nodeName-和-nodeValue-属性" class="headerlink" title="nodeName 和 nodeValue 属性"></a><code>nodeName</code> 和 <code>nodeValue</code> 属性</h4><p>要了解节点的具体信息，可以使用  <code>nodeName</code> 和 <code>nodeValue</code> 这两个属性。这两个属性的值完全取决于节点的类型。在使用这两个值以前，最好是像下面这样先检测一下节点的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;</div><div class="line">    value = someNode.nodeName;    <span class="comment">// nodeName的值是元素的标签名</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，首先检查节点类型，看它是不是一个元素。如果是，则取得并保存 <code>nodeName</code> 的值。对于元素节点，<code>nodeName</code> 中保存的始终都是元素的标签名，而 <code>nodeValue</code> 的值则始终为 <code>null</code>。</p>
<h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>文档中所有的节点之间都存在这样或那样的关系。节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。</p>
<p>每个节点都有一个 <code>childNodes</code> 属性，其中保存着一个 <code>NodeList</code> 对象。<code>NodeList</code> 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问 <code>NodeList</code> 的值，而且这个对象也有 <code>length</code> 属性，但它并不是 <code>Array</code> 的实例。<code>NodeList</code> 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 <code>NodeList</code> 对象中。</p>
<p>下面的例子展示了如何访问保存在 <code>NodeList</code> 中的节点——可以通过方括号，也可以使用 <code>item()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> count = someNode.childNodes.length;</div></pre></td></tr></table></figure>
<p>无论使用方括号还是使用 <code>item()</code> 方法都没有问题，但使用方括号语法看起来与访问数组相似，因此颇受一些开发人员的青睐。另外，要注意 <code>length</code> 属性表示的是访问 <code>NodeList</code> 的那一刻，其中包含的节点数量。</p>
<p>每个节点都有一个 <code>parentNode</code> 属性，该属性指向文档树中的父节点。包含在 <code>childNodes</code> 列表中的所有节点都具有相同的父节点，因此它们的 <code>parentNode</code> 属性都指向同一个节点。此外，包含在 <code>childNodes</code> 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 <code>previousSibling</code> 和 <code>nextSibling</code> 属性，可以访问同一列表中的其他节点。列表中第一个节点的 <code>previousSibling</code> 属性值为 <code>null</code>，而列表中最后一个节点的 <code>nextSibling</code> 属性的值同样也为 <code>null</code>，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nextSibling === <span class="literal">null</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Last node in the parent’s childNodes list."</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (someNode.previousSibling === <span class="literal">null</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"First node in the parent’s childNodes list."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果列表中只有一个节点，那么该节点的 <code>nextSibling</code> 和 <code>previousSibling</code> 都为 <code>null</code>。</p>
<p>父节点与其第一个和最后一个子节点之间也存在特殊关系。父节点的 <code>firstChild</code> 和 <code>lastChild</code> 属性分别指向其 <code>childNodes</code> 列表中的第一个和最后一个节点。其中，<code>someNode.firstChild</code> 的值始终等于 <code>someNode.childNodes[0]</code>，而 <code>someNode.lastChild</code> 的值始终等于 <code>someNode.childNodes [someNode.childNodes.length-1]</code>。在只有一个子节点的情况下， <code>firstChild</code> 和 <code>lastChild</code> 指向同一个节点。如果没有子节点，那么 <code>firstChild</code> 和 <code>lastChild</code> 的值均为 <code>null</code>。明确这些关系能够对我们查找和访问文档结构中的节点提供极大的便利。下图形象地展示了上述关系。</p>
<p><img src="http://qn.shisb.com/blog/javascript-lesson/2.2/2.jpg" alt=""></p>
<p>在反映这些关系的所有属性当中，<code>childNodes</code> 属性与其他属性相比更方便一些，因为只须使用简单的关系指针，就可以通过它访问文档树中的任何节点。另外，<code>hasChildNodes()</code> 也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回 <code>true</code>；应该说，这是比查询 <code>childNodes</code> 列表的 <code>length</code> 属性更简单的方法。</p>
<p>所有节点都有的最后一个属性是 <code>ownerDocument</code>，该属性指向表示整个文档的文档节点。这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。</p>
<h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>因为关系指针都是只读的，所以 DOM 提供了一些操作节点的方法。其中，最常用的方法是 <code>appendChild()</code>，用于向 <code>childNodes</code> 列表的末尾添加一个节点。添加节点后，<code>childNodes</code> 的新增节点、父节点及以前的最后一个子节点的关系指针都会相应地得到更新。更新完成后，<code>appendChild()</code> 返回新增的节点。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(newNode);</div><div class="line"><span class="built_in">console</span>.log(returnedNode == newNode);         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(someNode.lastChild == newNode);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如果传入到 <code>appendChild()</code> 中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出现在文档中的多个位置上。因此，如果在调用 <code>appendChild()</code> 时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// someNode 有多个子节点</span></div><div class="line"><span class="keyword">var</span> returnedNode = someNode.appendChild(someNode.firstChild);</div><div class="line"><span class="built_in">console</span>.log(returnedNode == someNode.firstChild);   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(returnedNode == someNode.lastChild);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>如果需要把节点放在 <code>childNodes</code> 列表中某个特定的位置上，而不是放在末尾，那么可以使用 <code>insertBefore()</code> 方法。这个方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点 <code>previousSibling</code>，同时被方法返回。如果参照节点是 <code>null</code>，则 <code>insertBefore()</code> 与 <code>appendChild()</code> 执行相同的操作，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插入后成为最后一个子节点</span></div><div class="line">returnedNode = someNode.insertBefore(newNode, <span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(newNode == someNode.lastChild);   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 插入后成为第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnedNode = someNode.insertBefore(newNode, someNode.firstChild);</div><div class="line"><span class="built_in">console</span>.log(returnedNode == newNode);         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(newNode == someNode.firstChild);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 插入到最后一个子节点前面</span></div><div class="line">returnedNode = someNode.insertBefore(newNode, someNode.lastChild);</div><div class="line"><span class="built_in">console</span>.log(newNode == someNode.childNodes[someNode.childNodes.length<span class="number">-2</span>]); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>前面介绍的 <code>appendChild()</code> 和 <code>insertBefore()</code> 方法都只插入节点，不会移除节点。而下面要介绍的 <code>replaceChild()</code> 方法接受的两个参数是：要插入的节点和要替换的节点。要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 替换第一个子节点</span></div><div class="line"><span class="keyword">var</span> returnedNode = someNode.replaceChild(newNode, someNode.firstChild);</div><div class="line"></div><div class="line"><span class="comment">// 替换最后一个子节点</span></div><div class="line">returnedNode = someNode.replaceChild(newNode, someNode.lastChild);</div></pre></td></tr></table></figure>
<p>在使用 <code>replaceChild()</code> 插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置。</p>
<p>如果只想移除而非替换节点，可以使用 <code>removeChild()</code> 方法。这个方法接受一个参数，即要移除的节点。被移除的节点将成为方法的返回值，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除第一个子节点</span></div><div class="line"><span class="keyword">var</span> formerFirstChild = someNode.removeChild(someNode.firstChild);</div><div class="line"></div><div class="line"><span class="comment">// 移除最后一个子节点</span></div><div class="line"><span class="keyword">var</span> formerLastChild = someNode.removeChild(someNode.lastChild);</div></pre></td></tr></table></figure>
<p>与使用 <code>replaceChild()</code> 方法一样，通过 <code>removeChild()</code> 移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。</p>
<p>前面介绍的四个方法操作的都是某个节点的子节点，也就是说，要使用这几个方法必须先取得父节点（使用 <code>parentNode</code> 属性）。另外，并不是所有类型的节点都有子节点，如果在不支持子节点的节点上调用了这些方法，将会导致错误发生。</p>
<h3 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h3><p>JavaScript 通过 Document 类型表示文档。在浏览器中，<code>document</code> 对象是 <code>HTMLDocument</code>（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，<code>document</code> 对象是 <code>window</code> 对象的一个属性，因此可以将其作为全局对象来访问。<code>Document</code> 节点具有下列特征：</p>
<ul>
<li><code>nodeType</code> 的值为9；</li>
<li><code>nodeName</code> 的值为 <code>&quot;#document&quot;</code>；</li>
<li><code>nodeValue</code> 的值为 <code>null</code>；</li>
<li><code>parentNode</code> 的值为 <code>null</code>；</li>
<li><code>ownerDocument</code> 的值为 <code>null</code>；</li>
<li>其子节点可能是一个 <code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code> 或 <code>Comment</code>。</li>
</ul>
<p><code>Document</code> 类型可以表示 HTML 页面或者其他基于 XML 的文档。不过，最常见的应用还是作为 <code>HTMLDocument</code> 实例的 <code>document</code> 对象。通过这个文档对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。</p>
<h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>虽然 DOM 标准规定 <code>Document</code> 节点的子节点可以是<code>DocumentType</code>、<code>Element</code>、<code>ProcessingInstruction</code> 或 <code>Comment</code>，但还有两个内置的访问其子节点的快捷方式。第一个就是<code>documentElement</code> 属性，该属性始终指向 HTML 页面中的 <code>html</code> 元素。另一个就是通过 <code>childNodes</code> 列表访问文档元素，但通过 <code>documentElement</code> 属性则能更快捷、更直接地访问该元素。以下面这个简单的页面为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个页面在经过浏览器解析后，其文档中只包含一个子节点，即 <code>html</code> 元素。可以通过 <code>documentElement</code> 或 <code>childNodes</code> 列表来访问这个元素，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;      <span class="comment">// 取得对&lt;html&gt;的引用</span></div><div class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>]);   <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(html === <span class="built_in">document</span>.firstChild);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这个例子说明，<code>documentElement</code>、<code>firstChild</code> 和 <code>childNodes[0]</code> 的值相同，都指向 <code>&lt;html&gt;</code> 元素。</p>
<p>作为 <code>HTMLDocument</code> 的实例，<code>document</code> 对象还有一个 <code>body</code> 属性，直接指向 <code>&lt;body&gt;</code> 元素。因为开发人员经常要使用这个元素，所以 <code>document.body</code> 在 JavaScript 代码中出现的频率非常高，其用法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;    <span class="comment">// 取得对&lt;body&gt;的引用</span></div></pre></td></tr></table></figure>
<p>所有浏览器都支持 <code>document.documentElement</code> 和 <code>document.body</code> 属性。</p>
<p><code>Document</code> 另一个可能的子节点是 <code>DocumentType</code>。通常将 <code>&lt;!DOCTYPE&gt;</code> 标签看成一个与文档其他部分不同的实体，可以通过 <code>doctype</code> 属性（在浏览器中是 <code>document.doctype</code> ）来访问它的信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype;     <span class="comment">// 取得对&lt;!DOCTYPE&gt;的引用</span></div></pre></td></tr></table></figure>
<p>浏览器对 <code>document.doctype</code> 的支持差别很大，可以给出如下总结。</p>
<ul>
<li>IE8 及之前版本：如果存在文档类型声明，会将其错误地解释为一个注释并把它当作 <code>Comment</code> 节点；而 <code>document.doctype</code> 的值始终为 <code>null</code>。</li>
<li>IE9+ 及 Firefox：如果存在文档类型声明，则将其作为文档的第一个子节点；<code>document.doctype</code> 是一个 <code>DocumentType</code> 节点，也可以通过 <code>document.firstChild</code> 或 <code>document.childNodes[0]</code> 访问同一个节点。</li>
<li>Safari、Chrome 和 Opera：如果存在文档类型声明，则将其解析，但不作为文档的子节点。<code>document.doctype</code> 是一个 <code>DocumentType</code> 节点，但该节点不会出现在 <code>document.childNodes</code> 中。</li>
</ul>
<p>由于浏览器对 <code>document.doctype</code> 的支持不一致，因此这个属性的用处很有限。</p>
<h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为 <code>HTMLDocument</code> 的一个实例，<code>document</code> 对象还有一些标准的 <code>Document</code> 对象所没有的属性。这些属性提供了 <code>document</code> 对象所表现的网页的一些信息。其中第一个属性就是 <code>title</code>，包含着 <code>&lt;title&gt;</code> 元素中的文本——显示在浏览器窗口的标题栏或标签页上。通过这个属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取得文档标题</span></div><div class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title;</div><div class="line"></div><div class="line"><span class="comment">// 设置文档标题</span></div><div class="line"><span class="built_in">document</span>.title = <span class="string">"New page title"</span>;</div></pre></td></tr></table></figure>
<p>接下来要介绍的3个属性都与对网页的请求有关，它们是 <code>URL</code>、<code>domain</code> 和 <code>referrer</code>。<code>URL</code> 属性中包含页面完整的 URL（即地址栏中显示的URL），<code>domain</code> 属性中只包含页面的域名，而 <code>referrer</code> 属性中则保存着链接到当前页面的那个页面的 URL。在没有来源页面的情况下，<code>referrer</code> 属性中可能会包含空字符串。所有这些信息都存在于请求的 HTTP 头部，只不过是通过这些属性让我们能够在 JavaScrip 中访问它们而已，如下面的例子所示。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 取得完整的URL</span></div><div class="line"><span class="built_in">var</span> <span class="built_in">url</span> = <span class="built_in">document</span>.URL;</div><div class="line"></div><div class="line"><span class="comment">// 取得域名</span></div><div class="line"><span class="built_in">var</span> domain = <span class="built_in">document</span>.domain;</div><div class="line"></div><div class="line"><span class="comment">// 取得来源页面的URL</span></div><div class="line"><span class="built_in">var</span> referrer = <span class="built_in">document</span>.referrer;</div></pre></td></tr></table></figure>
<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><p>说到最常见的 DOM 应用，恐怕就要数取得特定的某个或某组元素的引用，然后再执行一些操作了。取得元素的操作可以使用 <code>document</code> 对象的几个方法来完成。其中，<code>Document</code> 类型为此提供了两个方法：<code>getElementById()</code> 和 <code>getElementsByTagName()</code>。</p>
<p>第一个方法，<code>getElementById()</code>，接收一个参数：要取得的元素的 ID。如果找到相应的元素则返回该元素，如果不存在带有相应 ID 的元素，则返回 <code>null</code>。注意，这里的 ID 必须与页面中元素的 <code>id</code> 特性（attribute）严格匹配，包括大小写。以下面的元素为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Some text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以使用下面的代码取得这个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);   <span class="comment">// 取得&lt;div&gt;元素的引用</span></div></pre></td></tr></table></figure>
<p>但是，下面的代码在除 IE7 及更早版本之外的所有浏览器中都将返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"mydiv"</span>);   <span class="comment">// 无效的ID（在IE7及更早版本中可以）</span></div></pre></td></tr></table></figure>
<p>IE8 及较低版本不区分 ID 的大小写，因此 <code>&quot;myDiv&quot;</code> 和 <code>&quot;mydiv&quot;</code> 会被当作相同的元素 ID。如果页面中多个元素的ID值相同，<code>getElementById()</code> 只返回文档中第一次出现的元素。</p>
<p>另一个常用于取得元素引用的方法是 <code>getElementsByTagName()</code>。这个方法接受一个参数，即要取得元素的标签名，而返回的是包含零或多个元素的 <code>NodeList</code>。在HTML文档中，这个方法会返回一个<code>HTMLCollection</code> 对象，作为一个“动态”集合，该对象与 <code>NodeList</code>非常类似。例如，下列代码会取得页面中所有的 <code>&lt;img&gt;</code> 元素，并返回一个 <code>HTMLCollection</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</div></pre></td></tr></table></figure>
<p>这行代码会将一个 <code>HTMLCollection</code> 对象保存在 <code>images</code> 变量中。与 <code>NodeList</code> 对象类似，可以使用方括号语法或 <code>item()</code> 方法来访问 <code>HTMLCollection</code> 对象中的项。而这个对象中元素的数量则可以通过其 <code>length</code> 属性取得，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(images.length);        <span class="comment">// 输出图像的数量</span></div><div class="line"><span class="built_in">console</span>.log(images[<span class="number">0</span>].src);        <span class="comment">// 输出第一个图像元素的src特性</span></div><div class="line"><span class="built_in">console</span>.log(images.item(<span class="number">0</span>).src);   <span class="comment">// 输出第一个图像元素的src特性</span></div></pre></td></tr></table></figure>
<p><code>HTMLCollection</code> 对象还有一个方法，叫做 <code>namedItem()</code>，使用这个方法可以通过元素的 <code>name</code> 特性取得集合中的项。例如，假设上面提到的页面中包含如下 <code>&lt;img&gt;</code> 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"myimage.gif"</span> <span class="attr">name</span>=<span class="string">"myImage"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么就可以通过如下方式从 <code>images</code> 变量中取得这个 <code>&lt;img&gt;</code> 元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);</div></pre></td></tr></table></figure>
<p>在提供按索引访问项的基础上，<code>HTMLCollection</code> 还支持按名称访问项，这就为我们取得实际想要的元素提供了便利。而且，对命名的项也可以使用方括号语法来访问，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>];</div></pre></td></tr></table></figure>
<p>对 <code>HTMLCollection</code> 而言，我们可以向方括号中传入数值或字符串形式的索引值。在后台，对数值索引就会调用 <code>item()</code>，而对字符串索引就会调用 <code>namedItem()</code>。</p>
<p>要想取得文档中的所有元素，可以向 <code>getElementsByTagName()</code> 中传入 <code>&quot;*&quot;</code>。在 JavaScript 及 CSS 中，星号（<code>*</code>）通常表示“全部”。下面看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</div></pre></td></tr></table></figure>
<p>仅此一行代码返回的 <code>HTMLCollection</code> 中，就包含了整个页面中的所有元素——按照它们出现的先后顺序。换句话说，第一项是 <code>&lt;html&gt;</code> 元素，第二项是 <code>&lt;head&gt;</code> 元素，以此类推。由于 IE 将注释（<code>Comment</code>）实现为元素（<code>Element</code>），因此在IE中调用 <code>getElementsByTagName(&quot;*&quot;)</code> 将会返回所有注释节点。</p>
<p>第三个方法，也是只有 <code>HTMLDocument</code> 类型才有的方法，是 <code>getElementsByName()</code>。顾名思义，这个方法会返回带有给定 <code>name</code> 特性的所有元素。最常使用 <code>getElementsByName()</code> 方法的情况是取得单选按钮；为了确保发送给浏览器的值正确无误，所有单选按钮必须具有相同的 <code>name</code> 特性，如下面的例子所示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Which color do you prefer?<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"red"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorRed"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorRed"</span>&gt;</span>Red<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"green"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorGreen"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorGreen"</span>&gt;</span>Green<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"blue"</span> <span class="attr">name</span>=<span class="string">"color"</span> <span class="attr">id</span>=<span class="string">"colorBlue"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"colorBlue"</span>&gt;</span>Blue<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如这个例子所示，其中所有单选按钮的 <code>name</code> 特性值都是 <code>&quot;color&quot;</code>，但它们的 ID 可以不同。ID 的作用在于将 <code>&lt;label&gt;</code> 元素应用到每个单选按钮，而 <code>name</code> 特性则用以确保三个值中只有一个被发送给浏览器。这样，我们就可以使用如下代码取得所有单选按钮：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> radios = <span class="built_in">document</span>.getElementsByName(<span class="string">"color"</span>);</div></pre></td></tr></table></figure>
<p>与 <code>getElementsByTagName()</code> 类似，<code>getElementsByName()</code> 方法也会返回一个 <code>HTMLCollectioin</code>。但是，对于这里的单选按钮来说，<code>namedItem()</code> 方法则只会取得第一项（因为每一项的 <code>name</code> 特性都相同）。</p>
<h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><p>除了属性和方法，<code>document</code> 对象还有一些特殊的集合。这些集合都是 <code>HTMLCollection</code> 对象，为访问文档常用的部分提供了快捷方式，包括：</p>
<ul>
<li><code>document.anchors</code>，包含文档中所有带 <code>name</code> 特性的 <code>&lt;a&gt;</code> 元素；</li>
<li><code>document.applets</code>，包含文档中所有的 <code>&lt;applet&gt;</code> 元素，因为不再推荐使用 <code>&lt;applet&gt;</code> 元素，所以这个集合已经不建议使用了；</li>
<li><code>document.forms</code>，包含文档中所有的 <code>&lt;form&gt;</code> 元素，与<code>document.getElementsByTagName(&quot;form&quot;)</code>得到的结果相同；</li>
<li><code>document.images</code>，包含文档中所有的 <code>&lt;img&gt;</code> 元素，与<code>document.getElementsByTagName(&quot;img&quot;)</code>得到的结果相同；</li>
<li><code>document.links</code>，包含文档中所有带<code>href</code>特性的 <code>&lt;a&gt;</code> 元素。</li>
</ul>
<p>这个特殊集合始终都可以通过 <code>HTMLDocument</code> 对象访问到，而且，与 <code>HTMLCollection</code> 对象类似，集合中的项也会随着当前文档内容的更新而更新。</p>
<h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><p>有一个 <code>document</code> 对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列4个方法中：<code>write()</code>、<code>writeln()</code>、<code>open()</code> 和 <code>close()</code>。其中，<code>write()</code> 和 <code>writeln()</code> 方法都接受一个字符串参数，即要写入到输出流中的文本。<code>write()</code> 会原样写入，而 <code>writeln()</code> 则会在字符串的末尾添加一个换行符 <code>\n</code>。在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容，如下面的例子所示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>The current date and time is:</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">document</span>.write(<span class="string">"&lt;strong&gt;"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).toString() + <span class="string">"&lt;/strong&gt;"</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个例子展示了在页面加载过程中输出当前日期和时间的代码。其中，日期被包含在一个 <code>&lt;strong&gt;</code> 元素中，就像在 HTML 页面中包含普通的文本一样。这样做会创建一个 DOM 元素，而且可以在将来访问该元素。通过 <code>write()</code> 和 <code>writeln()</code> 输出的任何 HTML 代码都将如此处理。</p>
<p>此外，还可以使用 <code>write()</code> 和 <code>writeln()</code> 方法动态地包含外部资源，例如 JavaScript 文件等。在包含 JavaScript 文件时，必须注意不能像下面的例子那样直接包含字符串 <code>&quot;&lt;/script&gt;&quot;</code>，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example 2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></div><div class="line">        document.write("<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>"<span class="attr">text</span>/<span class="attr">javascript</span>\" <span class="attr">src</span>=<span class="string">\</span>"<span class="attr">file.js</span>\"&gt;</span><span class="undefined">" +   </span></div><div class="line">            "<span class="tag">&lt;/<span class="name">script</span>&gt;</span>");</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>即使这个文件看起来没错，但字符串 <code>&quot;&lt;/script&gt;&quot;</code> 将被解释为与外部的 <code>&lt;script&gt;</code> 标签匹配，结果文本 <code>&quot;)</code>；将会出现在页面中。为避免这个问题，只需把这个字符串分开写即可；第2章也曾经提及这个问题，解决方案如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example 3<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></div><div class="line">        document.write("<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">\</span>"<span class="attr">text</span>/<span class="attr">javascript</span>\" <span class="attr">src</span>=<span class="string">\</span>"<span class="attr">file.js</span>\"&gt;</span><span class="handlebars"><span class="xml">" +   </span></span></div><div class="line">            "<span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>");</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>字符串 <code>&quot;&lt;\/script&gt;&quot;</code> 不会被当作外部 <code>&lt;script&gt;</code> 标签的关闭标签，因而页面中也就不会出现多余的内容了。</p>
<p>前面的例子使用 <code>document.write()</code> 在页面被呈现的过程中直接向其中输出了内容。如果在文档加载结束后再调用 <code>document.write()</code>，那么输出的内容将会重写整个页面，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example 4<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is some content that you won't get to see because it will be overwritten.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">document</span>.write(<span class="string">"Hello world!"</span>);</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了 <code>window.onload</code> 事件处理程序，等到页面完全加载之后延迟执行函数。函数执行之后，字符串 <code>&quot;Hello world!&quot;</code> 会重写整个页面内容。</p>
<p>方法 <code>open()</code> 和 <code>close()</code> 分别用于打开和关闭网页的输出流。如果是在页面加载期间使用 <code>write()</code> 或 <code>writeln()</code> 方法，则不需要用到这两个方法。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>仔细想想，下面代码块会输出什么结果呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战一 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.firstChild.innerHTML);  <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.lastChild.innerHTML);   <span class="comment">// ???   </span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战二 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.childNodes[<span class="number">1</span>].innerHTML); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.parentNode.getAttribute(<span class="string">"name"</span>)); <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战三 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).childNodes[<span class="number">1</span>];  </div><div class="line">    <span class="built_in">document</span>.writeln(d.nextSibling.innerHTML);      <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.previousSibling.innerHTML);  <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API。DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。&lt;/p&gt;
&lt;h2 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;&gt;&lt;/a&gt;节点层次&lt;/h2&gt;&lt;p&gt;DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的 HTML 为例：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Sample Page&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello World!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以将这个简单的 HTML 文档表示为一个层次结构，如图下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn.shisb.com/blog/javascript-lesson/2.2/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。&lt;/p&gt;
&lt;p&gt;每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之 BOM</title>
    <link href="http://shisb.com/2016/11/07/javascript-lesson-2.1-BOM/"/>
    <id>http://shisb.com/2016/11/07/javascript-lesson-2.1-BOM/</id>
    <published>2016-11-07T14:30:00.000Z</published>
    <updated>2016-11-07T14:23:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。多年来，缺少事实上的规范导致 BOM 有很多问题，因为浏览器提供商会按照各自的想法随意去扩展它。W3C 为了把浏览器中 JavaScript 最基本的部分标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。</p>
<h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a><code>window</code> 对象</h2><p>BOM 的核心对象是 <code>window</code>，它表示浏览器的一个实例。在浏览器中，<code>window</code> 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 <code>Global</code> 对象。这意味着在网页中定义的任何一个对象、变量和函数，都以 <code>window</code> 作为其 <code>Global</code> 对象，因此有权访问 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code> 等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于 <code>window</code> 对象同时扮演着 ECMAScript 中 <code>Global</code> 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 <code>window</code> 对象的属性和方法。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);    <span class="comment">// 29</span></div><div class="line">sayAge();                   <span class="comment">// 29</span></div><div class="line"><span class="built_in">window</span>.sayAge();            <span class="comment">// 29</span></div></pre></td></tr></table></figure>
<a id="more"></a> 
<p>抛开全局变量会成为 <code>window</code> 对象的属性不谈，定义全局变量与在 <code>window</code> 对象上直接定义属性还是有一点差别：全局变量不能通过 <code>delete</code> 运算符删除，而直接在 <code>window</code> 对象上的定义的属性可以。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 false </span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.age;</div><div class="line"></div><div class="line"><span class="comment">// 在 IE &lt; 9 时抛出错误，在其他所有浏览器中都返回 true</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.color;        <span class="comment">// return true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.age);    <span class="comment">// 29</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.color);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>使用 <code>var</code> 语句添加的 <code>window</code> 属性有一个名为 <code>Configurable</code> 的特性，这个特性的值被默认设置为 <code>false</code>，因此这样定义的属性不可以通过 <code>delete</code> 运算符删除。IE8 及更早版本在遇到使用 <code>delete</code> 删除 <code>window</code> 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</p>
<p>另外，还要记住一件事：尝试访问未声明的变量会抛出错误，但是通过查询 <code>window</code> 对象，可以知道某个可能未声明的变量是否存在。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里会抛出错误，因为 oldValue 未定义</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue;</div><div class="line"></div><div class="line"><span class="comment">// 这里不会抛出错误，因为这是一次属性查询</span></div><div class="line"><span class="comment">// newValue 的值是 undefined</span></div><div class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;</div></pre></td></tr></table></figure>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的 <code>window</code> 对象，并且保存在 <code>frames</code> 集合中。在 <code>frames</code> 集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的 <code>window</code> 对象。每个 <code>window</code> 对象都有一个 <code>name</code> 属性，其中包含框架的名称。下面是一个包含框架的页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对这个例子而言，可以通过 <code>window.frames[0]</code> 或者 <code>window.frames[&quot;topFrame&quot;]</code> 来引用上方的框架。不过最好使用 <code>top</code> 而非 <code>window</code> 来引用这些框架（例如 <code>top.frames[0]</code>），因为 <code>top</code> 对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于在一个框架中编写的任何代码来说，其中的 <code>window</code> 对象指向的都是那个框架的特定实例，而非最高层的框架。</p>
<p>与 <code>top</code> 相对的另一个 <code>window</code> 对象是 <code>parent</code>。顾名思义，<code>parent</code>（父）对象始终指向当前框架的直接上层框架。在某些情况下，<code>parent</code> 有可能等于 <code>top</code>；但在没有框架的情况下，<code>parent</code> 一定等于 <code>top</code>（此时它们都等于 <code>window</code>）。</p>
<p>与框架有关的最后一个对象是 <code>self</code>，它始终指向 <code>window</code>；实际上，<code>self</code> 和 <code>window</code> 对象可以互换使用。引入 <code>self</code> 对象的目的只是为了与 <code>top</code> 和 <code>parent</code> 对象对应起来，因此它不格外包含其他值。</p>
<p>所有这些对象都是 <code>window</code> 对象的属性，可以通过 <code>window.parent</code>、<code>window.top</code> 等形式来访问。同时，这也意味着可以将不同层次的 <code>window</code> 对象连缀起来，例如 <code>window.parent.parent.frames[0]</code>。</p>
<p>在使用框架的情况下，浏览器中会存在多个 <code>Global</code> 对象。在每个框架中定义的全局变量会自动成为框架中 <code>window</code> 对象的属性。由于每个 <code>window</code> 对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，<code>top.Object</code> 并不等于 <code>top.frames[0].Object</code>。这个问题会影响到对跨框架传递的对象使用 <code>instanceof</code> 运算符。</p>
<h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>使用 <code>window.open()</code> 方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。</p>
<p>如果为 <code>window.open()</code> 传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的 URL。看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 等同于 &lt;a href="http://shijiajie.com" target="newWindow"&gt;&lt;/a&gt;</span></div><div class="line"><span class="built_in">window</span>.open(<span class="string">"http://shijiajie.com/"</span>, <span class="string">"newWindow"</span>);</div></pre></td></tr></table></figure>
<h4 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h4><p>如果给 <code>window.open()</code> 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页）。在不打开新窗口的情况下，会忽略第三个参数。</p>
<p>第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出了可以出现在这个字符串中的设置选项。</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fullscreen</td>
<td>yes或no</td>
<td>表示浏览器窗口是否最大化。仅限IE</td>
</tr>
<tr>
<td>height</td>
<td>数值</td>
<td>表示新窗口的高度。不能小于100</td>
</tr>
<tr>
<td>left</td>
<td>数值</td>
<td>表示新窗口的左坐标。不能是负值</td>
</tr>
<tr>
<td>location</td>
<td>yes或no</td>
<td>表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器）</td>
</tr>
<tr>
<td>menubar</td>
<td>yes或no</td>
<td>表示是否在浏览器窗口中显示菜单栏。默认值为no</td>
</tr>
<tr>
<td>resizable</td>
<td>yes或no</td>
<td>表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no</td>
</tr>
<tr>
<td>scrollbars</td>
<td>yes或no</td>
<td>表示如果内容在视口中显示不下，是否允许滚动。默认值为no</td>
</tr>
<tr>
<td>status</td>
<td>yes或no</td>
<td>表示是否在浏览器窗口中显示状态栏。默认值为no</td>
</tr>
<tr>
<td>toolbar</td>
<td>yes或no</td>
<td>表示是否在浏览器窗口中显示工具栏。默认值为no</td>
</tr>
<tr>
<td>top</td>
<td>数值</td>
<td>表示新窗口的上坐标。不能是负值</td>
</tr>
<tr>
<td>width</td>
<td>数值</td>
<td>表示新窗口的宽度。不能小于100</td>
</tr>
</tbody>
</table>
<p>这行代码会打开一个新的可以调整大小的窗口，窗口初始大小为400×400像素，并且距屏幕上沿和左边各10像素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.open(<span class="string">"http://shijiajie.com/"</span>,<span class="string">"newWindow"</span>,</div><div class="line">    <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div></pre></td></tr></table></figure>
<p><code>window.open()</code> 方法会返回一个指向新窗口的引用。引用的对象与其他 <code>window</code> 对象大致相似，但我们可以对其进行更多控制。例如，有些浏览器在默认情况下可能不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open()创建的窗口调整大小或移动位置。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">"http://shijiajie.com/"</span>,<span class="string">"newWindow"</span>,</div><div class="line">    <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 调整大小</span></div><div class="line">win.resizeTo(<span class="number">500</span>,<span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="comment">// 移动位置</span></div><div class="line">win.moveTo(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="comment">// 关闭窗口</span></div><div class="line">win.close();</div></pre></td></tr></table></figure>
<p>但是，<code>close()</code> 方法仅适用于通过 <code>window.open()</code> 打开的弹出窗口。对于浏览器的主窗口，如果没有得到用户的允许是不能关闭它的。</p>
<p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层 <code>window</code> 对象（top）中有定义，而且指向调用 <code>window.open()</code> 的窗口或框架。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">"http://shijiajie.com/"</span>,<span class="string">"newWindow"</span>,</div><div class="line">    <span class="string">"height=400,width=400,top=10,left=10,resizable=yes"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(win.opener === <span class="built_in">window</span>);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口，因此我们只能在必要的时候自己来手动实现跟踪。</p>
<h4 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h4><p>曾经有一段时间，广告商在网上使用弹出窗口达到了肆无忌惮的程度。他们经常把弹出窗口打扮成系统对话框的模样，引诱用户去点击其中的广告。由于看起来像是系统对话框，一般用户很难分辨是真是假。为了解决这个问题，大多数浏览器内置有弹出窗口屏蔽程序，将绝大多数用户不想看到弹出窗口屏蔽掉。</p>
<p>于是，在弹出窗口被屏蔽时，就应该考虑两种可能性。如果是浏览器内置的屏蔽程序阻止的弹出窗口，那么 <code>window.open()</code> 很可能会返回 <code>null</code>，如果是浏览器扩展或其他程序阻止的弹出窗口，那么 <code>window.open()</code> 通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 <code>window.open()</code> 的调用封装在一个 <code>try-catch</code> 块中，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> win = <span class="built_in">window</span>.open(<span class="string">"http://shijiajie.com"</span>, <span class="string">"_blank"</span>);</div><div class="line">    <span class="keyword">if</span> (win == <span class="literal">null</span>)&#123;</div><div class="line">        blocked = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">    blocked = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (blocked)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"The popup was blocked!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p>JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。</p>
<p>超时调用需要使用 <code>window</code> 对象的 <code>setTimeout()</code> 方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含 JavaScript 代码的字符串（就和在 <code>eval()</code> 函数中使用的字符串一样），也可以是一个函数。例如，下面对 <code>setTimeout()</code> 的两次调用都会在一秒钟后显示一个警告框。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不建议传递字符串</span></div><div class="line">setTimeout(<span class="string">"console.log('Hello world!') "</span>, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 推荐的调用方式</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>); </div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>虽然这两种调用方式都没有问题，但由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。</p>
<p>第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。<code>setTimeout()</code> 的第二个参数告诉 <code>JavaScript</code> 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p>
<p>调用 <code>setTimeout()</code> 之后，该方法会返回一个数值 <code>ID</code>，表示超时调用。这个超时调用 <code>ID</code> 是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 <code>clearTimeout()</code> 方法并将相应的超时调用 <code>ID</code> 作为参数传递给它，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置超时调用</span></div><div class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 注意：把它取消</span></div><div class="line">clearTimeout(timeoutId);</div></pre></td></tr></table></figure>
<p>只要是在指定的时间尚未过去之前调用 <code>clearTimeout()</code>，就可以完全取消超时调用。前面的代码在设置超时调用之后马上又调用了 <code>clearTimeout()</code>，结果就跟什么也没有发生一样。</p>
<p>间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 <code>setInterval()</code>，它接受的参数与 <code>setTimeout()</code> 相同：要执行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。下面来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不建议传递字符串</span></div><div class="line">setInterval (<span class="string">"console.log('Hello world!') "</span>, <span class="number">10000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 推荐的调用方式</span></div><div class="line">setInterval (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>); </div><div class="line">&#125;, <span class="number">10000</span>);</div></pre></td></tr></table></figure>
<p>调用 <code>setInterval()</code> 方法同样也会返回一个间歇调用 <code>ID</code>，该 <code>ID</code> 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 <code>clearInterval()</code> 方法并传入相应的间歇调用 <code>ID</code>。取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。以下是一个常见的使用间歇调用的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    num++;</div><div class="line">    <span class="comment">// 如果执行次数达到了max设定的值，则取消后续尚未执行的调用</span></div><div class="line">    <span class="keyword">if</span> (num == max) &#123;</div><div class="line">        clearInterval(intervalId);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中，变量num每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这个模式也可以使用超时调用来实现，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    num++;</div><div class="line"></div><div class="line">    <span class="comment">// 如果执行次数未达到max设定的值，则设置另一次超时调用</span></div><div class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</div><div class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Done"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(incrementNumber, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<p>可见，在使用超时调用时，没有必要跟踪超时调用 <code>ID</code>，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。</p>
<h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>浏览器通过 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含 HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由 CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</p>
<p>第一种对话框是调用 <code>alert()</code> 方法生成的。它向用户显示一个系统对话框，其中包含指定的文本和一个 OK（“确定”）按钮。通常使用 <code>alert()</code> 生成的“警告”对话框向用户显示一些他们无法控制的消息，例如错误消息。而用户只能在看完消息后关闭对话框。</p>
<p>第二种对话框是调用 <code>confirm()</code> 方法生成的。从向用户显示消息的方面来看，这种“确认”对话框很像是一个“警告”对话框。但二者的主要区别在于“确认”对话框除了显示OK按钮外，还会显示一个 Cancel（“取消”）按钮，两个按钮可以让用户决定是否执行给定的操作。</p>
<p>为了确定用户是单击了OK还是Cancel，可以检查 <code>confirm()</code> 方法返回的布尔值：<code>true</code> 表示单击了OK，<code>false</code> 表示单击了Cancel或单击了右上角的 X 按钮。确认对话框的典型用法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (confirm(<span class="string">"Are you sure?"</span>)) &#123;</div><div class="line">    alert(<span class="string">"I'm so glad you're sure! "</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">"I'm sorry to hear you're not sure."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后一种对话框是通过调用 <code>prompt()</code> 方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK 和 Cancel 按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。<code>prompt()</code> 方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。</p>
<p>如果用户单击了 OK 按钮，则 <code>promp()</code> 返回文本输入域的值；如果用户单击了 Cancel 或没有单击 OK 而是通过其他方式关闭了对话框，则该方法返回 <code>null</code>。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = prompt(<span class="string">"What is your name? "</span>, <span class="string">""</span>);</div><div class="line"><span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123;</div><div class="line">    alert(<span class="string">"Welcome, "</span> + result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上所述，这些系统对话框很适合向用户显示消息并请用户作出决定。由于不涉及 HTML、CSS 或 JavaScript，因此它们是增强 Web 应用程序的一种便捷方式。</p>
<h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a><code>location</code> 对象</h2><p><code>location</code> 对象提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，<code>location</code> 对象是很特别的一个对象，因为它既是 <code>window</code> 对象的属性，也是 <code>document</code> 对象的属性；换句话说，<code>window.location</code> 和 <code>document.location</code> 引用的是同一个对象。<code>location</code> 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。下表列出了 <code>location</code> 对象的所有属性。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td>“#contents”</td>
<td>返回 URL 中的 hash（#号后跟零或多个字符），如果 URL 中不包含散列，则返回空字符串</td>
</tr>
<tr>
<td>host</td>
<td>“shijiajie.com:80”</td>
<td>返回服务器名称和端口号（如果有）</td>
</tr>
<tr>
<td>hostname</td>
<td>“shijiajie.com”</td>
<td>返回不带端口号的服务器名称</td>
</tr>
<tr>
<td>href</td>
<td>“http:/shijiajie.com”</td>
<td>返回当前加载页面的完整URL。而 <code>location</code> 对象的 <code>toString()</code> 方法也返回这个值</td>
</tr>
<tr>
<td>pathname</td>
<td>“/WileyCDA/“</td>
<td>返回URL中的目录和（或）文件名</td>
</tr>
<tr>
<td>port</td>
<td>“8080”</td>
<td>返回 URL 中指定的端口号。如果 URL 中不包含端口号，则这个属性返回空字符串</td>
</tr>
<tr>
<td>protocol</td>
<td>“http:”</td>
<td>返回页面使用的协议。通常是 http: 或 https:</td>
</tr>
<tr>
<td>search</td>
<td>“?q=javascript”</td>
<td>返回URL的查询字符串。这个字符串以问号开头</td>
</tr>
</tbody>
</table>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><p>虽然通过上面的属性可以访问到 <code>location</code> 对象的大多数信息，但其中访问URL包含的查询字符串的属性并不方便。尽管 <code>location.search</code> 返回从问号到 URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这个函数用来解析来自URL的查询串中的name=value参数对</div><div class="line"> * 它将name=value对存储在一个对象的属性中，并返回该对象</div><div class="line"> * 这样来使用它</div><div class="line"> *</div><div class="line"> * var args = urlArgs(); // 从URL中解析参数</div><div class="line"> * var q = args.q || ""; // 如果参数定义了的话就使用参数；否则使用一个默认值</div><div class="line"> * var n = args.n ? parseInt(args.n) : 10;</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlArgs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = &#123;&#125;;                                  <span class="comment">// 定义一个空对象</span></div><div class="line">    <span class="keyword">var</span> query = location.search.substring(<span class="number">1</span>);       <span class="comment">// 查找到查询串，并去掉'? '</span></div><div class="line">    <span class="keyword">var</span> pairs = query.split(<span class="string">"&amp;"</span>);                   <span class="comment">// 根据"&amp;"符号将查询字符串分隔开</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) &#123;        <span class="comment">// 对于每个片段</span></div><div class="line">        <span class="keyword">var</span> pos = pairs[i].indexOf(<span class="string">'='</span>);            <span class="comment">// 查找"name=value"</span></div><div class="line">        <span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="keyword">continue</span>;                    <span class="comment">// 如果没有找到的话，就跳过</span></div><div class="line">        <span class="keyword">var</span> name = pairs[i].substring(<span class="number">0</span>, pos);      <span class="comment">// 提取name</span></div><div class="line">        <span class="keyword">var</span> value = pairs[i].substring(pos + <span class="number">1</span>);    <span class="comment">// 提取value</span></div><div class="line">        value = <span class="built_in">decodeURIComponent</span>(value);          <span class="comment">// 对value进行解码</span></div><div class="line">        args[name] = value;                         <span class="comment">// 存储为属性</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> args;                                    <span class="comment">// 返回解析后的参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><p>使用 <code>location</code> 对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用 <code>assign()</code>方法并为其传递一个 URL，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location.assign(<span class="string">"http://shijiajie.com"</span>);</div></pre></td></tr></table></figure>
<p>这样，就可以立即打开新URL并在浏览器的历史记录中生成一条记录。如果是将 <code>location.href</code> 或 <code>window.location</code> 设置为一个URL值，也会以该值调用 <code>assign()</code> 方法。例如，下列两行代码与显式调用 <code>assign()</code> 方法的效果完全一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.location = <span class="string">"http://shijiajie.com"</span>;</div><div class="line">location.href = <span class="string">"http://shijiajie.com"</span>;</div></pre></td></tr></table></figure>
<p>在这些改变浏览器位置的方法中，最常用的是设置 <code>location.href</code> 属性。</p>
<p>另外，修改 <code>location</code> 对象的其他属性也可以改变当前加载的页面。下面的例子展示了通过将 <code>hash</code>、<code>search</code>、<code>hostname</code>、<code>pathname</code> 和 <code>port</code> 属性设置为新值来改变 URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设初始 URL 为 http://shijiajie.com/about/</span></div><div class="line">location.href = <span class="string">"http://shijiajie.com/about/"</span></div><div class="line"></div><div class="line"><span class="comment">// 将 URL 修改为 "http://shijiajie.com/about/#ds-thread"</span></div><div class="line">location.hash = <span class="string">"#ds-thread"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将 URL 修改为 "http://shijiajie.com/about/?args=123"</span></div><div class="line">location.search = <span class="string">"?args=123"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将 URL 修改为 "https://segmentfault.com/"</span></div><div class="line">location.hostname = <span class="string">"segmentfault.com"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将 URL 修改为 "http://segmentfault.com/u/stone0090/"</span></div><div class="line">location.pathname = <span class="string">"u/stone0090"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将 URL 修改为 "https://segmentfault.com:8080/"</span></div><div class="line">location.port = <span class="number">8080</span>;</div></pre></td></tr></table></figure>
<p>当通过上述任何一种方式修改URL之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用 <code>replace()</code> 方法。这个方法只接受一个参数，即要导航到的 URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用 <code>replace()</code> 方法之后，用户不能回到前一个页面，来看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>You won't be able to get back here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Enjoy this page for a second, because you won't be coming back here.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"></span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">            location.replace(<span class="string">"http://shijiajie.com/"</span>);</div><div class="line">        &#125;, <span class="number">1000</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果将这个页面加载到浏览器中，浏览器就会在1秒钟后重新定向到 <code>shijiajie.com</code>。然后，“后退”按钮将处于禁用状态，如果不重新输入完整的 URL，则无法返回示例页面。</p>
<p>与位置有关的最后一个方法是 <code>reload()</code>，作用是重新加载当前显示的页面。如果调用 <code>reload()</code> 时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">location.reload();        <span class="comment">// 重新加载（有可能从缓存中加载）</span></div><div class="line">location.reload(<span class="literal">true</span>);    <span class="comment">// 重新加载（从服务器重新加载）</span></div></pre></td></tr></table></figure>
<p>位于 <code>reload()</code> 调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将 <code>reload()</code> 放在代码的最后一行。</p>
<h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a><code>history</code> 对象</h2><p><code>history</code> 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为 <code>history</code> 是 <code>window</code> 对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的 <code>history</code> 对象与特定的 <code>window</code> 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的 URL。不过，借由用户访问过的页面列表，同样可以在不知道实际 URL 的情况下实现后退和前进。</p>
<p>使用 <code>go()</code> 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 后退一页</span></div><div class="line">history.go(<span class="number">-1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 前进一页</span></div><div class="line">history.go(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 前进两页</span></div><div class="line">history.go(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>也可以给 <code>go()</code> 方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 跳转到最近的 shijiajie.com 页面</span></div><div class="line">history.go(<span class="string">"shijiajie.com"</span>);</div></pre></td></tr></table></figure>
<p>另外，还可以使用两个简写方法 <code>back()</code> 和 <code>forward()</code> 来代替 <code>go()</code>。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 后退一页</span></div><div class="line">history.back();</div><div class="line"></div><div class="line"><span class="comment">// 前进一页</span></div><div class="line">history.forward();</div></pre></td></tr></table></figure>
<p>除了上述几个方法外，<code>history</code> 对象还有一个 <code>length</code> 属性，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，<code>history.length</code> 等于0。通过像下面这样测试该属性的值，可以确定用户是否一开始就打开了你的页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (history.length == <span class="number">0</span>)&#123;</div><div class="line">    <span class="comment">//这应该是用户打开窗口后的第一个页面</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然 <code>history</code> 并不常用，但在创建自定义的“后退”和“前进”按钮，以及检测当前页面是不是用户历史记录中的第一个页面时，还是必须使用它。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>BOM（浏览器对象模型）以 <code>window</code> 对象为依托，表示浏览器窗口以及页面可见区域。同时，<code>window</code> 对象还是 ECMAScript 中的 <code>Global</code> 对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列 BOM 的组成部分。</p>
<ul>
<li>在使用框架时，每个框架都有自己的 <code>window</code> 对象以及所有原生构造函数及其他函数的副本。每个框架都保存在 <code>frames</code> 集合中，可以通过位置或通过名称来访问。</li>
<li>有一些窗口指针，可以用来引用其他框架，包括父框架。</li>
<li><code>top</code> 对象始终指向最外围的框架，也就是整个浏览器窗口。</li>
<li><code>parent</code> 对象表示包含当前框架的框架，而 <code>self</code> 对象则回指 <code>window</code>。</li>
<li>使用 <code>location</code> 对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的 URL。</li>
<li>调用 <code>replace()</code> 方法可以导航到一个新 URL，同时该 URL 会替换浏览器历史记录中当前显示的页面。</li>
<li><code>navigator</code> 对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如 <code>userAgent</code>）存在于所有浏览器中。</li>
</ul>
<p>BOM中还有两个对象：<code>screen</code> 和 <code>history</code>，但它们的功能有限。<code>screen</code> 对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。<code>history</code> 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</div><div class="line">&#125;, <span class="number">0</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"2"</span>);   <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);     <span class="comment">// ???</span></div><div class="line">    &#125;, <span class="number">0</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span> : <span class="number">2</span>,</div><div class="line">    <span class="attr">b</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">        &#125;, <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.b();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战四</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">a</span> : <span class="number">2</span>,</div><div class="line">    <span class="attr">b</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">        &#125;.call(<span class="keyword">this</span>), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">obj.b();    <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。多年来，缺少事实上的规范导致 BOM 有很多问题，因为浏览器提供商会按照各自的想法随意去扩展它。W3C 为了把浏览器中 JavaScript 最基本的部分标准化，已经将 BOM 的主要方面纳入了 HTML5 的规范中。&lt;/p&gt;
&lt;h2 id=&quot;window-对象&quot;&gt;&lt;a href=&quot;#window-对象&quot; class=&quot;headerlink&quot; title=&quot;window 对象&quot;&gt;&lt;/a&gt;&lt;code&gt;window&lt;/code&gt; 对象&lt;/h2&gt;&lt;p&gt;BOM 的核心对象是 &lt;code&gt;window&lt;/code&gt;，它表示浏览器的一个实例。在浏览器中，&lt;code&gt;window&lt;/code&gt; 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 &lt;code&gt;Global&lt;/code&gt; 对象。这意味着在网页中定义的任何一个对象、变量和函数，都以 &lt;code&gt;window&lt;/code&gt; 作为其 &lt;code&gt;Global&lt;/code&gt; 对象，因此有权访问 &lt;code&gt;isNaN()&lt;/code&gt;、&lt;code&gt;isFinite()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt;、&lt;code&gt;parseFloat()&lt;/code&gt; 等方法。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于 &lt;code&gt;window&lt;/code&gt; 对象同时扮演着 ECMAScript 中 &lt;code&gt;Global&lt;/code&gt; 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 &lt;code&gt;window&lt;/code&gt; 对象的属性和方法。来看下面的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayAge&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.age);    &lt;span class=&quot;comment&quot;&gt;// 29&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sayAge();                   &lt;span class=&quot;comment&quot;&gt;// 29&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.sayAge();            &lt;span class=&quot;comment&quot;&gt;// 29&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之单体内置对象</title>
    <link href="http://shisb.com/2016/11/01/javascript-lesson-1.12-SingletonBuiltInObjects/"/>
    <id>http://shisb.com/2016/11/01/javascript-lesson-1.12-SingletonBuiltInObjects/</id>
    <published>2016-11-01T14:30:00.000Z</published>
    <updated>2016-11-01T14:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMA-262 对内置对象的定义是「由 JavaScript 实现提供的、不依赖于宿主环境的对象，这些对象在 JavaScript 程序执行之前就已经存在了」。意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 <code>Object</code>、<code>Array</code> 和 <code>String</code>。ECMA-262 还定义了两个单体内置对象：<code>Global</code> 和 <code>Math</code>。</p>
<h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a><code>Global</code> 对象</h2><p><code>Global</code> 对象可以说是 JavaScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。<code>Global</code> 对象在某种意义上是作为一个终极的「兜底儿对象」来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是 <code>Global</code> 对象的属性。本书前面介绍过的那些函数，诸如 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code> 以及 <code>parseFloat()</code>，实际上全都是 <code>Global</code> 对象的方法。除此之外，<code>Global</code> 对象还包含其他一些方法。</p>
<a id="more"></a> 
<h3 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h3><p><code>Global</code> 对象的 <code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</p>
<p>其中，<code>encodeURI()</code> 主要用于整个 URI，而 <code>encodeURIComponent()</code> 主要用于对 URI 中的某一段进行编码。它们的主要区别在于，<code>encodeURI()</code> 不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而 <code>encodeURIComponent()</code> 则会对它发现的任何非标准字符进行编码。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http://shijiajie.com/illegal value.htm#start"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</div><div class="line"><span class="comment">// "http://shijiajie.com/illegal%20value.htm#start"</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</div><div class="line"><span class="comment">// "http%3A%2F%2Fshijiajie.com%2Fillegal%20value.htm%23start"</span></div></pre></td></tr></table></figure>
<p>使用 <code>encodeURI()</code> 编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 <code>%20</code>。而 <code>encodeURIComponent()</code> 方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个 URI 使用 <code>encodeURI()</code>，而只能对附加在现有 URI 后面的字符串使用 <code>encodeURIComponent()</code> 的原因所在。</p>
<p> 一般来说，我们使用 <code>encodeURIComponent()</code> 方法的时候要比使用 <code>encodeURI()</code> 更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</p>
<p>与 <code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 方法对应的两个方法分别是 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code>。其中，<code>decodeURI()</code> 只能对使用 <code>encodeURI()</code> 替换的字符进行解码。例如，它可将 <code>%20</code> 替换成一个空格，但不会对 <code>%23</code> 作任何处理，因为 <code>%23</code> 表示井字号 <code>#</code>，而井字号不是使用 <code>encodeURI()</code> 替换的。同样地，<code>decodeURIComponent()</code> 能够解码使用 <code>encodeURIComponent()</code> 编码的所有字符，即它可以解码任何特殊字符的编码。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> uri = <span class="string">"http%3A%2F%2Fshijiajie.com%2Fillegal%20value.htm%23start"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));</div><div class="line"><span class="comment">// http%3A%2F%2Fshijiajie.com%2Fillegal value.htm%23start</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</div><div class="line"><span class="comment">// http://shijiajie.com/illegal value.htm#start</span></div></pre></td></tr></table></figure>
<p>这里，变量 <code>uri</code> 包含着一个由 <code>encodeURIComponent()</code> 编码的字符串。在第一次调用 <code>decodeURI()</code> 输出的结果中，只有 <code>%20</code> 被替换成了空格。而在第二次调用 <code>decodeURIComponent()</code> 输出的结果中，所有特殊字符的编码都被替换成了原来的字符，得到了一个未经转义的字符串（但这个字符串并不是一个有效的 URI）。</p>
<h3 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval() 方法"></a><code>eval()</code> 方法</h3><p><code>eval()</code> 方法就像是一个完整的 JavaScript 解析器，它只接受一个参数，即要执行的 JavaScript 字符串。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"console.log('hi')"</span>);</div></pre></td></tr></table></figure>
<p>这行代码的作用等价于下面这行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure>
<p>当解析器发现代码中调用 <code>eval()</code> 方法时，它会将传入的参数当作实际的 JavaScript 语句来解析，然后把执行结果插入到原位置。通过 <code>eval()</code> 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过 <code>eval()</code> 执行的代码可以引用在包含环境中定义的变量，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"console.log(msg)"</span>);    <span class="comment">// "hello world"</span></div></pre></td></tr></table></figure>
<p>可见，变量 <code>msg</code> 是在 <code>eval()</code> 调用的环境之外定义的，但其中调用的 <code>console.log()</code> 仍然能够显示 <code>&quot;hello world&quot;</code>。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在 <code>eval()</code> 调用中定义一个函数，然后再在该调用的外部代码中引用这个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; console.log('hi'); &#125;"</span>);</div><div class="line">sayHi();    <span class="comment">// "hi"</span></div></pre></td></tr></table></figure>
<p>显然，函数 <code>sayHi()</code> 是在 <code>eval()</code> 内部定义的。但由于对 <code>eval()</code> 的调用最终会被替换成定义函数的实际代码，因此可以在下一行调用 <code>sayHi()</code> 。对于变量也一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world';"</span>);</div><div class="line"><span class="built_in">console</span>.log(msg);     <span class="comment">// "hello world"</span></div></pre></td></tr></table></figure>
<p>在 <code>eval()</code> 中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 <code>eval()</code> 执行的时候创建。</p>
<p>严格模式下，在外部访问不到 <code>eval()</code> 中创建的任何变量或函数，因此前面两个例子都会导致错误。同样，在严格模式下，为 <code>eval</code> 赋值也会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span> = <span class="string">"hi"</span>;   <span class="comment">// causes error</span></div></pre></td></tr></table></figure>
<p> 能够解释代码字符串的能力非常强大，但也非常危险。因此在使用 <code>eval()</code> 时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）。</p>
<h3 id="Global-对象的属性"><a href="#Global-对象的属性" class="headerlink" title="Global 对象的属性"></a><code>Global</code> 对象的属性</h3><p><code>Global</code> 对象还包含一些属性，其中一部分属性已经在本书前面介绍过了。例如，特殊的值 <code>undefined</code>、<code>NaN</code> 以及 <code>Infinity</code> 都是 <code>Global</code> 对象的属性。此外，所有原生引用类型的构造函数，像 <code>Object</code> 和 <code>Function</code>，也都是 <code>Global</code> 对象的属性。下表列出了 <code>Global</code> 对象的所有属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>特殊值undefined</td>
<td>Date</td>
<td>构造函数Date</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值NaN</td>
<td>RegExp</td>
<td>构造函数RegExp</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值Infinity</td>
<td>Error</td>
<td>构造函数Error</td>
</tr>
<tr>
<td>Object</td>
<td>构造函数Object</td>
<td>EvalError</td>
<td>构造函数EvalError</td>
</tr>
<tr>
<td>Array</td>
<td>构造函数Array</td>
<td>RangeError</td>
<td>构造函数RangeError</td>
</tr>
<tr>
<td>Function</td>
<td>构造函数Function</td>
<td>ReferenceError</td>
<td>构造函数ReferenceError</td>
</tr>
<tr>
<td>Boolean</td>
<td>构造函数Boolean</td>
<td>SyntaxError</td>
<td>构造函数SyntaxError</td>
</tr>
<tr>
<td>String</td>
<td>构造函数String</td>
<td>TypeError</td>
<td>构造函数TypeError</td>
</tr>
<tr>
<td>Number</td>
<td>构造函数Number</td>
<td>URIError</td>
<td>构造函数URIError</td>
</tr>
</tbody>
</table>
<p>ECMAScript 5 明确禁止给 <code>undefined</code>、<code>NaN</code> 和 <code>Infinity</code> 赋值，这样做即使在非严格模式下也会导致错误。</p>
<h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a><code>window</code> 对象</h3><p>JavaScript 虽然没有指出如何直接访问 <code>Global</code> 对象，但 Web 浏览器都是将这个全局对象作为 <code>window</code> 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了 <code>window</code> 对象的属性。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.sayColor();  <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>JavaScript 中的 <code>window</code> 对象除了扮演规定的 <code>Global</code> 对象的角色外，还承担了很多别的任务。</p>
<p>##　<code>Math</code> 对象</p>
<p>JavaScript 还为保存数学公式和信息提供了一个公共位置，即 <code>Math</code> 对象。与我们在 <code>JavaScript</code> 直接编写的计算功能相比，<code>Math</code> 对象提供的计算功能执行起来要快得多。<code>Math</code> 对象中还提供了辅助完成这些计算的属性和方法。</p>
<h3 id="Math-对象的属性"><a href="#Math-对象的属性" class="headerlink" title="Math 对象的属性"></a><code>Math</code> 对象的属性</h3><p><code>Math</code> 对象包含的属性大都是数学计算中可能会用到的一些特殊值。下表列出了这些属性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底e的对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底e的对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根（即2的平方根的倒数）</td>
</tr>
<tr>
<td>Math.SQRT2</td>
<td>2的平方根</td>
</tr>
</tbody>
</table>
<h3 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min() 和 max() 方法"></a><code>min()</code> 和 <code>max()</code> 方法</h3><p><code>Math</code> 对象还包含许多方法，用于辅助完成简单和复杂的数学计算。其中，<code>min()</code> 和 <code>max()</code> 方法用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</div><div class="line"><span class="built_in">console</span>.log(max);    <span class="comment">// 54</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</div><div class="line"><span class="built_in">console</span>.log(min);    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>要找到数组中的最大或最小值，可以像下面这样使用 <code>apply()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</div><div class="line"><span class="built_in">console</span>.log(max);   <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>这个技巧的关键是把 <code>Math</code> 对象作为 <code>apply()</code> 的第一个参数，从而正确地设置 <code>this</code> 值。然后，可以将任何数组作为第二个参数。</p>
<h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><p>下面来介绍将小数值舍入为整数的几个方法：<code>Math.ceil()</code>、<code>Math.floor()</code> 和 <code>Math.round()</code>。这三个方法分别遵循下列舍入规则：</p>
<ul>
<li><code>Math.ceil()</code> 执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li><code>Math.floor()</code> 执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li><code>Math.round()</code> 执行标准舍入，即它总是将数值四舍五入为最接近的整数。</li>
</ul>
<p>下面是使用这些方法的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>));     <span class="comment">// 26</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.5</span>));     <span class="comment">// 26</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));     <span class="comment">// 26</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.9</span>));    <span class="comment">// 26</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>));    <span class="comment">// 26</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>));    <span class="comment">// 25</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>));    <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.5</span>));    <span class="comment">// 25</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>));    <span class="comment">// 25</span></div></pre></td></tr></table></figure>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random() 方法"></a><code>random()</code> 方法</h3><p><code>Math.random()</code> 方法返回介于0和1之间一个随机数，不包括0和1。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用 <code>Math.random()</code> 从某个整数范围内随机选择一个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">值 = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * 可能值的总数 + 第一个可能的值)</div></pre></td></tr></table></figure>
<p>公式中用到了 <code>Math.floor()</code> 方法，这是因为 <code>Math.random()</code> 总返回一个小数值。而用这个小数值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个1到10之间的数值，可以像下面这样编写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>总共有10个可能的值（1到10），而第一个可能的值是1。而如果想要选择一个介于2到10之间的值，就应该将上面的代码改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">9</span> + <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>从2数到10要数9个数，因此可能值的总数就是9，而第一个可能的值就是2。多数情况下，其实都可以通过一个函数来计算可能值的总数和第一个可能的值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">// 介于2和10之间（包括2和10）的一个数值</span></div></pre></td></tr></table></figure>
<p>函数 <code>selectFrom()</code> 接受两个参数：应该返回的最小值和最大值。而用最大值减最小值再加1得到了可能值的总数，然后它又把这些数值套用到了前面的公式中。这样，通过调用 <code>selectFrom(2,10)</code> 就可以得到一个介于2和10之间（包括2和10）的数值了。利用这个函数，可以方便地从数组中随机取出一项，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"purple"</span>, <span class="string">"brown"</span>];</div><div class="line"><span class="keyword">var</span> color = colors[selectFrom(<span class="number">0</span>, colors.length<span class="number">-1</span>)];</div><div class="line"><span class="built_in">console</span>.log(color);  <span class="comment">// 可能是数组中包含的任何一个字符串</span></div></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p><code>Math</code> 对象中还包含其他一些与完成各种简单或复杂计算有关的方法，但详细讨论其中每一个方法的细节及适用情形超出了本书的范围。下面我们就给出一个表格，其中列出了这些没有介绍到的 <code>Math</code> 对象的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.abs(num)</td>
<td>返回num的绝对值</td>
</tr>
<tr>
<td>Math.asin(x)</td>
<td>返回x的反正弦值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E的num次幂</td>
</tr>
<tr>
<td>Math.atan(x)</td>
<td>返回x的反正切值</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num的自然对数</td>
</tr>
<tr>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切值</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num的power次幂</td>
</tr>
<tr>
<td>Math.cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num的平方根</td>
</tr>
<tr>
<td>Math.sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦值</td>
</tr>
<tr>
<td>Math.tan(x)</td>
<td>返回x的正切值</td>
</tr>
</tbody>
</table>
<p>虽然 ECMA-262 规定了这些方法，但不同实现可能会对这些方法采用不同的算法。毕竟，计算某个值的正弦、余弦和正切的方式多种多样。也正因为如此，这些方法在不同的实现中可能会有不同的精度。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如何高效产生m个n范围内的不重复随机数（m&lt;=n)</span></div><div class="line"><span class="keyword">var</span> getRandomNumber = <span class="function"><span class="keyword">function</span>(<span class="params">n, m</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(getRandomNumber(<span class="number">20</span>, <span class="number">3</span>));  <span class="comment">// 8,4,19</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMA-262 对内置对象的定义是「由 JavaScript 实现提供的、不依赖于宿主环境的对象，这些对象在 JavaScript 程序执行之前就已经存在了」。意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 &lt;code&gt;Object&lt;/code&gt;、&lt;code&gt;Array&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt;。ECMA-262 还定义了两个单体内置对象：&lt;code&gt;Global&lt;/code&gt; 和 &lt;code&gt;Math&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;Global-对象&quot;&gt;&lt;a href=&quot;#Global-对象&quot; class=&quot;headerlink&quot; title=&quot;Global 对象&quot;&gt;&lt;/a&gt;&lt;code&gt;Global&lt;/code&gt; 对象&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Global&lt;/code&gt; 对象可以说是 JavaScript 中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。&lt;code&gt;Global&lt;/code&gt; 对象在某种意义上是作为一个终极的「兜底儿对象」来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。所有在全局作用域中定义的属性和函数，都是 &lt;code&gt;Global&lt;/code&gt; 对象的属性。本书前面介绍过的那些函数，诸如 &lt;code&gt;isNaN()&lt;/code&gt;、&lt;code&gt;isFinite()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt; 以及 &lt;code&gt;parseFloat()&lt;/code&gt;，实际上全都是 &lt;code&gt;Global&lt;/code&gt; 对象的方法。除此之外，&lt;code&gt;Global&lt;/code&gt; 对象还包含其他一些方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之基本包装类型</title>
    <link href="http://shisb.com/2016/10/26/javascript-lesson-1.11-PrimitiveWrapperObjects/"/>
    <id>http://shisb.com/2016/10/26/javascript-lesson-1.11-PrimitiveWrapperObjects/</id>
    <published>2016-10-26T15:00:00.000Z</published>
    <updated>2016-11-22T12:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：<code>Boolean</code>、<code>Number</code> 和 <code>String</code>。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>这个例子中的变量 <code>s1</code> 包含一个字符串，字符串当然是基本类型值。而下一行调用了 <code>s1</code> 的 <code>substring()</code> 方法，并将返回的结果保存在了 <code>s2</code> 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 <code>s1</code> 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<ol>
<li>创建 <code>String</code> 类型的一个实例；</li>
<li>在实例上调用指定的方法；</li>
<li>销毁这个实例。</li>
</ol>
<p>可以将以上三个步骤想象成是执行了下列 JavaScript 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</div><div class="line">s1 = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 <code>Boolean</code> 和 <code>Number</code> 类型对应的布尔值和数字值。</p>
<a id="more"></a> 
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用 <code>new</code> 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</div><div class="line">s1.color = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(s1.color);   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>当然，可以显式地调用 <code>Boolean</code>、<code>Number</code> 和 <code>String</code> 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理「基本类型」还是「引用类型」的值。对基本包装类型的实例调用 <code>typeof</code> 会返回 <code>&quot;object&quot;</code>，而且所有基本包装类型的对象都会被转换为布尔值 <code>true</code>。</p>
<p><code>Object</code> 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</div><div class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>把字符串传给 <code>Object</code> 构造函数，就会创建 <code>String</code> 的实例；而传入数值参数会得到 <code>Number</code> 的实例，传入布尔值参数就会得到 <code>Boolean</code> 的实例。</p>
<p>要注意的是，使用 <code>new</code> 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</div><div class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value);  <span class="comment">// 转型函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number);  <span class="comment">// "number"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);     <span class="comment">// "object"</span></div></pre></td></tr></table></figure>
<p>尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。</p>
<p>##　<code>Boolean</code> 类型</p>
<p><code>Boolean</code> 类型是与布尔值对应的引用类型。要创建 <code>Boolean</code> 对象，可以像下面这样调用 <code>Boolean</code> 构造函数并传入 <code>true</code> 或 <code>false</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> booleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p><code>Boolean</code> 类型的实例重写了 <code>valueOf()</code> 方法，返回基本类型值 <code>true</code> 或 <code>false</code>；重写了 <code>toString()</code> 方法，返回字符串 <code>&quot;true&quot;</code> 和 <code>&quot;false&quot;</code>。可是，<code>Boolean</code> 对象在 JavaScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 <code>Boolean</code> 对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</div><div class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用 <code>false</code> 值创建了一个 <code>Boolean</code> 对象。然后，将这个对象与基本类型值 <code>true</code> 构成了逻辑与表达式。在布尔运算中，<code>false &amp;&amp; true</code> 等于 <code>false</code>。可是，示例中的这行代码是对 <code>falseObject</code> 而不是对它的值 <code>false</code> 进行求值。布尔表达式中的所有对象都会被转换为 <code>true</code>，因此 <code>falseObject</code> 对象在布尔表达式中代表的是 <code>true</code>。结果，<code>true &amp;&amp; true</code> 当然就等于 <code>true</code> 了。</p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，<code>typeof</code> 操作符对基本类型返回 <code>&quot;boolean&quot;</code>，而对引用类型返回 <code>&quot;object&quot;</code>。其次，由于 <code>Boolean</code> 对象是 <code>Boolean</code> 类型的实例，所以使用 <code>instanceof</code> 操作符测试 <code>Boolean</code> 对象会返回 <code>true</code>，而测试基本类型的布尔值则返回 <code>false</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);   <span class="comment">// object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseValue);    <span class="comment">// boolean</span></div><div class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>理解基本类型的布尔值与 <code>Boolean</code> 对象之间的区别非常重要，我们的建议是永远不要使用 <code>Boolean</code> 对象。</p>
<p>##　<code>Number</code> 类型</p>
<p><code>Number</code> 是与数字值对应的引用类型。要创建 <code>Number</code> 对象，可以在调用 <code>Number</code> 构造函数时向其中传递相应的数值。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div></pre></td></tr></table></figure>
<p>与 <code>Boolean</code> 类型一样，<code>Number</code> 类型也重写了 <code>valueOf()</code>、<code>toLocaleString()</code> 和 <code>toString()</code> 方法。重写后的 <code>valueOf()</code> 方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。可以为 <code>toString()</code> 方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toString());     <span class="comment">// "10"</span></div><div class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));    <span class="comment">// "1010"</span></div><div class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));    <span class="comment">// "12"</span></div><div class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));   <span class="comment">// "10"</span></div><div class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));   <span class="comment">// "a"</span></div></pre></td></tr></table></figure>
<p>除了继承的方法之外，<code>Number</code> 类型还提供了一些用于将数值格式化为字符串的方法。其中，<code>toFixed()</code> 方法会按照指定的小数位返回数值的字符串表示，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));    <span class="comment">// "10.00"</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">这里给 `toFixed()<span class="string">` 方法传入了数值 `</span><span class="number">2</span><span class="string">`，意思是显示几位小数。于是，这个方法返回了 `</span><span class="string">"10.00"</span><span class="string">`，即以 `</span><span class="number">0</span><span class="string">` 填补了必要的小数位。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入，如下面的例子所示。</span></div><div class="line"></div><div class="line">`<span class="string">``</span> javascript</div><div class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));    <span class="comment">// "10.01"</span></div></pre></td></tr></table></figure>
<p>能够自动舍入的特性，使得 <code>toFixed()</code> 方法很适合处理货币值。</p>
<blockquote>
<p>但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。</p>
<p>在给 <code>toFixed()</code> 传入0的情况下，IE8 及之前版本不能正确舍入范围在{(-0.94,-0.5],[0.5,0.94)}之间的值。对于这个范围内的值，IE8 会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9 修复了这个问题。</p>
<p><code>toFixed()</code> 方法可以表示带有0到20个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p>
</blockquote>
<p>另外可用于格式化数值的方法是 <code>toExponential()</code>，该方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式。与 <code>toFixed()</code> 一样，<code>toExponential()</code> 也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>));     <span class="comment">// "1.0e+1"</span></div></pre></td></tr></table></figure>
<p>以上代码输出了 <code>&quot;1.0e+1&quot;</code>；不过，这么小的数值一般不必使用 e 表示法。如果你想得到表示某个数值的最合适的格式，就应该使用 <code>toPrecision()</code> 方法。</p>
<p>对于一个数值来说，<code>toPrecision()</code> 方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</div><div class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>));     <span class="comment">// "1e+2"</span></div><div class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>));     <span class="comment">// "99"</span></div><div class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>));     <span class="comment">// "99.0"</span></div></pre></td></tr></table></figure>
<p>以上代码首先完成的任务是以一位数来表示 <code>99</code>，结果是 <code>&quot;1e+2&quot;</code>，即 <code>100</code>。因为一位数无法准确地表示 <code>99</code>，因此 <code>toPrecision()</code> 就将它向上舍入为 <code>100</code>，这样就可以使用一位数来表示它了。而接下来的用两位数表示 <code>99</code>，当然还是 <code>&quot;99&quot;</code>。最后，在想以三位数表示 <code>99</code> 时，<code>toPrecision()</code> 方法返回了 <code>&quot;99.0&quot;</code>。实际上，<code>toPrecision()</code> 会根据要处理的数值决定到底是调用 <code>toFixed()</code> 还是调用 <code>toExponential()</code>。而这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值。</p>
<blockquote>
<p><code>toPrecision()</code> 方法可以表现1到21位小数。但这只是标准实现的范围，有些浏览器也可能支持更多位数。</p>
</blockquote>
<p>与 <code>Boolean</code> 对象类似，<code>Number</code> 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化 <code>Number</code> 类型，而原因与显式创建 <code>Boolean</code> 对象一样。具体来讲，就是在使用 <code>typeof</code> 和 <code>instanceof</code> 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"><span class="keyword">var</span> numberValue = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject);   <span class="comment">// "object"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberValue);    <span class="comment">// "number"</span></div><div class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>);   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><code>String</code> 类型</h2><p><code>String</code> 类型是字符串的对象包装类型，可以像下面这样使用 <code>String</code> 构造函数来创建。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>
<p><code>String</code> 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 <code>valueOf()</code>、<code>toLocaleString()</code> 和 <code>toString()</code> 方法，都返回对象所表示的基本字符串值。</p>
<p><code>String</code> 类型的每个实例都有一个 <code>length</code> 属性，表示字符串中包含多个字符。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.length);     <span class="comment">// 11</span></div></pre></td></tr></table></figure>
<p>应该注意的是，即使字符串中包含双字节字符（不是占一个字节的 ASCII 字符），每个字符也仍然算一个字符。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"大家好"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.length);     <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p><code>String</code> 类型提供了很多方法，用于辅助完成对 JavaScript 中字符串的解析和操作。</p>
<h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>两个用于访问字符串中特定字符的方法是：<code>charAt()</code> 和 <code>charCodeAt()</code>。这两个方法都接收一个参数，即基于0的字符位置。其中，<code>charAt()</code> 方法以单字符字符串的形式返回给定位置的那个字符（JavaScript 中没有字符类型）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.charAt(<span class="number">1</span>));  <span class="comment">// "e"</span></div></pre></td></tr></table></figure>
<p>如果你想得到的不是字符而是字符编码，那么就要像下面这样使用 <code>charCodeAt()</code> 了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.charCodeAt(<span class="number">1</span>));  <span class="comment">// 101，101是小写字母"e"的字符编码</span></div></pre></td></tr></table></figure>
<p>ECMAScript 5 还定义了另一个访问个别字符的方法。在支持浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue[<span class="number">1</span>]);   <span class="comment">// "e"</span></div></pre></td></tr></table></figure>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>下面介绍与操作字符串有关的几个方法。第一个就是 <code>concat()</code>，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。先来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result);        <span class="comment">// "hello world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue);   <span class="comment">// "hello"</span></div></pre></td></tr></table></figure>
<p>实际上，<code>concat()</code> 方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</div><div class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(result);        <span class="comment">// "hello world!"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue);   <span class="comment">// "hello"</span></div></pre></td></tr></table></figure>
<p>虽然 <code>concat()</code> 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符 <code>+</code> 。而且，使用加号操作符 <code>+</code> 在大多数情况下都比使用 <code>concat()</code>方法要简便易行（特别是在拼接多个字符串的情况下）。</p>
<p>JavaScript 还提供了三个基于子字符串创建新字符串的方法：<code>slice()</code>、<code>substr()</code> 和 <code>substring()</code>。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，<code>slice()</code> 和 <code>substring()</code> 的第二个参数指定的是子字符串最后一个字符后面的位置。而 <code>substr()</code> 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与 <code>concat()</code> 方法一样，<code>slice()</code>、<code>substr()</code> 和 <code>substring()</code>也不会修改字符串本身的值，它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));            <span class="comment">// "lo world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));        <span class="comment">// "lo world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));           <span class="comment">// "lo world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">7</span>));         <span class="comment">// "lo w"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));      <span class="comment">// "lo w"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">7</span>));        <span class="comment">// "lo worl"</span></div></pre></td></tr></table></figure>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，<code>slice()</code> 方法会将传入的负值与字符串的长度相加，<code>substr()</code> 方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，<code>substring()</code> 方法会把所有负值参数都转换为0。下面来看例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">-3</span>));           <span class="comment">// "rld"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">-3</span>));       <span class="comment">// "hello world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">-3</span>));          <span class="comment">// "rld"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>, <span class="number">-4</span>));        <span class="comment">// "lo w"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>, <span class="number">-4</span>));    <span class="comment">// "hel"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>, <span class="number">-4</span>));       <span class="comment">//""（空字符串）</span></div></pre></td></tr></table></figure>
<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>有两个可以从字符串中查找子字符串的方法：<code>indexOf()</code> 和 <code>lastIndexOf()</code>。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于：<code>indexOf()</code> 方法从字符串的开头向后搜索子字符串，而 <code>lastIndexOf()</code> 方法是从字符串的末尾向前搜索子字符串。还是来看一个例子吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>));             <span class="comment">// 4</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>));         <span class="comment">// 7</span></div></pre></td></tr></table></figure>
<p>这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.indexOf(<span class="string">"o"</span>, <span class="number">6</span>));          <span class="comment">// 7</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>));      <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>在使用第二个参数的情况下，可以通过循环调用 <code>indexOf()</code> 或 <code>lastIndexOf()</code> 来找到所有匹配的子字符串，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"Lorem ipsum dolor sit amet, consectetur adipisicing elit"</span>;</div><div class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(pos &gt; <span class="number">-1</span>)&#123;</div><div class="line">    positions.push(pos);</div><div class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(positions);    <span class="comment">// "3,24,32,35,52"</span></div></pre></td></tr></table></figure>
<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a><code>trim()</code> 方法</h3><p>ECMAScript 5 为所有字符串定义了 <code>trim()</code> 方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"   hello world   "</span>;</div><div class="line"><span class="keyword">var</span> trimmedStringValue = stringValue.trim();</div><div class="line"><span class="built_in">console</span>.log(stringValue);            <span class="comment">// "   hello world   "</span></div><div class="line"><span class="built_in">console</span>.log(trimmedStringValue);     <span class="comment">// "hello world"</span></div></pre></td></tr></table></figure>
<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>JavaScript 中涉及字符串大小写转换的方法有4个：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code> 和 <code>toLocaleUpperCase()</code>。其中，<code>toLowerCase()</code> 和 <code>toUpperCase()</code> 是两个经典的方法，借鉴自 <code>java.lang.String</code> 中的同名方法。而 <code>toLocaleLowerCase()</code> 和 <code>toLocaleUpperCase()</code> 方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。以下是几个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());  <span class="comment">// "HELLO WORLD"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());        <span class="comment">// "HELLO WORLD"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());  <span class="comment">// "hello world"</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());        <span class="comment">// "hello world"</span></div></pre></td></tr></table></figure>
<p>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。</p>
<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><p><code>String</code> 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 <code>match()</code>，在字符串上调用这个方法，本质上与调用 <code>RegExp</code> 的 <code>exec()</code> 方法相同。<code>match()</code> 方法只接受一个参数，要么是一个正则表达式，要么是一个 <code>RegExp</code> 对象。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>; </div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</div><div class="line"></div><div class="line"><span class="comment">// 与pattern.exec(text)相同</span></div><div class="line"><span class="keyword">var</span> matches = text.match(pattern);</div><div class="line"><span class="built_in">console</span>.log(matches.index);               <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);                  <span class="comment">// "cat"</span></div><div class="line"><span class="built_in">console</span>.log(pattern.lastIndex);           <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>另一个用于查找模式的方法是 <code>search()</code>。这个方法的唯一参数与 <code>match()</code> 方法的参数相同：由字符串或 <code>RegExp</code> 对象指定的一个正则表达式。<code>search()</code> 方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，<code>search()</code> 方法始终是从字符串开头向后查找模式。看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>; </div><div class="line"><span class="keyword">var</span> pos = text.search(<span class="regexp">/at/</span>);</div><div class="line"><span class="built_in">console</span>.log(pos);   <span class="comment">// 1，即"at"第一次出现的位置</span></div></pre></td></tr></table></figure>
<p>为了简化替换子字符串的操作，JavaScript 提供了 <code>replace()</code> 方法。这个方法接受两个参数：第一个参数可以是一个 <code>RegExp</code> 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局 <code>g</code> 标志，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>; </div><div class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);    <span class="comment">// "cond, bat, sat, fat"</span></div><div class="line"></div><div class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</div><div class="line"><span class="built_in">console</span>.log(result);    <span class="comment">// "cond, bond, sond, fond"</span></div></pre></td></tr></table></figure>
<p>最后一个与模式匹配有关的方法是 <code>split()</code>，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 <code>RegExp</code> 对象（这个方法不会将字符串看成正则表达式）。<code>split()</code> 方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</div><div class="line"><span class="keyword">var</span> colors1 = colorText.split(<span class="string">","</span>);          <span class="comment">// ["red", "blue", "green", "yellow"]</span></div><div class="line"><span class="keyword">var</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>);       <span class="comment">// ["red", "blue"]</span></div></pre></td></tr></table></figure>
<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a><code>localeCompare()</code> 方法</h3><p>这个方法比较两个字符串，并返回下列值中的一个：</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回0；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）。</li>
</ul>
<p>下面是几个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;       </div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"brick"</span>));    <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"yellow"</span>));   <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"zoo"</span>));      <span class="comment">// -1</span></div></pre></td></tr></table></figure>
<p>这个例子比较了字符串 <code>&quot;yellow&quot;</code> 和另外几个值：<code>&quot;brick&quot;</code>、<code>&quot;yellow&quot;</code> 和 <code>&quot;zoo&quot;</code>。因为 <code>&quot;brick&quot;</code> 在字母表中排在 <code>&quot;yellow&quot;</code> 之前，所以 <code>localeCompare()</code> 返回了1；而 <code>&quot;yellow&quot;</code> 等于 <code>&quot;yellow&quot;</code>，所以 <code>localeCompare()</code> 返回了0；最后，<code>&quot;zoo&quot;</code> 在字母表中排在 <code>&quot;yellow&quot;</code> 后面，所以 <code>localeCompare()</code> 返回了-1。再强调一次，因为 <code>localeCompare()</code> 返回的数值取决于实现，所以最好是像下面例子所示的这样使用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">determineOrder</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = stringValue.localeCompare(value);</div><div class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The string 'yellow' comes before the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The string 'yellow' comes after the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"The string 'yellow' is equal to the string '"</span> + value + <span class="string">"'."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">determineOrder(<span class="string">"brick"</span>);</div><div class="line">determineOrder(<span class="string">"yellow"</span>);</div><div class="line">determineOrder(<span class="string">"zoo"</span>);</div></pre></td></tr></table></figure>
<p>使用这种结构，就可以确保自己的代码在任何实现中都可以正确地运行了。</p>
<p><code>localeCompare()</code> 方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。比如，美国以英语作为 JavaScript 实现的标准语言，因此 <code>localeCompare()</code> 就是区分大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他地区恐怕就不是这种情况了。</p>
<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a><code>fromCharCode()</code> 方法</h3><p>另外，<code>String</code> 构造函数本身还有一个静态方法：<code>fromCharCode()</code>。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 <code>charCodeAt()</code> 执行的是相反的操作。来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">// "hello"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;s[i]&#125;</span>----<span class="subst">$&#123;s[i].charCodeAt()&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">"h----104"</div><div class="line">"e----101"</div><div class="line">"l----108"</div><div class="line">"l----108"</div><div class="line">"o----111"</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>在这里，我们给 <code>fromCharCode()</code> 传递的是字符串 <code>&quot;hello&quot;</code> 中每个字母的字符编码。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一</span></div><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">false</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObject);             <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二</span></div><div class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">100</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numberObject);             <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>);  <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三</span></div><div class="line"><span class="keyword">var</span> stringObject = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"abcde"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> stringObject);             <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(stringObject <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// ???</span></div><div class="line"><span class="built_in">console</span>.log(stringObject <span class="keyword">instanceof</span> <span class="built_in">String</span>);  <span class="comment">// ???</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战四，翻转一个字符串</span></div><div class="line"><span class="comment">// 提示：可以使用数组的 reverse() 方法</span></div><div class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(reverse(<span class="string">"hello"</span>));  <span class="comment">// "olleh"</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了便于操作基本类型值，JavaScript 还提供了3个特殊的引用类型：&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt;。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的变量 &lt;code&gt;s1&lt;/code&gt; 包含一个字符串，字符串当然是基本类型值。而下一行调用了 &lt;code&gt;s1&lt;/code&gt; 的 &lt;code&gt;substring()&lt;/code&gt; 方法，并将返回的结果保存在了 &lt;code&gt;s2&lt;/code&gt; 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 &lt;code&gt;s1&lt;/code&gt; 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建 &lt;code&gt;String&lt;/code&gt; 类型的一个实例；&lt;/li&gt;
&lt;li&gt;在实例上调用指定的方法；&lt;/li&gt;
&lt;li&gt;销毁这个实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以将以上三个步骤想象成是执行了下列 JavaScript 代码。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 &lt;code&gt;Boolean&lt;/code&gt; 和 &lt;code&gt;Number&lt;/code&gt; 类型对应的布尔值和数字值。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之正则表达式</title>
    <link href="http://shisb.com/2016/10/17/javascript-lesson-1.10-RegExpObjects/"/>
    <id>http://shisb.com/2016/10/17/javascript-lesson-1.10-RegExpObjects/</id>
    <published>2016-10-17T14:30:00.000Z</published>
    <updated>2016-10-17T14:38:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于本课程的核心是 JavaScript，所以本文着重讲解了「正则表达式」在 JavaScript 中的用法，并未深入「正则表达式」的具体细节。如果您尚不了解「正则表达式」，强烈推荐您先学习 <strong>正则表达式30分钟入门教程 <a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">http://deerchao.net/tutorials/regex/regex.htm</a></strong> 之后，再进行本课程的学习。</p>
</blockquote>
<p>正则表达式（regular expression）是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。JavaScript 的正则表达式语法是 Perl5 的正则表达式语法的大型子集，所以对于有 Perl 编程经验的程序员来说，学习 JavaScript 中的正则表达式是小菜一碟。</p>
<h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>JavaScript 中的正则表达式用 <code>RegExp</code> 对象表示，可以使用 <code>RegExp()</code> 构造函数来创建 <code>RegExp</code> 对象，不过 <code>RegExp</code> 对象更多是通过字面量的语法来创建，使用下面类似 Perl 的语法，就可以创建一个正则表达式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 推荐写法</span></div><div class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</div><div class="line"></div><div class="line"><span class="comment">// 不推荐写法</span></div><div class="line"><span class="keyword">var</span> expression = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern, flags);</div></pre></td></tr></table></figure>
<a id="more"></a> 
<p>其中的模式（pattern）部分，是包含在一对斜杠 <code>/</code> 之间的字符，可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志。</p>
<ul>
<li><code>g</code>：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li><code>i</code>：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li><code>m</code>：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
</ul>
<p>因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配字符串中所有"at"的实例</span></div><div class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</div><div class="line"></div><div class="line"><span class="comment">// 匹配第一个"bat"或"cat"，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</div><div class="line"></div><div class="line"><span class="comment">// 匹配所有以"at"结尾的3个字符的组合，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</div></pre></td></tr></table></figure>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( [ &#123; \ ^ $ | ) ? * + . ] &#125;</div></pre></td></tr></table></figure>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。下面给出几个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配第一个"bat"或"cat"，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</div><div class="line"></div><div class="line"><span class="comment">// 匹配第一个" [bc]at"，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</div><div class="line"></div><div class="line"><span class="comment">// 匹配所有以"at"结尾的3个字符的组合，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</div><div class="line"></div><div class="line"><span class="comment">// 匹配所有".at"，不区分大小写</span></div><div class="line"><span class="keyword">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</div></pre></td></tr></table></figure>
<h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a><code>RegExp</code> 实例属性</h2><p><code>RegExp</code> 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li><code>global</code>：布尔值，表示是否设置了 <code>g</code> 标志。</li>
<li><code>ignoreCase</code>：布尔值，表示是否设置了 <code>i</code> 标志。</li>
<li><code>lastIndex</code>：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li><code>multiline</code>：布尔值，表示是否设置了 <code>m</code> 标志。</li>
<li><code>source</code>：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li>
</ul>
<p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</div><div class="line"><span class="built_in">console</span>.log(pattern1.global);         <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.multiline);      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);      <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.source);         <span class="comment">// "\[bc\]at"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</div><div class="line"><span class="built_in">console</span>.log(pattern2.global);         <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.multiline);      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);      <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.source);         <span class="comment">// "\[bc\]at"</span></div></pre></td></tr></table></figure>
<p>我们注意到，尽管第一个模式使用的是字面量，第二个模式使用了 <code>RegExp</code> 构造函数，但它们的 <code>source</code> 属性是相同的。可见，<code>source</code> 属性保存的是规范形式的字符串，即字面量形式所用的字符串。</p>
<h2 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a><code>RegExp</code> 实例方法</h2><p><code>RegExp</code> 对象的主要方法是 <code>exec()</code>，该方法是专门为捕获组而设计的。<code>exec()</code> 接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 <code>null</code>。返回的数组虽然是 <code>Array</code> 的实例，但包含两个额外的属性：<code>index</code> 和 <code>input</code>。其中，<code>index</code> 表示匹配项在字符串中的位置，而 <code>input</code> 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> matches = pattern.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches.index);     <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(matches.input);     <span class="comment">// "mom and dad and baby"</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);        <span class="comment">// "mom and dad and baby"</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);        <span class="comment">// " and dad and baby"</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);        <span class="comment">// " and baby"</span></div></pre></td></tr></table></figure>
<p>这个例子中的模式包含两个捕获组。最内部的捕获组匹配 <code>&quot;and baby&quot;</code>，而包含它的捕获组匹配 <code>&quot;and dad&quot;</code> 或者 <code>&quot;and dad and baby&quot;</code>。当把字符串传入 <code>exec()</code> 方法中之后，发现了一个匹配项。因为整个字符串本身与模式匹配，所以返回的数组 <code>matchs</code> 的 <code>index</code> 属性值为 <code>0</code>。数组中的第一项是匹配的整个字符串，第二项包含与第一个捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。</p>
<p>对于 <code>exec()</code> 方法而言，即使在模式中设置了全局标志 <code>g</code>，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 <code>exec()</code> 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 <code>exec()</code> 则都会在字符串中继续查找新匹配项，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</div><div class="line"></div><div class="line"><span class="comment">// 非全局模式，第一次匹配</span></div><div class="line"><span class="keyword">var</span> matches = pattern1.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches.index);        <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="comment">// 非全局模式，第二次匹配</span></div><div class="line">matches = pattern1.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches.index);        <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</div><div class="line"></div><div class="line"><span class="comment">// 全局模式，第一次匹配</span></div><div class="line"><span class="keyword">var</span> matches = pattern2.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches.index);        <span class="comment">// 0</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="comment">// 全局模式，第二次匹配</span></div><div class="line">matches = pattern2.exec(text);</div><div class="line"><span class="built_in">console</span>.log(matches.index);        <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);           <span class="comment">// bat</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">// 8</span></div></pre></td></tr></table></figure>
<p>这个例子中的第一个模式 <code>pattern1</code> 不是全局模式，因此每次调用 <code>exec()</code> 返回的都是第一个匹配项 <code>&quot;cat&quot;</code>。而第二个模式 <code>pattern2</code> 是全局模式，因此每次调用 <code>exec()</code> 都会返回字符串中的下一个匹配项，直至搜索到字符串末尾为止。此外，还应该注意模式的 <code>lastIndex</code> 属性的变化情况。在全局匹配模式下，<code>lastIndex</code> 的值在每次调用 <code>exec()</code> 后都会增加，而在非全局模式下则始终保持不变。</p>
<blockquote>
<p>IE 的 JavaScript 实现在 <code>lastIndex</code> 属性上存在偏差，即使在非全局模式下，<code>lastIndex</code> 属性每次也会变化。</p>
</blockquote>
<p>正则表达式的第二个方法是 <code>test()</code>，它接受一个字符串参数。在模式与该参数匹配的情况下返回 <code>true</code>；否则，返回 <code>false</code>。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，<code>test()</code> 方法经常被用在 <code>if</code> 语句中，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"The pattern was matched."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们使用正则表达式来测试了一个数字序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为我们只想知道输入是不是有效，至于它为什么无效就无关紧要了。</p>
<p><code>RegExp</code> 实例继承的 <code>toLocaleString()</code> 和 <code>toString()</code> 方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"gi"</span>);</div><div class="line"><span class="built_in">console</span>.log(pattern.toString());             <span class="comment">// /\[bc\]at/gi</span></div><div class="line"><span class="built_in">console</span>.log(pattern.toLocaleString());       <span class="comment">// /\[bc\]at/gi</span></div></pre></td></tr></table></figure>
<p>即使上例中的模式是通过调用 <code>RegExp</code> 构造函数创建的，但 <code>toLocaleString()</code> 和 <code>toString()</code> 方法仍然会像它是以字面量形式创建的一样显示其字符串表示。</p>
<h2 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a><code>RegExp</code> 构造函数属性</h2><p><code>RegExp</code> 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>input | $_ | 最近一次要匹配的字符串。Opera未实现此属性。<br>lastMatch | $&amp; | 最近一次的匹配项。Opera未实现此属性。<br>lastParen | $+ | 最近一次匹配的捕获组。Opera未实现此属性。<br>leftContext | $` | input字符串中lastMatch之前的文本。<br>multiline | $* | 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性。<br>rightContext | $’ | Input字符串中lastMatch之后的文本。</p>
<p>使用这些属性可以从 <code>exec()</code> 或 <code>test()</code> 执行的操作中提取出更具体的信息。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 注意：Internet Explorer 不支持 multiline 属性</div><div class="line"> * Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);          <span class="comment">// this has been a short summer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);    <span class="comment">// this has been a</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext);   <span class="comment">// summer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);      <span class="comment">// short</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastParen);      <span class="comment">// s</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.multiline);      <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如前所述，例子使用的长属性名都可以用相应的短属性名来代替。只不过，由于这些短属性名大都不是有效的 JavaScript 标识符，因此必须通过方括号语法来访问它们，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 注意：Internet Explorer 不支持 multiline 属性</div><div class="line"> * Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$_);      <span class="comment">// this has been a short summer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$`"</span>]);   <span class="comment">// this has been a</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$'"</span>]);   <span class="comment">// summer</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$&amp;"</span>]);   <span class="comment">// short</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$+"</span>]);   <span class="comment">// s</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>[<span class="string">"$*"</span>]);   <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是 <code>RegExp.$1</code>、<code>RegExp.$2</code>…<code>RegExp.$9</code>，分别用于存储第一、第二…第九个匹配的捕获组。在调用 <code>exec()</code> 或 <code>test()</code> 方法时，这些属性会被自动填充。然后，我们就可以像下面这样来使用它们。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (pattern.test(text))&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);  <span class="comment">// sh</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);  <span class="comment">// t</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个包含两个捕获组的模式，并用该模式测试了一个字符串。即使 <code>test()</code> 方法只返回一个布尔值，但 <code>RegExp</code> 构造函数的属性 <code>$1</code> 和 <code>$2</code> 也会被匹配相应捕获组的字符串自动填充。</p>
<h2 id="模式的局限性"><a href="#模式的局限性" class="headerlink" title="模式的局限性"></a>模式的局限性</h2><p>尽管 JavaScript 中的正则表达式功能还是比较完备的，但仍然缺少某些语言（特别是 Perl）所支持的高级正则表达式特性。下面列出了 JavaScript 正则表达式所不支持的特性。</p>
<ul>
<li>匹配字符串开始和结尾的\A和\Z锚</li>
<li>向后查找（lookbehind）</li>
<li>并集和交集类</li>
<li>原子组（atomic grouping）</li>
<li>Unicode支持（单个字符除外，如\uFFFF）</li>
<li>命名的捕获组</li>
<li>s（single，单行）和x（free-spacing，无间隔）匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul>
<p>即使存在这些限制，JavaScript 正则表达式仍然是非常强大的，能够帮我们完成绝大多数模式匹配任务。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>按要求完成下列常用的正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一：数字</span></div><div class="line"><span class="keyword">var</span> pattern1 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.test(<span class="string">'123'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern1.test(<span class="string">'abc'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二：3位的数字</span></div><div class="line"><span class="keyword">var</span> pattern2 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.test(<span class="string">'123'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern2.test(<span class="string">'1234'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三：至少3位的数字</span></div><div class="line"><span class="keyword">var</span> pattern3 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern3.test(<span class="string">'1234'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern3.test(<span class="string">'12'</span>));   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战四：3-5位的数字</span></div><div class="line"><span class="keyword">var</span> pattern4 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern4.test(<span class="string">'1234'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern4.test(<span class="string">'1'</span>));    <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战五：由26个英文字母组成的字符串</span></div><div class="line"><span class="keyword">var</span> pattern5 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern5.test(<span class="string">'abc'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern5.test(<span class="string">'1abc'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战六：由数字和26个英文字母组成的字符串</span></div><div class="line"><span class="keyword">var</span> pattern6 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern6.test(<span class="string">'1abc'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern6.test(<span class="string">'_abc'</span>));  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战七：日期格式：年-月-日</span></div><div class="line"><span class="keyword">var</span> pattern7 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern7.test(<span class="string">'2016-08-20'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern7.test(<span class="string">'2016/08/20'</span>));  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战八：时间格式：小时:分钟, 24小时制</span></div><div class="line"><span class="keyword">var</span> pattern8 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern8.test(<span class="string">'13:45'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern8.test(<span class="string">'13点45'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战九：中国大陆身份证号，15位或18位</span></div><div class="line"><span class="keyword">var</span> pattern9 = <span class="literal">null</span>;  <span class="comment">// 补全该正则表达式</span></div><div class="line"><span class="built_in">console</span>.log(pattern9.test(<span class="string">'4223222199901090033'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(pattern9.test(<span class="string">'asdfasdfasfasdf1234'</span>));  <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于本课程的核心是 JavaScript，所以本文着重讲解了「正则表达式」在 JavaScript 中的用法，并未深入「正则表达式」的具体细节。如果您尚不了解「正则表达式」，强烈推荐您先学习 &lt;strong&gt;正则表达式30分钟入门教程 &lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;http://deerchao.net/tutorials/regex/regex.htm&lt;/a&gt;&lt;/strong&gt; 之后，再进行本课程的学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正则表达式（regular expression）是一个描述字符模式的对象，使用正则表达式可以进行强大的模式匹配和文本检索与替换功能。JavaScript 的正则表达式语法是 Perl5 的正则表达式语法的大型子集，所以对于有 Perl 编程经验的程序员来说，学习 JavaScript 中的正则表达式是小菜一碟。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式的定义&quot;&gt;&lt;a href=&quot;#正则表达式的定义&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的定义&quot;&gt;&lt;/a&gt;正则表达式的定义&lt;/h2&gt;&lt;p&gt;JavaScript 中的正则表达式用 &lt;code&gt;RegExp&lt;/code&gt; 对象表示，可以使用 &lt;code&gt;RegExp()&lt;/code&gt; 构造函数来创建 &lt;code&gt;RegExp&lt;/code&gt; 对象，不过 &lt;code&gt;RegExp&lt;/code&gt; 对象更多是通过字面量的语法来创建，使用下面类似 Perl 的语法，就可以创建一个正则表达式。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 推荐写法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expression = &lt;span class=&quot;regexp&quot;&gt;/ pattern /&lt;/span&gt; flags ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 不推荐写法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; expression = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;RegExp&lt;/span&gt;(pattern, flags);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之函数</title>
    <link href="http://shisb.com/2016/10/12/javascript-lesson-1.9-FunctionObjects/"/>
    <id>http://shisb.com/2016/10/12/javascript-lesson-1.9-FunctionObjects/</id>
    <published>2016-10-12T14:00:00.000Z</published>
    <updated>2016-10-12T13:50:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数是一段代码，它只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>在 JavaScript 中，函数实际上是对象，每个函数都是 <code>Function</code> 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：函数声明（推荐写法）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写法二：函数表达式（推荐写法）</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三：Function 构造函数（不推荐写法）</span></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</div></pre></td></tr></table></figure>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>));        <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherSum = sum;</div><div class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div><div class="line"></div><div class="line">sum = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<a id="more"></a> 
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);    <span class="comment">// 300</span></div></pre></td></tr></table></figure>
<p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);    <span class="comment">// 300</span></div></pre></td></tr></table></figure>
<p>通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量 <code>addSomeNumber</code>。</p>
<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// Uncaught TypeError: sum is not a function</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);   <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</div><div class="line"><span class="built_in">console</span>.log(result2);   <span class="comment">// "Hello, Nicholas"</span></div></pre></td></tr></table></figure>
<p>这里的 <code>callSomeFunction()</code> 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给 <code>callSomeFunction()</code> 的是 <code>add10</code> 和 <code>getGreeting</code>，而不是执行它们之后的结果。</p>
<p>当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 <code>sort()</code> 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个 <code>return</code> 操作符。在内部函数接收到 <code>propertyName</code> 参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Nicholas</span></div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Zachary</span></div></pre></td></tr></table></figure>
<p>这里，我们创建了一个包含两个对象的数组 <code>data</code>。其中，每个对象都包含一个 <code>name</code> 属性和一个 <code>age</code> 属性。在默认情况下，<code>sort()</code> 方法会调用每个对象的 <code>toString()</code> 方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用 <code>createComparisonFunction(&quot;name&quot;)</code> 方法创建了一个比较函数，以便按照每个对象的 <code>name</code> 属性值进行排序。而结果排在前面的第一项是 <code>name</code> 为 <code>&quot;Nicholas&quot;</code>，<code>age</code> 是 <code>29</code> 的对象。然后，我们又使用了 <code>createComparisonFunction(&quot;age&quot;)</code> 返回的比较函数，这次是按照对象的age属性排序。得到的结果是 <code>name</code> 值为 <code>&quot;Zachary&quot;</code>，<code>age</code> 值是 <code>28</code> 的对象排在了第一位。</p>
<h2 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h2><p>在函数内部，有两个特殊的对象：<code>arguments</code> 和 <code>this</code>。其中，<code>arguments</code> 是一个类数组对象，包含着传入函数中的所有参数。虽然 <code>arguments</code> 的主要用途是保存函数参数，但这个对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数。请看下面这个非常经典的阶乘函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个重写后的 <code>factorial()</code> 函数的函数体内，没有再引用函数名 <code>factorial</code>。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(trueFactorial(<span class="number">5</span>));  <span class="comment">// 120</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));      <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>在此，变量 <code>trueFactorial</code> 获得了 <code>factorial</code> 的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回 <code>0</code> 的函数赋值给 <code>factorial</code> 变量。如果像原来的 <code>factorial()</code> 那样不使用 <code>arguments.callee</code>，调用 <code>trueFactorial()</code> 就会返回 <code>0</code>。可是，在解除了函数体内的代码与函数名的耦合状态之后，<code>trueFactorial()</code> 仍然能够正常地计算阶乘；至于 <code>factorial()</code>，它现在只是一个返回 <code>0</code> 的函数。</p>
<p>函数内部的另一个特殊对象是 <code>this</code>，其行为与 Java 和 C# 中的 <code>this</code> 大致类似。换句话说，<code>this</code> 引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，<code>this</code> 对象引用的就是 <code>window</code>）。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor();     <span class="comment">// "red"</span></div><div class="line"></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();   <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p>上面这个函数 <code>sayColor()</code> 是在全局作用域中定义的，它引用了 <code>this</code> 对象。由于在调用函数之前，<code>this</code> 的值并不确定，因此 <code>this</code> 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 <code>sayColor()</code> 时，<code>this</code> 引用的是全局对象 <code>window</code>；换句话说，对 <code>this.color</code> 求值会转换成对 <code>window.color</code> 求值，于是结果就返回了 <code>&quot;red&quot;</code>。而当把这个函数赋给对象 <code>o</code> 并调用 <code>o.sayColor()</code> 时，<code>this</code> 引用的是对象 <code>o</code>，因此对 <code>this.color</code> 求值会转换成对 <code>o.color</code> 求值，结果就返回了 <code>&quot;blue&quot;</code>。</p>
<p>请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 <code>sayColor()</code> 函数与 <code>o.sayColor()</code> 指向的仍然是同一个函数。</p>
<p>ECMAScript 5也规范化了另一个函数对象的属性 <code>caller</code>。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为 <code>null</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</div><div class="line">&#125; </div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure>
<p>以上代码会导致警告框中显示 <code>outer()</code> 函数的源代码。因为 <code>outer()</code> 调用了 <code>inter()</code>，所以 <code>arguments.callee.caller</code> 就指向 <code>outer()</code>。</p>
<p>在严格模式下，访问 <code>arguments.callee</code>属性，或为函数的 <code>caller</code> 属性赋值，都会导致错误。</p>
<h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><p>JavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：<code>length</code> 和 <code>prototype</code>。其中，<code>length</code> 属性表示函数希望接收的命名参数的个数，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sayName.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(sum.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(sayHi.length);        <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>对于 JavaScript 中的引用类型而言，<code>prototype</code> 是保存它们所有实例方法的真正所在。换句话说，诸如 <code>toString()</code> 和 <code>valueOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，<code>prototype</code> 属性的作用是极为重要的。在 ECMAScript 5中，<code>prototype</code> 属性是不可枚举的，因此使用 <code>for-in</code> 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：<code>apply()</code> 和 <code>call()</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 <code>this</code> 对象的值。首先，<code>apply()</code> 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 <code>Array</code> 的实例，也可以是 <code>arguments</code> 对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);  <span class="comment">// 传入 arguments 对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);  <span class="comment">// 传入数组</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div><div class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>callSum1()</code> 在执行 <code>sum()</code> 函数时传入了 <code>this</code>（因为是在全局作用域中调用的，所以传入的就是 <code>window</code> 对象）和 <code>arguments</code> 对象。而 <code>callSum2</code> 同样也调用了 <code>sum()</code> 函数，但它传入的则是 <code>this</code> 和一个参数数组。这两个函数都会正常执行并返回正确的结果。</p>
<p><code>call()</code> 方法与 <code>apply()</code> 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 <code>call()</code> 方法而言，第一个参数是 <code>this</code> 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 <code>call()</code> 方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>在使用 <code>call()</code> 方法的情况下，<code>callSum()</code> 必须明确地传入每一个参数。结果与使用 <code>apply()</code> 没有什么不同。至于是使用 <code>apply()</code> 还是 <code>call()</code>，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入 <code>arguments</code> 对象，或者包含函数中先接收到的也是一个数组，那么使用 <code>apply()</code> 肯定更方便；否则，选择 <code>call()</code> 可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）<br>事实上，传递参数并非 <code>apply()</code> 和 <code>call()</code> 真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor();                <span class="comment">// red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>);       <span class="comment">// red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>);     <span class="comment">// red</span></div><div class="line">sayColor.call(o);          <span class="comment">// blue</span></div></pre></td></tr></table></figure>
<p>这个例子是在前面说明 <code>this</code> 对象的示例基础上修改而成的。这一次，<code>sayColor()</code> 也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示 <code>&quot;red&quot;</code>，因为对 <code>this.color</code> 的求值会转换成对 <code>window.color</code> 的求值。而 <code>sayColor.call(this)</code> 和 <code>sayColor.call(window)</code>，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示 <code>&quot;red&quot;</code>。但是，当运行 <code>sayColor.call(o)</code> 时，函数的执行环境就不一样了，因为此时函数体内的 <code>this</code> 对象指向了 <code>o</code>，于是结果显示的是 <code>&quot;blue&quot;</code>。</p>
<p>使用 <code>call()</code> 或 <code>apply()</code> 来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将 <code>sayColor()</code> 函数放到了对象 <code>o</code> 中，然后再通过 <code>o</code> 来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一，合并任意个数的字符串</span></div><div class="line"><span class="keyword">var</span> concat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(concat(<span class="string">'st'</span>,<span class="string">'on'</span>,<span class="string">'e'</span>));  <span class="comment">// stone</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二，输出指定位置的斐波那契数列</span></div><div class="line"><span class="keyword">var</span> fioacciSequece = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fioacciSequece(<span class="number">12</span>));  <span class="comment">// 0、1、1、2、3、5、8、13、21、34、55、89</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三，三维数组或 n 维数组去重，使用 arguments 重写</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">5</span>],<span class="number">3</span>,<span class="number">5</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">2</span>],<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">// [2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数是一段代码，它只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。&lt;/p&gt;
&lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h2&gt;&lt;p&gt;在 JavaScript 中，函数实际上是对象，每个函数都是 &lt;code&gt;Function&lt;/code&gt; 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写法一：函数声明（推荐写法）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写法二：函数表达式（推荐写法）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 写法三：Function 构造函数（不推荐写法）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sum = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;num1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;num2&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;return num1 + num2&quot;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(sum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;// 20&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherSum = sum;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(anotherSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 20&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sum = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(anotherSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)); &lt;span class=&quot;comment&quot;&gt;// 20&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之对象</title>
    <link href="http://shisb.com/2016/10/07/javascript-lesson-1.8-ArrayObjects/"/>
    <id>http://shisb.com/2016/10/07/javascript-lesson-1.8-ArrayObjects/</id>
    <published>2016-10-07T15:00:00.000Z</published>
    <updated>2016-10-07T15:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。</p>
<p>JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。</p>
<p>JavaScript数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。</p>
<p>JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引要大。</p>
<p>JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p>
<a id="more"></a> 
<p>数组继承自 <code>Array.prototype</code> 中的属性，它定义了一套丰富的数组操作方法。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>可以使用数组字面量和 <code>new</code> 关键字来创建数组。</p>
<h3 id="使用数组字面量创建数组（推荐）"><a href="#使用数组字面量创建数组（推荐）" class="headerlink" title="使用数组字面量创建数组（推荐）"></a>使用数组字面量创建数组（推荐）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty = [];                 <span class="comment">// 没有元素的数组</span></div><div class="line"><span class="keyword">var</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>];  <span class="comment">// 有5个数值的数组</span></div><div class="line"><span class="keyword">var</span> misc = [<span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">"a"</span>];    <span class="comment">// 3个不同类型的元素</span></div><div class="line"></div><div class="line"><span class="comment">// 数组直接量中的值不一定要是常量，可以是任意的表达式</span></div><div class="line"><span class="keyword">var</span> base = <span class="number">1024</span>;</div><div class="line"><span class="keyword">var</span> table = [base, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">// 也可以包含对象直接量或其他数组直接量</span></div><div class="line"><span class="keyword">var</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">3</span>, <span class="attr">y</span>:<span class="number">4</span>&#125;]];</div></pre></td></tr></table></figure>
<p>注意，不要忽略数组字面量的最后一个元素，仅以逗号结尾。下面几个案例，在不同的浏览器下，可能会被识别成2个元素，也有可能识别成3个元素，而造成程序bug。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nums = [,,,];               <span class="comment">// 不好的写法</span></div><div class="line"><span class="keyword">var</span> names = [<span class="string">"stone"</span>,,];        <span class="comment">// 不好的写法</span></div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"green"</span>,];  <span class="comment">// 不好的写法</span></div></pre></td></tr></table></figure>
<h3 id="使用-new-关键字创建数组"><a href="#使用-new-关键字创建数组" class="headerlink" title="使用 new 关键字创建数组"></a>使用 <code>new</code> 关键字创建数组</h3><p>使用 <code>new</code> 关键字调用构造函数 <code>Array()</code> 是创建数组的另一种方法，可以用三种方式调用构造函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用时没有参数</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line"><span class="comment">// 调用时有一个数值参数，它指定长度</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); </div><div class="line"></div><div class="line"><span class="comment">// 显式指定多个数组元素或者数组的一个非数值元素</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">"testing"</span>);</div></pre></td></tr></table></figure>
<h2 id="数组元素的读和写"><a href="#数组元素的读和写" class="headerlink" title="数组元素的读和写"></a>数组元素的读和写</h2><p>使用 <code>[]</code> 操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="string">"world"</span>];     <span class="comment">// 从一个元素的数组开始</span></div><div class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>];      <span class="comment">// 读第0个元素</span></div><div class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;           <span class="comment">// 写第1个元素</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">2</span>; </div><div class="line">a[i] = <span class="number">3</span>;              <span class="comment">// 写第2个元素</span></div><div class="line">a[i + <span class="number">1</span>] = <span class="string">"hello"</span>;    <span class="comment">// 写第3个元素</span></div><div class="line">a[a[i]] = a[<span class="number">0</span>];        <span class="comment">// 读第0个和第2个元素，写第3个元素</span></div></pre></td></tr></table></figure>
<p>请记住，数组是对象的特殊形式，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的length属性值。</p>
<p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a[<span class="number">-1.23</span>] = <span class="literal">true</span>;  <span class="comment">// 这将创建一个名为"-1.23"的属性</span></div><div class="line">a[<span class="string">"1000"</span>] = <span class="number">0</span>;    <span class="comment">// 这是数组的第1001个元素</span></div><div class="line">a[<span class="number">1.000</span>]          <span class="comment">// 和 a[1] 相等</span></div></pre></td></tr></table></figure>
<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有「越界」错误的概念。当试图查询任何对象中不存在的属性时，不会报错，只会得到 <code>undefined</code> 值。</p>
<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的 <code>length</code> 属性值代表数组中元素的个数。如果数组是稀疏的，<code>length</code> 属性值大于元素的个数。可以用 <code>Array()</code> 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);   <span class="comment">// 数组没有元素，但是 a.length = 5</span></div><div class="line">a = [];             <span class="comment">// 创建一个空数组，a.length = 0</span></div><div class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;        <span class="comment">// 添加一个元素，a.length 被自动更新为1001</span></div></pre></td></tr></table></figure>
<p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p>
<p>需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如 <code>[1,,3]</code> ），这时所得到的数组也是稀疏数组，省略掉的值是不存在的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a1 = [,<span class="string">'1'</span>,<span class="string">'2'</span>];    <span class="comment">// 此数组长度是3 </span></div><div class="line"><span class="keyword">var</span> a2 = [<span class="literal">undefined</span>];   <span class="comment">// 此数组包含一个值为 undefined 的元素 </span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> a1);   <span class="comment">// false，a1 在索引0处没有元素</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">0</span> <span class="keyword">in</span> a2);   <span class="comment">// true，a2 在索引0处有一个值为 undefined 的元素</span></div></pre></td></tr></table></figure>
<p>了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 <code>undefined</code> 值。</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>每个数组有一个 <code>length</code> 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，<code>length</code> 属性值代表数组中元素的个数。其值比数组中最大的索引大1。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[].length             <span class="comment">// 0，数组没有元素</span></div><div class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>].length  <span class="comment">// 3，最大的索引为2，length 为3</span></div></pre></td></tr></table></figure>
<p>当数组是稀疏的时，<code>length</code> 属性值大于元素的个数。而且关于此我们可以说的一切也就是数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。</p>
<ul>
<li>第一个如同上面的描述：如果为一个数组元素赋值，它的索引 <code>i</code> 大于或等于现有数组的长度时，<code>length</code> 属性的值将设置为 <code>i+1</code>。</li>
<li>第二个特殊的行为就是设置 <code>length</code> 属性为一个小于当前长度的非负整数 <code>n</code> 时，当前数组中那些索引值大于或等于 <code>n</code> 的元素将从中删除。例如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];     <span class="comment">// 从5个元素的数组开始</span></div><div class="line">a.length = <span class="number">3</span>;        <span class="comment">// 现在 a 为[1,2,3]</span></div><div class="line">a.length = <span class="number">0</span>;        <span class="comment">// 删除所有的元素。a 为[ ]</span></div><div class="line">a.length = <span class="number">5</span>;        <span class="comment">// 长度为5，但是没有元素，就像 new Array(5)</span></div></pre></td></tr></table></figure>
<p>还可以将数组的 <code>length</code> 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。</p>
<p>在 ECMAScript 5中，可以用 <code>Object.defineProperty()</code> 让数组的 <code>length</code> 属性变成只读的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];                                            <span class="comment">// 从3个元素的数组开始</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">"length"</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);  <span class="comment">// 让 length 属性只读</span></div><div class="line">a.length = <span class="number">0</span>;                                           <span class="comment">// a 不会改变</span></div></pre></td></tr></table></figure>
<h2 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h2><p>我们已经见过添加数组元素最简单的方法，为新索引赋值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = []           <span class="comment">// 开始是一个空数组</span></div><div class="line">a[<span class="number">0</span>] = <span class="string">"zero"</span>;   <span class="comment">// 然后向其中添加元素</span></div><div class="line">a[<span class="number">1</span>] = <span class="string">"one"</span>;</div></pre></td></tr></table></figure>
<p>也可以使用 <code>push()</code> 方法在数组末尾增加一个或多个元素。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = [];                 <span class="comment">// 开始是一个空数组</span></div><div class="line">a.push(<span class="string">"zero"</span>);         <span class="comment">// 在末尾添加一个元素。a = ["zero"]</span></div><div class="line">a.push(<span class="string">"one"</span>, <span class="string">"two"</span>);   <span class="comment">// 再添加两个元素。a = ["zero", "one", "two"]</span></div></pre></td></tr></table></figure>
<p>可以像删除对象属性一样使用 <code>delete</code> 运算符来删除数组元素。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </div><div class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];   <span class="comment">// a在索引1的位置不再有元素</span></div><div class="line"><span class="number">1</span> <span class="keyword">in</span> a         <span class="comment">// =&gt; false: 数组索引1并未在数组中定义</span></div><div class="line">a.length       <span class="comment">// =&gt; 3: delete操作并不影响数组长度</span></div></pre></td></tr></table></figure>
<p>注意，对一个数组元素使用 <code>delete</code> 不会修改数组的 <code>length</code> 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p>
<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p>使用 <code>for</code> 循环是遍历数组元素最常见的方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(o);   <span class="comment">// 获得 o 对象属性名组成的数组</span></div><div class="line"><span class="keyword">var</span> values = []              <span class="comment">// 在数组中存储匹配属性的值</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;  <span class="comment">// 对于数组中每个索引</span></div><div class="line">    <span class="keyword">var</span> key = keys[i];                  <span class="comment">// 获得索引处的键值</span></div><div class="line">    values[i] = o[key];                 <span class="comment">// 在 values 数组中保存属性值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</div><div class="line">   <span class="comment">// 循环体仍然不变</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!a[i]) <span class="keyword">continue</span>;    <span class="comment">// 跳过 null、undefined 和不存在的元素</span></div><div class="line">    <span class="keyword">if</span> (!(i <span class="keyword">in</span> a)) <span class="keyword">continue</span> ;   <span class="comment">// 跳过不存在的元素</span></div><div class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;   <span class="comment">// 跳过 undefined 和不存在的元素</span></div><div class="line">    <span class="comment">// 循环体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以使用 <code>for-in</code> 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量，不存在的索引将不会遍历到。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> sparseArray) &#123;</div><div class="line">   <span class="keyword">var</span> value = sparseArray[index];</div><div class="line">   <span class="comment">// 此处可以使用索引和值做一些事情</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但由于 <code>for-in</code> 循环能够枚举继承的属性名，如添加到 <code>Array.prototype</code> 中的方法。基于这个原因，在数组上不应该使用 <code>for-in</code> 循环，除非使用额外的检测方法来过滤不想要的属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</div><div class="line">    <span class="comment">// 跳过继承的属性</span></div><div class="line">    <span class="keyword">if</span> (!a.hasOwnProperty(i)) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 跳过不是非负整数的 i</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">String</span>(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.abs(<span class="built_in">Number</span>(i)))) !== i) <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>JavaScript</code> 规范允许 <code>for-in</code> 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现，各个浏览器都不相同，如果算法依赖于遍历的顺序，那么最好不要使用 <code>for-in</code> 而用常规的 <code>for</code> 循环。</p>
<p>ECMAScript 5定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数。这些方法中最常用的就是 <code>forEach()</code> 方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];     <span class="comment">// 这是需要遍历的数组</span></div><div class="line"><span class="keyword">var</span> sumOfSquares = <span class="number">0</span>;       <span class="comment">// 要得到数据的平方和</span></div><div class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;  <span class="comment">// 把每个元素传递给此函数</span></div><div class="line">    sumOfSquares += x*x;    <span class="comment">// 平方相加</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(sumOfSquares);  <span class="comment">// 55，1 + 4 + 9 + 16 + 25</span></div></pre></td></tr></table></figure>
<h2 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h2><p>给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript 5中，可以使用 <code>Array.isArray()</code> 函数来做这件事情。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.isArray([])   <span class="comment">// true</span></div><div class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;)   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>但是，在 ECMAScript 5以前，要区分数组和非数组对象很困难。<code>typeof</code> 运算符对数组返回 <code>&quot;object&quot;</code>（并且对于除了函数以外的所有对象都是如此）。<code>instanceof</code> 操作符也只能用于简单的情形。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>     <span class="comment">// true</span></div><div class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Array</span>   <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>使用 <code>instanceof</code> 的问题是在 Web 浏览器中有可能有多个窗体存在。每个窗体都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 <code>instanceof</code> 操作符不能视为一个可靠的数组检测方法。</p>
<p>解决方案是检查对象的类属性，对数组而言该属性的值总是 <code>&quot;Array&quot;</code>，因此在 ECMAScript 3中 <code>isArray()</code> 函数的代码可以这样书写。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">"[object Array]"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>ECMAScript 3和 ECMAScript 5在 <code>Array.prototype</code> 中定义了一些很有用的操作数组的方法。</p>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>所有对象都具有 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法。其中，调用数组的 <code>toString()</code> 和 <code>valueOf()</code> 方法会返回相同的值，即由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。实际上，为了创建这个字符串会调用数组每一项的 <code>toString()</code> 方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// 创建一个包含3个字符串的数组</span></div><div class="line">alert(colors.toString()); <span class="comment">// red,blue,green</span></div><div class="line">alert(colors.valueOf());  <span class="comment">// red,blue,green</span></div><div class="line">alert(colors);            <span class="comment">// red,blue,green</span></div></pre></td></tr></table></figure>
<p>在这里，我们首先显式地调用了 <code>toString()</code> 和 <code>valueOf()</code> 方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。最后一行代码直接将数组传递给了 <code>alert()</code>。由于 <code>alert()</code>要接收字符串参数，所以它会在后台调用 <code>toString()</code> 方法，由此会得到与直接调用 <code>toString()</code> 方法相同的结果。</p>
<p>另外，<code>toLocaleString()</code> 方法经常也会返回与 <code>toString()</code> 和 <code>valueOf()</code> 方法相同的值，但也不总是如此。当调用数组的 <code>toLocaleString()</code> 方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 <code>toLocaleString()</code> 方法，而不是 <code>toString()</code> 方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">    <span class="attr">toLocaleString</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = &#123;</div><div class="line">    <span class="attr">toLocaleString</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Grigorios"</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toString</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Greg"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> people = [person1, person2];</div><div class="line">alert(people);                           <span class="comment">// Nicholas,Greg</span></div><div class="line">alert(people.toString());                <span class="comment">// Nicholas,Greg</span></div><div class="line">alert(people.toLocaleString());          <span class="comment">// Nikolaos,Grigorios</span></div></pre></td></tr></table></figure>
<p>数组继承的 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code>方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 <code>join()</code> 方法，则可以使用不同的分隔符来构建这个字符串。<code>join()</code> 方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">","</span>));    <span class="comment">// red,green,blue</span></div><div class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></div></pre></td></tr></table></figure>
<p> 如果数组中的某一项的值是 <code>null</code> 或者 <code>undefined</code>，那么该值在 <code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法返回的结果中以空字符串表示。</p>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。<code>push()</code> 方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而 <code>pop()</code> 方法则从数组末尾移除最后一项，减少数组的 <code>length</code> 值，然后返回移除的项。结合 <code>push()</code> 和 <code>pop()</code> 方法，就可以像栈一样使用数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [];                            <span class="comment">// 创建一个数组</span></div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);    <span class="comment">// 推入两项</span></div><div class="line"><span class="built_in">console</span>.log(count);                         <span class="comment">// 2，数组的长度</span></div><div class="line"></div><div class="line">count = colors.push(<span class="string">"black"</span>);               <span class="comment">// 推入另一项</span></div><div class="line"><span class="built_in">console</span>.log(count);                         <span class="comment">// 3，数组的长度</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> item = colors.pop();                    <span class="comment">// 取得最后一项</span></div><div class="line"><span class="built_in">console</span>.log(item);                          <span class="comment">// "black"</span></div><div class="line"><span class="built_in">console</span>.log(colors.length);                 <span class="comment">// 2，数组的长度</span></div></pre></td></tr></table></figure>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>队列是一种 FIFO（First-In-First-Out，先进先出）的数据结构，队列在列表的末端添加项，从列表的前端移除项。<code>shift()</code> 方法则从数组前端移除第一项，减少数组的 <code>length</code> 值，然后返回移除的项。结合 <code>push()</code> 和 <code>shift()</code> 方法，就可以像队列一样使用数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [];                            <span class="comment">// 创建一个数组</span></div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);    <span class="comment">// 推入两项</span></div><div class="line"><span class="built_in">console</span>.log(count);                         <span class="comment">// 2，数组的长度</span></div><div class="line"></div><div class="line">count = colors.push(<span class="string">"black"</span>);               <span class="comment">// 推入另一项</span></div><div class="line"><span class="built_in">console</span>.log(count);                         <span class="comment">// 3，数组的长度</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> item = colors.shift();                  <span class="comment">// 取得第一项</span></div><div class="line"><span class="built_in">console</span>.log(item);                          <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(colors.length);                 <span class="comment">// 2，数组的长度</span></div></pre></td></tr></table></figure>
<p>JavaScipt 还为数组提供了一个 <code>unshift()</code> 方法。顾名思义，<code>unshift()</code> 与 <code>shift()</code> 的用途相反，它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用 <code>unshift()</code> 和 <code>pop()</code> 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中有两个重排序的方法：<code>reverse()</code> 和 <code>sort()</code>。<code>reverse()</code> 方法可以反转数组元素的顺序。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">values.reverse();</div><div class="line"><span class="built_in">console</span>.log(values);  <span class="comment">// 5,4,3,2,1</span></div></pre></td></tr></table></figure>
<p><code>sort()</code> 方法可以按升序排列数组元素（即最小的值位于最前面，最大的值排在最后面）。<code>sort()</code> 方法在排序的过程中会调用每个数组元素的 <code>toString()</code>，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，<code>sort()</code> 方法比较的也是字符串，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line"><span class="built_in">console</span>.log(values);     <span class="comment">// 0,1,10,15,5</span></div></pre></td></tr></table></figure>
<p>这种排序方式在很多情况下都不是最佳方案，因此 <code>sort()</code> 方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面，以下就是一个简单的比较函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。它可以适用于大多数情况，只要将其作为参数传递给 <code>sort()</code> 方法即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">15</span>];</div><div class="line">values.sort(compare);</div><div class="line"><span class="built_in">console</span>.log(values);   <span class="comment">// 0,1,5,10,15</span></div></pre></td></tr></table></figure>
<p>对于数值类型或者其 <code>valueOf()</code> 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。</p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>JavaScript 为操作已经包含在数组中的元素提供了很多方法。其中，<code>concat()</code> 方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 <code>concat()</code> 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 <code>concat()</code> 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors);     <span class="comment">// red,green,blue</span></div><div class="line"><span class="built_in">console</span>.log(colors2);    <span class="comment">// red,green,blue,yellow,black,brown</span></div></pre></td></tr></table></figure>
<p>下一个方法是 <code>slice()</code>，它能够基于当前数组中的一或多个项创建一个新数组。<code>slice()</code> 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，<code>slice()</code> 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项。注意，<code>slice()</code> 方法不会影响原始数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</div><div class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors2);   <span class="comment">// green,blue,yellow,purple</span></div><div class="line"><span class="built_in">console</span>.log(colors3);   <span class="comment">// green,blue,yellow</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>slice()</code> 方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用 <code>slice(-2,-1)</code> 与调用 <code>slice(3,4)</code> 得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
</blockquote>
<p>下一个方法是 <code>splice()</code>，它的主要用途是向数组的中部插入元素，主要有以下3种使用方式。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定2个参数：起始位置和要删除元素的数量。例如，<code>splice(0,2)</code> 会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除元素的数量）和要插入的元素。如果要插入多个元素，可以再传入第四、第五，以至任意多个元素。例如，<code>splice(2,0,&quot;red&quot;,&quot;green&quot;)</code> 会从当前数组的位置2开始插入字符串 <code>&quot;red&quot;</code> 和 <code>&quot;green&quot;</code>。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除元素的数量和要插入的元素。插入的项数不必与删除的项数相等。例如，<code>splice (2,1,&quot;red&quot;,&quot;green&quot;)</code>会删除当前数组位置2的项，然后再从位置2开始插入字符串 <code>&quot;red&quot;</code> 和 <code>&quot;green&quot;</code>。</li>
</ul>
<p><code>splice()</code> 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3种使用 <code>splice()</code> 方法的方式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);       <span class="comment">// 删除第一项</span></div><div class="line"><span class="built_in">console</span>.log(colors);                    <span class="comment">// green,blue</span></div><div class="line"><span class="built_in">console</span>.log(removed);                   <span class="comment">// red，返回的数组中只包含一项</span></div><div class="line"></div><div class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>);  <span class="comment">// 从位置1开始插入两项</span></div><div class="line"><span class="built_in">console</span>.log(colors);                    <span class="comment">// green,yellow,orange,blue</span></div><div class="line"><span class="built_in">console</span>.log(removed);                   <span class="comment">// 返回的是一个空数组</span></div><div class="line"></div><div class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>);     <span class="comment">// 插入两项，删除一项</span></div><div class="line"><span class="built_in">console</span>.log(colors);                    <span class="comment">// green,red,purple,orange,blue</span></div><div class="line"><span class="built_in">console</span>.log(removed);                   <span class="comment">// yellow，返回的数组中只包含一项</span></div></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5为数组实例添加了两个位置方法：<code>indexOf()</code> 和 <code>lastIndexOf()</code>。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，<code>indexOf()</code> 方法从数组的开头（位置0）开始向后查找，<code>lastIndexOf()</code> 方法则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 <code>-1</code>。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用 <code>===</code> 一样）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="built_in">console</span>.log(numbers.indexOf(<span class="number">4</span>));          <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">4</span>));      <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>));       <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>));   <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</div><div class="line"><span class="keyword">var</span> people = [&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;];</div><div class="line"><span class="keyword">var</span> morePeople = [person];</div><div class="line"><span class="built_in">console</span>.log(people.indexOf(person));      <span class="comment">// -1</span></div><div class="line"><span class="built_in">console</span>.log(morePeople.indexOf(person));  <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回值。以下是这5个迭代方法的作用。</p>
<ul>
<li><code>every()</code>，对数组中的每一项运行给定函数，如果该函数对每一项都返回 <code>true</code> ，则返回 <code>true</code>。</li>
<li><code>filter()</code>，对数组中的每一项运行给定函数，返回该函数会返回 <code>true</code> 的项组成的数组。</li>
<li><code>forEach()</code>，对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()</code>，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>，对数组中的每一项运行给定函数，如果该函数对任一项返回 <code>true</code> ，则返回 <code>true</code>。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。在这些方法中，最相似的是 <code>every()</code> 和 <code>some()</code>，它们都用于查询数组中的项是否满足某个条件。对 <code>every()</code> 来说，传入的函数必须对每一项都返回 <code>true</code>，这个方法才返回 <code>true</code>；否则，它就返回 <code>false</code>。而 <code>some()</code>方法则是只要传入的函数对数组中的某一项返回 <code>true</code>，就会返回 <code>true</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>); </div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(everyResult);   <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(someResult);    <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>下面再看一看 <code>filter()</code> 函数，它利用指定的函数确定是否在返回的数组中包含的某一项。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(filterResult);  <span class="comment">// [3,4,5,4,3]</span></div></pre></td></tr></table></figure>
<p><code>map()</code> 也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。例如，可以给数组中的每一项乘以2，然后返回这些乘积组成的数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(mapResult);     <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></div></pre></td></tr></table></figure>
<p>最后一个方法是 <code>forEach()</code>，它只是对数组中的每一项运行传入的函数。这个方法没有返回值，本质上与使用 <code>for</code> 循环迭代数组一样。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</div><div class="line">    <span class="comment">//执行某些操作 </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>###　缩小方法</p>
<p>ECMAScript 5还新增了两个缩小数组的方法：<code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，<code>reduce()</code> 方法从数组的第一项开始，逐个遍历到最后。而 <code>reduceRight()</code> 则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值。传给 <code>reduce()</code> 和<code>reduceRight()</code> 的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<p>使用 <code>reduce()</code> 方法可以执行求数组中所有值之和的操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur; </div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>第一次执行回调函数，prev是1，cur是2。第二次，prev是3（1加2的结果），cur是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</p>
<p><code>reduceRight()</code> 的作用类似，只不过方向相反而已。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> prev + cur;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>使用 <code>reduce()</code> 还是 <code>reduceRight()</code>，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>完成下面3个数组去重方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一，一维数组</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">// [2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二，二维数组</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">3</span>,<span class="number">5</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">// [2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三，三维数组或 n 维数组</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">5</span>],<span class="number">3</span>,<span class="number">5</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">2</span>],<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">// [2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。&lt;/p&gt;
&lt;p&gt;JavaScript 数组是无类型的，数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组。&lt;/p&gt;
&lt;p&gt;JavaScript数组是动态的，根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。&lt;/p&gt;
&lt;p&gt;JavaScript 数组可能是稀疏的，数组元素的索引不一定要连续的，它们之间可以有空缺。每个JavaScript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引要大。&lt;/p&gt;
&lt;p&gt;JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>被「李笑来老师」拉黑之「JavaScript微博自动转发的脚本」</title>
    <link href="http://shisb.com/2016/10/02/javascript-weibo-forward-tool/"/>
    <id>http://shisb.com/2016/10/02/javascript-weibo-forward-tool/</id>
    <published>2016-10-02T04:00:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>故事的背景如下图，<a href="http://weibo.com/bylixiaolai" target="_blank" rel="external">李笑来</a> 老师于10月19日在 <a href="https://www.zhihu.com/lives/about" target="_blank" rel="external">知乎Live</a> 开设 <a href="https://www.zhihu.com/lives/763851343583547392" target="_blank" rel="external">一小时建立终生受用的阅读操作系统</a> 的讲座，他老人家看到大家伙报名踊跃，便在微博上发起了一个 <a href="http://weibo.com/1576218000/Eau3ZoPWd?type=comment" target="_blank" rel="external">猜数量赢取iPhone7</a> 的活动。</p>
<p><img src="http://qn.shisb.com/blog/javascript-weibo-forward-tool/1.jpg" alt=""></p>
<p>因为该活动注明了「不限猜的次数」，我便用 JavaScript 写一个自动转发的脚本，用机器代替手工转发，结果转发不到200次就被 <a href="http://weibo.com/bylixiaolai" target="_blank" rel="external">李笑来</a> 老师拉黑了，实在扫兴。与其独自郁闷，不如把技术细节分享给大家，祝大家能早日赢得 iPhone7。我的微博地址是：<a href="http://weibo.com/stone0090" target="_blank" rel="external">http://weibo.com/stone0090</a>，欢迎大家来围观。</p>
<a id="more"></a> 
<p>本以为花一两个小时就能搞定这个微博自动转发的脚本，结果中途不停的踩坑折腾了大半天。还好早早的被 <a href="http://weibo.com/bylixiaolai" target="_blank" rel="external">李笑来</a> 老师拉黑。不然用 .NET 重写工具，再接入 <a href="http://www.dama2.com" target="_blank" rel="external">打码兔</a>，还得再花我好几个小时。好不容易国庆长假休息一下，还不是想给媳妇换个 iPhone7，我就能用她的 iPhone6s，要不然真心不想花太多时间捣鼓这个。废话不多说了，进入正题：</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>JavaScript：如果不会 JavaScript，建议先学完 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">JavaScript 闯关记</a>，再继续看本文。</li>
<li>Chrome：开发调试 JavaScript 必备神器。</li>
<li>微博会员：据网上流言，普通用户如果转发过多会被封号，而会员则不会。</li>
</ul>
<h3 id="填坑过程"><a href="#填坑过程" class="headerlink" title="填坑过程"></a>填坑过程</h3><p>打开 Chrome 浏览器中，先登录自己的微博，再进入李笑来老师的微博首页 <a href="http://weibo.com/bylixiaolai" target="_blank" rel="external">http://weibo.com/bylixiaolai</a> 。</p>
<p><img src="http://qn.shisb.com/blog/javascript-weibo-forward-tool/3.jpg" alt=""></p>
<p>打开 Chrome 开发者工具（Mac 快捷键 <code>option</code> + <code>comand</code> + <code>j</code>，Window 快捷键 <code>ctrl</code> + <code>shift</code> + <code>i</code>），切换 tab 到 NetWork，并点击 clear，清除初始化时所加载的数据。</p>
<p><img src="http://qn.shisb.com/blog/javascript-weibo-forward-tool/2.jpg" alt=""></p>
<p>然后手动转发一次微博，获取到转发时所产生的请求。</p>
<p><img src="http://qn.shisb.com/blog/javascript-weibo-forward-tool/4.jpg" alt=""></p>
<p>利用上图红框中的关键数据，使用 JavaScript 模拟发送转发请求，具体代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 转发微博，并评论</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">forwardWeibo</span>(<span class="params">content, retcode</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">  formData.append(<span class="string">'pic_src'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'pic_id'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'appkey'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'mid'</span>, <span class="string">'4024988475919525'</span>);</div><div class="line">  formData.append(<span class="string">'style_type'</span>, <span class="string">'1'</span>);</div><div class="line">  formData.append(<span class="string">'mark'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'reason'</span>, content);</div><div class="line">  formData.append(<span class="string">'location'</span>, <span class="string">'page_100505_home'</span>);</div><div class="line">  formData.append(<span class="string">'pdetail'</span>, <span class="string">'1005051576218000'</span>);</div><div class="line">  formData.append(<span class="string">'module'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'page_module_id'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'refer_sort'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'is_comment_base'</span>, <span class="string">'1'</span>);</div><div class="line">  formData.append(<span class="string">'rank'</span>, <span class="string">'0'</span>);</div><div class="line">  formData.append(<span class="string">'rankid'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'_t'</span>, <span class="string">'0'</span>);</div><div class="line">  formData.append(<span class="string">'retcode'</span>, retcode || <span class="string">''</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  xhr.timeout = <span class="number">3000</span>;</div><div class="line">  xhr.responseType = <span class="string">"text"</span>;</div><div class="line">  xhr.open(<span class="string">'POST'</span>, <span class="string">'http://weibo.com/aj/v6/mblog/forward?ajwvr=6&amp;domain=100505&amp;__rnd='</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), <span class="literal">true</span>);</div><div class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span> || <span class="keyword">this</span>.status == <span class="number">304</span>) &#123;</div><div class="line">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText);</div><div class="line">      <span class="keyword">if</span> (data.code == <span class="string">"100000"</span>) &#123;</div><div class="line">        <span class="comment">// 转发微博成功</span></div><div class="line">        <span class="built_in">console</span>.log(content);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.code == <span class="string">"100027"</span>) &#123;</div><div class="line">        <span class="comment">// 转发微博失败，需要回答图片验证码的问题</span></div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 转发微博失败，其他原因</span></div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  xhr.send(formData);</div><div class="line">&#125;</div><div class="line"><span class="comment">//forwardWeibo('转发内容');</span></div><div class="line"><span class="comment">//forwardWeibo('转发内容',verified('答案'));</span></div><div class="line"></div><div class="line"><span class="comment">// 每5秒转发一次</span></div><div class="line"><span class="keyword">var</span> count = <span class="number">35000</span>;</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  forwardWeibo(count++);</div><div class="line">&#125;, <span class="number">5000</span>);</div></pre></td></tr></table></figure>
<p>打开 Chrome 开发者工具，切换 tab 到 Console，拷贝上面代码到 Console 中，按回车键即可以「5秒1次」的频率对李笑来老师的这条微博进行转发评论，如需停止请关闭该页面再重新打开。</p>
<p>然而仅过了2分钟，成功转发50多次之后，后面的转发全部失败。经检查发现，由于我转发频率过快，被微博官方暂时封号。回答一些简单的问题把账号解封，我把转发频率由「5秒1次」改为「10秒1次」，因为除我之外还有其他几个号也在用脚本刷，他们大概用「10秒1次」的频率，稳定的转发没有间断过，所以「10秒1次」应该是相对安全的。</p>
<p>我调整频率之后重新开始转发，但还是转发失败，手动操作后发现转发需要输入验证码，以前并没有这个环节，看来刚才的封号是有一些后遗症的。验证码我才不怕，专业的打码服务 <a href="http://www.dama2.com" target="_blank" rel="external">打码兔</a> 连12306的验证码都能轻松应付，识别这里的验证码就是小儿科。但接入 <a href="http://www.dama2.com" target="_blank" rel="external">打码兔</a> 的工作量有点大，我还是先找找看，有没有更简单的方法。</p>
<p>果然还真被我找到了，虽然转发的时候需要输入验证码，但评论的时候并不用，手动操作一把，评论并转发也能成功，便马上新增了一个评论的方法，具体代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 评论微博，并转发</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">commentWeibo</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">  formData.append(<span class="string">'act'</span>, <span class="string">'post'</span>);</div><div class="line">  formData.append(<span class="string">'mid'</span>, <span class="string">'4024988475919525'</span>);</div><div class="line">  formData.append(<span class="string">'uid'</span>, <span class="string">'1760390531'</span>);</div><div class="line">  formData.append(<span class="string">'forward'</span>, <span class="string">'1'</span>);</div><div class="line">  formData.append(<span class="string">'isroot'</span>, <span class="string">'0'</span>);</div><div class="line">  formData.append(<span class="string">'content'</span>, content);</div><div class="line">  formData.append(<span class="string">'location'</span>, <span class="string">'page_100505_home'</span>);</div><div class="line">  formData.append(<span class="string">'module'</span>, <span class="string">'scommlist'</span>);</div><div class="line">  formData.append(<span class="string">'group_source'</span>, <span class="string">''</span>);</div><div class="line">  formData.append(<span class="string">'tranandcomm'</span>, <span class="string">'1'</span>);</div><div class="line">  formData.append(<span class="string">'pdetail'</span>, <span class="string">'1005051576218000'</span>);</div><div class="line">  formData.append(<span class="string">'_t'</span>, <span class="string">'0'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  xhr.timeout = <span class="number">3000</span>;</div><div class="line">  xhr.responseType = <span class="string">"text"</span>;</div><div class="line">  xhr.open(<span class="string">'POST'</span>, <span class="string">'http://weibo.com/aj/v6/comment/add?ajwvr=6&amp;__rnd='</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(), <span class="literal">true</span>);</div><div class="line">  xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span> || <span class="keyword">this</span>.status == <span class="number">304</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.responseText.code == <span class="string">"100000"</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(content);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  xhr.send(formData);</div><div class="line">&#125;</div><div class="line"><span class="comment">//commentWeibo('评论内容');</span></div><div class="line"></div><div class="line"><span class="comment">// 每10秒评论一次</span></div><div class="line"><span class="keyword">var</span> count = <span class="number">35000</span>;</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  forwardWeibo(count++);</div><div class="line">&#125;, <span class="number">10000</span>);</div></pre></td></tr></table></figure>
<p>没高兴几分钟，又发现新的问题，评论成功10条，只有1条转发成功了，这完全是坑爹啊。看来只有接入 <a href="http://www.dama2.com" target="_blank" rel="external">打码兔</a>  才能彻底解决问题了，估计要花2、3个小时才能搞定，算了，先吃饭、洗澡再弄。</p>
<p>磨蹭了1、2个小时之后回来，发现微博转发输入验证码的限制已经被取消，但我仍心有余悸，把脚本的频率改为「30秒1次」让它慢慢的跑。然后，埋头研究  <a href="http://www.dama2.com" target="_blank" rel="external">打码兔</a> 的 API，注册相关开发者账号，充值测试费用。就在我刚准备写代码之际，脚本又失败了，而且，这次的报错跟以前都不一样，原来是我已经被 <strong>李笑来老师拉黑了</strong>，再也不能转发评论他老人家任何微博了。</p>
<p>本以为会刷几万条微博出来，没想到只刷了200条不到，这些微博就留作纪念不删了。下面是提前准备好的批量删微博的脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除微博</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteWeibo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> items = <span class="built_in">document</span>.querySelectorAll(<span class="string">".WB_feed_type"</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> items)&#123;</div><div class="line">    <span class="keyword">if</span>(items[i].getAttribute)&#123;</div><div class="line">      <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">      formData.append(<span class="string">'mid'</span>, items[i].getAttribute(<span class="string">"mid"</span>));</div><div class="line">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">      xhr.open(<span class="string">'POST'</span>, <span class="string">'http://weibo.com/aj/mblog/del?ajwvr=6'</span>, <span class="literal">false</span>);</div><div class="line">      xhr.send(formData);</div><div class="line">      <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">deleteWeibo();</div></pre></td></tr></table></figure>
<p>信念瞬间崩塌，思想得到解放，果断去抱着媳妇追 <a href="https://movie.douban.com/subject/3016187/" target="_blank" rel="external">权利的游戏</a>，啪啪啪，真是一个美好夜晚。</p>
<p>最后，祝大家国庆节快乐。如果还想听我聊技术（che dan），请关注微信公众号「劼哥舍」，老斯基带你飙车。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的背景如下图，&lt;a href=&quot;http://weibo.com/bylixiaolai&quot;&gt;李笑来&lt;/a&gt; 老师于10月19日在 &lt;a href=&quot;https://www.zhihu.com/lives/about&quot;&gt;知乎Live&lt;/a&gt; 开设 &lt;a href=&quot;https://www.zhihu.com/lives/763851343583547392&quot;&gt;一小时建立终生受用的阅读操作系统&lt;/a&gt; 的讲座，他老人家看到大家伙报名踊跃，便在微博上发起了一个 &lt;a href=&quot;http://weibo.com/1576218000/Eau3ZoPWd?type=comment&quot;&gt;猜数量赢取iPhone7&lt;/a&gt; 的活动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qn.shisb.com/blog/javascript-weibo-forward-tool/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为该活动注明了「不限猜的次数」，我便用 JavaScript 写一个自动转发的脚本，用机器代替手工转发，结果转发不到200次就被 &lt;a href=&quot;http://weibo.com/bylixiaolai&quot;&gt;李笑来&lt;/a&gt; 老师拉黑了，实在扫兴。与其独自郁闷，不如把技术细节分享给大家，祝大家能早日赢得 iPhone7。我的微博地址是：&lt;a href=&quot;http://weibo.com/stone0090&quot;&gt;http://weibo.com/stone0090&lt;/a&gt;，欢迎大家来围观。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>「前端开发者」如何把握住「微信小程序」这波红利？</title>
    <link href="http://shisb.com/2016/09/27/wechat-application-font-end/"/>
    <id>http://shisb.com/2016/09/27/wechat-application-font-end/</id>
    <published>2016-09-26T19:00:00.000Z</published>
    <updated>2017-08-30T14:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于前两周一直在老家处理重要事情，虽然朋友圈被「微信小程序」刷爆了，但并没有时间深入了解。</p>
<p>昨天回广州之后，第一件事情就是把「微信小程序」相关的文章、开发文档、设计规范全部看了一遍，基本上明白了「微信小程序」是怎么回事，我关注的公众号都很看好「微信小程序」的前景。</p>
<p>作为一个「前端开发者」，确实觉得「微信小程序」是个不错的机会，但从哪个方向投入到这股的热潮中呢？咨询了好几位公众号的作者，得到了以下回复：</p>
<ul>
<li>开发新的轮子。</li>
<li>赶快投入，开始做一些应用，</li>
<li>大家都去挖金子，你可以去边上卖水。</li>
<li>关注排名100开外的App，估计这些突破口比较大。</li>
</ul>
<p><img src="http://qn.shisb.com/blog/wechat-application-font-end/weixinxiaochengxu.jpg" alt=""></p>
<a id="more"></a>
<p>就在我写这篇文章的时候，「小道消息」正好推送了文章<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968702&amp;idx=1&amp;sn=1398cd09b54c5a84a746a0a5f8fc6845&amp;chksm=bd3836458a4fbf5302be668a9ed65933cf93edc21b854c109d4cc8d02e1f08788807165d6d39&amp;scene=0#rd" target="_blank" rel="external">如何把握「微信小程序」这一波红利？</a>，看来我的提问也引起了 Fenng 的思考，他的文章中说，有三批人可能会享受「微信小程序」红利的，分别是：</p>
<blockquote>
<p>第一批享受「微信小程序」红利的，我猜可能是做相关培训的人。一些做培训的团队，可以趁着这个时机，开一些类似「工作坊」之类的短期培训，对一些摸不到头绪的开发者，无疑是有好处的，口碑好的培训课程，值得参加。</p>
<p>第二批享受「微信小程序」红利的，是外包团队。预计到年底的时候会出现一些营销类的「小程序」，而有营销需求的，可能并不具备开发和传播能力。所以，外包团队一定有机会赚钱。</p>
<p>第三批享受「微信小程序」红利的，是具备一定能力的开发者，尤其是前端开发工程师，这是个会涨工资的新机会。小程序「框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架」，WXML 是微信自己定义的一套标记语言，WXSS 是微信定义的样式语言。你可以理解为微信开发环境的 XML 和 CSS，语法并不复杂，只需要用到熟练即可。我的一位律师朋友已经在学习文档调试程序了，这一点比我厉害多了。</p>
</blockquote>
<p>每一位公众号的作者都有自己独到的见解，特别是 Fenng 的文章既有深度又有广度。我将上述内容进行简单的整理，来回答标题的提问：「前端开发者」如何把握住「微信小程序」这波红利？</p>
<ol>
<li>迅速掌握「微信小程序」相关技术。</li>
<li>对一些摸不到头绪的开发者做短期培训。</li>
<li>对有营销需求的公司提供技术外包服务。</li>
<li>制造提高开发效率、简化开发流程的轮子。</li>
<li>开发非热门、低频、服务类应用，寻找突破口。</li>
</ol>
<p>如果大家还有什么好的想法，欢迎继续补充。祝每一位前端开发者都能在这波红利中获益。</p>
<hr>
<h4 id="谢谢给本文提供观点的「微信公众号」："><a href="#谢谢给本文提供观点的「微信公众号」：" class="headerlink" title="谢谢给本文提供观点的「微信公众号」："></a>谢谢给本文提供观点的「微信公众号」：</h4><p>小道消息<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_WebNotes_1.jpg" alt=""></p>
<p>槽边往事<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_bitsea_1.jpg" alt=""></p>
<p>待字闺中<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_daiziguizhongren_1.jpg" alt=""></p>
<p>MacTalk<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_sagacity-mac_1.jpg" alt=""></p>
<p>姜胡说<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_shuojianghu_1.jpg" alt=""></p>
<p>学习学习再学习<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_xiaolai-xuexi_1.jpg" alt=""></p>
<p>JavaScript<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_JavaScriptcn_1.jpg" alt=""></p>
<p>菜鸟教程<br><img src="http://qn.shisb.com/blog/wechat-application-font-end/qrcode_runoob_1.jpg" alt=""></p>
<hr>
<h4 id="「微信小程序」文章推荐："><a href="#「微信小程序」文章推荐：" class="headerlink" title="「微信小程序」文章推荐："></a>「微信小程序」文章推荐：</h4><p><a href="https://github.com/Notedown-cn/wxopen" target="_blank" rel="external">微信小程序官方文档</a> - GitHub</p>
<p><a href="https://github.com/Aufree/awesome-wechat-weapp" target="_blank" rel="external">微信小程序资源汇总整理</a> - GitHub</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIyMTE0MA==&amp;mid=2650968689&amp;idx=1&amp;sn=c27c74226fe4d500ff552abc46b62812&amp;chksm=bd38364a8a4fbf5ca2fd32caa15799a160e90295abc56a1b874d8ce14c85614b32a2cb846291&amp;scene=1&amp;srcid=0924XJYKWOip88uwaGx1P0cY#rd" target="_blank" rel="external">微信应用号来了</a> -  微信（小道消息）</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAzODU2MA==&amp;mid=2652780053&amp;idx=1&amp;sn=0b09f8aeef0b0fa53fd2b6398bd00795&amp;chksm=bd46fdda8a3174ccc9a4abeb15e00b37addb9f5c6e5a562f4df63435dda0334a897175fe2561&amp;scene=1&amp;srcid=0924Jfdn4Ude6PvsWOIIQjBk#rd" target="_blank" rel="external">作为大自然的微信</a> -  微信（槽边往事）</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE4NzM5MA==&amp;mid=2651782411&amp;idx=1&amp;sn=8b759fe00d5e21db239cc1a583b00037&amp;chksm=8cb3bc9abbc4358cf1531010bdebb73b5aabcef0b7d782086224c3e913558eb47f10d4fc6b6d&amp;scene=1&amp;srcid=0924Cemq8LC5cMQtVYBVdVuO#rd" target="_blank" rel="external">小程序来了，你准备好了吗？</a> -  微信（姜胡说）</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712679&amp;idx=1&amp;sn=d00033b16097ca890c10951f90b50c88&amp;chksm=bec0643489b7ed225417e8d68e5f125ccfaed7ba6e3c88e14acc3db0034c23be679d8f7728bd&amp;scene=1&amp;srcid=0924wjAswa2NkdCJd7WSOKap#rd" target="_blank" rel="external">微信小程序，仅仅是 Web App 么？</a> -  微信（MacTalk）</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNzI4MTMwMw==&amp;mid=2651630318&amp;idx=1&amp;sn=6dcbbf3b8c5f56a39a73a4ffdfc8b46a&amp;chksm=801ff296b7687b80e0eff50a15017f1232e838c3e0bc73554f639cae229765d1168c134673f9&amp;scene=1&amp;srcid=0924o86DBZfkcoBWRZrN8G7K#rd" target="_blank" rel="external">微信小程序是谁的“通往财富自由之路”？</a> - 微信（学习学习再学习）</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODIzNDQ3Mw==&amp;mid=2649966189&amp;idx=1&amp;sn=0dd7d677adff5455eee1bf09d53f9108&amp;chksm=beca366b89bdbf7d70abec27ce9d0172fda8c38328fae8f192512f5771f1dfcd78481bde9f29&amp;scene=1&amp;srcid=0924g0gvZiayg4i8h0KuLHQd#rd" target="_blank" rel="external">别扯了，微信应用号和百度直达号不是一路货色</a> - 微信（待字闺中）</p>
<p><a href="https://zhuanlan.zhihu.com/p/22565340" target="_blank" rel="external">关于微信小程序（应用号）的底层逻辑分析和拥抱建议</a> - 知乎（三节课）</p>
<p><a href="http://www.ifanr.com/721124" target="_blank" rel="external">微信小程序怎么开发？玩物志用一个上午上线了电商应用</a> - 爱范儿</p>
<p><a href="http://tech.qq.com/a/20160922/000527.htm" target="_blank" rel="external">应用号终于来了 它到底长什么样？看这篇就知道了</a> - 腾讯科技</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于前两周一直在老家处理重要事情，虽然朋友圈被「微信小程序」刷爆了，但并没有时间深入了解。&lt;/p&gt;
&lt;p&gt;昨天回广州之后，第一件事情就是把「微信小程序」相关的文章、开发文档、设计规范全部看了一遍，基本上明白了「微信小程序」是怎么回事，我关注的公众号都很看好「微信小程序」的前景。&lt;/p&gt;
&lt;p&gt;作为一个「前端开发者」，确实觉得「微信小程序」是个不错的机会，但从哪个方向投入到这股的热潮中呢？咨询了好几位公众号的作者，得到了以下回复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发新的轮子。&lt;/li&gt;
&lt;li&gt;赶快投入，开始做一些应用，&lt;/li&gt;
&lt;li&gt;大家都去挖金子，你可以去边上卖水。&lt;/li&gt;
&lt;li&gt;关注排名100开外的App，估计这些突破口比较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://qn.shisb.com/blog/wechat-application-font-end/weixinxiaochengxu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="微信小程序" scheme="http://shisb.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 闯关记》之对象</title>
    <link href="http://shisb.com/2016/09/07/javascript-lesson-1.7-ObjectObjects/"/>
    <id>http://shisb.com/2016/09/07/javascript-lesson-1.7-ObjectObjects/</id>
    <published>2016-09-07T14:15:00.000Z</published>
    <updated>2016-10-04T07:24:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>对象是 JavaScript 的数据类型。它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值，因此我们可以把它看成是从字符串到值的映射。对象是动态的，可以随时新增和删除自有属性。对象除了可以保持自有的属性，还可以从一个称为原型的对象继承属性，这种「原型式继承（prototypal inheritance）」是 JavaScript 的核心特征。</p>
<p>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。</p>
<p>属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意 JavaScript 值，或者在 ECMAScript 5中可以是 <code>getter</code> 或 <code>setter</code> 函数。</p>
<p>除了名字和值之外，每个属性还有一些与之相关的值，称为「属性特性（property attribute）」：</p>
<ul>
<li>可写（writable attribute），表明是否可以设置该属性的值。</li>
<li>可枚举（enumerable attribute），表明是否可以通过 <code>for-in</code> 循环返回该属性。</li>
<li>可配置（configurable attribute），表明是否可以删除或修改该属性。</li>
</ul>
<p>在 ECMAScript 5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在 ECMAScript 5中则可以对这些特性加以配置。</p>
<p>除了包含属性特性之外，每个对象还拥有三个相关的「对象特性（object attribute）」：</p>
<ul>
<li>对象的类（class），是一个标识对象类型的字符串。</li>
<li>对象的原型（prototype），指向另外一个对象，本对象的属性继承自它的原型对象。</li>
<li>对象的扩展标记（extensible flag），指明了在 ECMAScript 5中是否可以向该对象添加新属性。</li>
</ul>
<p>最后，用下面术语来对 JavaScript 的「三类对象」和「两类属性」进行区分：</p>
<ul>
<li>内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</li>
<li>宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。</li>
<li>自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。</li>
<li>自有属性（own property），是直接在对象中定义的属性。</li>
<li>继承属性（inherited property），是在对象的原型对象中定义的属性。</li>
</ul>
<a id="more"></a> 
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>可以使用对象字面量、<code>new</code> 关键字和 ECMAScript 5中的 <code>Object.create()</code> 函数来创建对象。</p>
<h3 id="使用对象字面量创建对象（推荐）"><a href="#使用对象字面量创建对象（推荐）" class="headerlink" title="使用对象字面量创建对象（推荐）"></a>使用对象字面量创建对象（推荐）</h3><p>创建对象最简单的方式就是在 JavaScript 代码中使用对象字面量。对象字面量是由若干名值对组成的映射表，名值对中间用冒号分隔，名值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式，表达式的值（可以是原始值也可以是对象值）就是这个属性的值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 推荐写法</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">"stone"</span>,</div><div class="line">    <span class="attr">age</span> : <span class="number">28</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 也可以写成</span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.name = <span class="string">"stone"</span>;</div><div class="line">person.age = <span class="number">28</span>;</div></pre></td></tr></table></figure>
<h3 id="使用-new-关键字创建对象"><a href="#使用-new-关键字创建对象" class="headerlink" title="使用 new 关键字创建对象"></a>使用 <code>new</code> 关键字创建对象</h3><p>new 关键字创建并初始化一个新对象。关键字 new 后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。JavaScript 语言核心中的原始类型都包含内置构造函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"stone"</span>;</div><div class="line">person.age = <span class="number">28</span>;</div></pre></td></tr></table></figure>
<p>其中 <code>var person = new Object();</code> 等价于 <code>var person = {};</code> 。</p>
<h3 id="使用-Object-create-函数创建对象"><a href="#使用-Object-create-函数创建对象" class="headerlink" title="使用 Object.create() 函数创建对象"></a>使用 <code>Object.create()</code> 函数创建对象</h3><p>ECMAScript 5定义了一个名为 <code>Object.create()</code> 的方法，它创建一个新对象，其中第一个参数是这个对象的原型。<code>Object.create()</code> 提供第二个可选参数，用以对对象的属性进行进一步描述。<code>Object.create()</code> 是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</div><div class="line">person.name = <span class="string">"stone"</span>;</div><div class="line">person.age = <span class="number">28</span>;</div></pre></td></tr></table></figure>
<p>其中 <code>var person = Object.create(Object.prototype);</code> 也等价于 <code>var person = {};</code> 。</p>
<h3 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h3><p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 <code>Object.prototype</code> 获得对原型对象的引用。通过关键字 <code>new</code> 和构造函数调用创建的对象的原型就是构造函数的 <code>prototype</code> 属性的值。因此，同使用 <code>{}</code> 创建对象一样，通过 <code>new Object()</code> 创建的对象也继承自 <code>Object.prototype</code>。同样，通过 <code>new Array()</code> 创建的对象的原型就是 <code>Array.prototype</code>，通过 <code>new Date()</code> 创建的对象的原型就是 <code>Date.prototype</code>。</p>
<p>没有原型的对象为数不多，<code>Object.prototype</code> 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 <code>Object.prototype</code> 的原型。例如，<code>Date.prototype</code> 的属性继承自 <code>Object.prototype</code>，因此由 <code>new Date()</code> 创建的 <code>Date</code> 对象的属性同时继承自 <code>Date.prototype</code> 和 <code>Object.prototype</code>。</p>
<p>这一系列链接的原型对象就是所谓的「原型链（prototype chain）」。</p>
<h2 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h2><p>前面有提到过，可以通过点 <code>.</code> 或方括号 <code>[]</code> 运算符来获取属性的值。对于点 <code>.</code> 来说，左侧应当是一个对象，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说 <code>[]</code> ，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名称。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 推荐写法</span></div><div class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// "stone"</span></div><div class="line"><span class="built_in">console</span>.log(person.age);    <span class="comment">// "28"</span></div><div class="line"></div><div class="line"><span class="comment">// 也可以写成</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]);    <span class="comment">// stone</span></div><div class="line"><span class="built_in">console</span>.log(person[<span class="string">"age"</span>]);     <span class="comment">// 28</span></div></pre></td></tr></table></figure>
<p>和获取属性的值写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 推荐写法</span></div><div class="line">person.name = <span class="string">"sophie"</span>; <span class="comment">// 赋值</span></div><div class="line">person.age = <span class="number">30</span>;        <span class="comment">// 赋值</span></div><div class="line">person.weight = <span class="number">38</span>;     <span class="comment">// 创建</span></div><div class="line"></div><div class="line"><span class="comment">// 也可以写成</span></div><div class="line">person[<span class="string">"name"</span>] = <span class="string">"sophie"</span>;  <span class="comment">// 赋值</span></div><div class="line">person[<span class="string">"age"</span>] = <span class="number">30</span>;         <span class="comment">// 赋值</span></div><div class="line">person[<span class="string">"weight"</span>] = <span class="number">38</span>;      <span class="comment">// 创建</span></div></pre></td></tr></table></figure>
<p>当使用方括号时，方括号内的表达式必须返回字符串。更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。</p>
<h2 id="属性的访问错误"><a href="#属性的访问错误" class="headerlink" title="属性的访问错误"></a>属性的访问错误</h2><p>查询一个不存在的属性并不会报错，如果在对象 <code>o</code> 自身的属性或继承的属性中均未找到属性 <code>x</code>，属性访问表达式 <code>o.x</code> 返回 <code>undefined</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.wife;    <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。<code>null</code> 和 <code>undefined</code> 值都没有属性，因此查询这些值的属性会报错。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line">person.wife.name;   <span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined.</span></div></pre></td></tr></table></figure>
<p>除非确定 <code>person</code> 和 <code>person.wife</code> 都是对象，否则不能这样写表达式 <code>person.wife.name</code>，因为会报「未捕获的错误类型」，下面提供了两种避免出错的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 冗余但易懂的写法</span></div><div class="line"><span class="keyword">var</span> name;</div><div class="line"><span class="keyword">if</span> (person) &#123;</div><div class="line">    <span class="keyword">if</span> (person.wife) </div><div class="line">        name = person.wife.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 简练又常用的写法（推荐写法）</span></div><div class="line"><span class="keyword">var</span> name = person &amp;&amp; person.wife &amp;&amp; person.wife.name;</div></pre></td></tr></table></figure>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p><code>delete</code> 运算符用来删除对象属性，事实上 <code>delete</code> 只是断开属性和宿主对象的联系，并没有真正的删除它。<code>delete</code> 运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。</p>
<blockquote>
<p>代码范例，请参见<a href="https://github.com/stone0090/javascript-lessons/tree/master/1.5-Expression%26Operators#delete-运算符" target="_blank" rel="external">「变量和数据类型」-「数据类型」-「delete 运算符」</a>。</p>
</blockquote>
<h2 id="检测属性"><a href="#检测属性" class="headerlink" title="检测属性"></a>检测属性</h2><p>JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系（判断某个属性是否存在于某个对象中）。可以通过 <code>in</code> 运算符、<code>hasOwnPreperty()</code> 和 <code>propertyIsEnumerable()</code> 来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p>
<p><code>in</code> 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 <code>true</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// true，x是o的属性</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"y"</span> <span class="keyword">in</span> o);          <span class="comment">// false，y不是o的属性</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> o);   <span class="comment">// true，toString是继承属性</span></div></pre></td></tr></table></figure>
<p>对象的 <code>hasOwnProperty()</code> 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 <code>false</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</div><div class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"x"</span>));          <span class="comment">// true，x是o的自有属性</span></div><div class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"y"</span>));          <span class="comment">// false，y不是o的属性</span></div><div class="line"><span class="built_in">console</span>.log(o.hasOwnProperty(<span class="string">"toString"</span>));   <span class="comment">// false，toString是继承属性</span></div></pre></td></tr></table></figure>
<p><code>propertyIsEnumerable()</code> 是 <code>hasOwnProperty()</code> 的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 <code>true</code> 时它才返回 <code>true</code>。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript 5中使用一个特殊的方法来改变属性的可枚举性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = inherit(&#123; <span class="attr">y</span>: <span class="number">2</span> &#125;);</div><div class="line">o.x = <span class="number">1</span>;</div><div class="line">o.propertyIsEnumerable(<span class="string">"x"</span>);    <span class="comment">// true:，x是o的自有属性，可枚举</span></div><div class="line">o.propertyIsEnumerable(<span class="string">"y"</span>);    <span class="comment">// false，y是继承属性</span></div><div class="line"><span class="built_in">Object</span>.prototype.propertyIsEnumerable(<span class="string">"toString"</span>);  <span class="comment">// false，不可枚举</span></div></pre></td></tr></table></figure>
<p>除了使用 <code>in</code> 运算符之外，另一种更简便的方法是使用 <code>!==</code> 判断一个属性是否是 <code>undefined</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</div><div class="line"><span class="built_in">console</span>.log(o.x !== <span class="literal">undefined</span>);              <span class="comment">// true，x是o的属性</span></div><div class="line"><span class="built_in">console</span>.log(o.y !== <span class="literal">undefined</span>);              <span class="comment">// false，y不是o的属性</span></div><div class="line"><span class="built_in">console</span>.log(o.toString !== <span class="literal">undefined</span>);       <span class="comment">// true，toString是继承属性</span></div></pre></td></tr></table></figure>
<p>然而有一种场景只能使用 <code>in</code> 运算符而不能使用上述属性访问的方式。<code>in</code> 可以区分不存在的属性和存在但值为 <code>undefined</code> 的属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;        <span class="comment">// 属性被显式赋值为undefined</span></div><div class="line"><span class="built_in">console</span>.log(o.x !== <span class="literal">undefined</span>); <span class="comment">// false，属性存在，但值为undefined</span></div><div class="line"><span class="built_in">console</span>.log(o.y !== <span class="literal">undefined</span>); <span class="comment">// false，属性不存在</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// true，属性存在</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"y"</span> <span class="keyword">in</span> o);          <span class="comment">// false，属性不存在</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> o.x);        <span class="comment">// true，删除了属性x</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span> <span class="keyword">in</span> o);          <span class="comment">// false，属性不再存在</span></div></pre></td></tr></table></figure>
<blockquote>
<p>扩展阅读「JavaScript 检测原始值、引用值、属性」<br><a href="http://shijiajie.com/2016/06/20/javascript-maintainable-javascript-validate1/" target="_blank" rel="external">http://shijiajie.com/2016/06/20/javascript-maintainable-javascript-validate1/</a></p>
<p>扩展阅读「JavaScript 检测之 basevalidate.js」<br><a href="http://shijiajie.com/2016/06/25/javascript-maintainable-javascript-basevalidatejs/" target="_blank" rel="external">http://shijiajie.com/2016/06/25/javascript-maintainable-javascript-basevalidatejs/</a></p>
</blockquote>
<h2 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h2><p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。通常使用 <code>for-in</code> 循环遍历，ECMAScript 5提供了两个更好用的替代方案。</p>
<p><code>for-in</code> 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;            <span class="comment">// 三个可枚举的自有属性</span></div><div class="line">o.propertyIsEnumerable(<span class="string">"toString"</span>); <span class="comment">// false，不可枚举</span></div><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;          <span class="comment">// 遍历属性</span></div><div class="line">    <span class="built_in">console</span>.log(p);     <span class="comment">// 输出x、y和z，不会输出toString</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有许多实用工具库给 <code>Object.prototype</code> 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在ECMAScript 5标准之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在 <code>for-in</code> 循环中枚举出来。为了避免这种情况，需要过滤 <code>for-in</code> 循环返回的属性，下面两种方式是最常见的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(p <span class="keyword">in</span> o) &#123;</div><div class="line">   <span class="keyword">if</span> (!o.hasOwnProperty(p)) <span class="keyword">continue</span>;          <span class="comment">// 跳过继承的属性</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">"function"</span>) <span class="keyword">continue</span>;    <span class="comment">// 跳过方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了 <code>for-in</code> 循环之外，ECMAScript 5定义了两个用以枚举属性名称的函数。第一个是 <code>Object.keys()</code>，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。第二个是 <code>Object.getOwnPropertyNames()</code>，它和 <code>Ojbect.keys()</code> 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。在ECMAScript 3中是无法实现的类似的函数的，因为ECMAScript 3中没有提供任何方法来获取对象不可枚举的属性。</p>
<h2 id="属性的-getter-和-setter"><a href="#属性的-getter-和-setter" class="headerlink" title="属性的 getter 和 setter"></a>属性的 <code>getter</code> 和 <code>setter</code></h2><p>我们知道，对象属性是由名字、值和一组特性（attribute）构成的。在ECMAScript 5中，属性值可以用一个或两个方法替代，这两个方法就是 <code>getter</code> 和 <code>setter</code>。由 <code>getter</code> 和 <code>setter</code> 定义的属性称做「存取器属性（accessor property）」，它不同于「数据属性（data property）」，数据属性只有一个简单的值。</p>
<p>当程序查询存取器属性的值时，JavaScript 调用 <code>getter</code> 方法。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时，JavaScript 调用 <code>setter</code> 方法，将赋值表达式右侧的值当做参数传入 <code>setter</code>。从某种意义上讲，这个方法负责「设置」属性值。可以忽略 <code>setter</code> 方法的返回值。</p>
<p>和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 <code>getter</code> 和 <code>setter</code> 方法，那么它是一个读/写属性。如果它只有 <code>getter</code> 方法，那么它是一个只读属性。如果它只有 <code>setter</code> 方法，那么它是一个只写属性，读取只写属性总是返回 <code>undefined</code>。定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="comment">// 普通的数据属性</span></div><div class="line">    data_prop: value,</div><div class="line"></div><div class="line">    <span class="comment">// 存取器属性都是成对定义的函数</span></div><div class="line">    get accessor_prop() &#123; <span class="comment">/*这里是函数体 */</span> &#125;,</div><div class="line">    set accessor_prop(value) &#123; <span class="comment">/* 这里是函数体*/</span> &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 <code>function</code> 关键字，而是使用 <code>get</code> 或 <code>set</code>。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。</p>
<h2 id="序列化对象（JSON）"><a href="#序列化对象（JSON）" class="headerlink" title="序列化对象（JSON）"></a>序列化对象（JSON）</h2><p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5提供了内置函数 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是「JavaScript 对象表示法（JavaScript Object Notation）」，它的语法和 JavaScript 对象与数组直接量的语法非常相近。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:&#123;<span class="attr">z</span>:[<span class="literal">false</span>,<span class="literal">null</span>,<span class="string">""</span>]&#125;&#125;;       <span class="comment">// 定义一个对象</span></div><div class="line">s = <span class="built_in">JSON</span>.stringify(o);                  <span class="comment">// s是 '&#123;"x":1,"y":&#123;"z":[false,null,""]&#125;&#125;'</span></div><div class="line">p = <span class="built_in">JSON</span>.parse(s);                      <span class="comment">// p是o的深拷贝</span></div></pre></td></tr></table></figure>
<p>ECMAScript 5中的这些函数的本地实现和 <a href="https://github.com/douglascrockford/JSON-js" target="_blank" rel="external">https://github.com/douglascrockford/JSON-js</a> 中的公共域ECMAScript 3版本的实现非常类似，或者说完全一样，因此可以通过引入 <code>json2.js</code> 模块在ECMAScript 3的环境中使用ECMAScript 5中的这些函数。</p>
<p>JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。它支持对象、数组、字符串、无穷大数字、<code>true</code>、<code>false</code> 和 <code>null</code>，可以序列化和还原它们。<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code> 序列化的结果是 <code>null</code>，日期对象序列化的结果是 ISO 格式的日期字符串（参照 <code>Date.toJSON()</code> 函数），但 <code>JSON.parse()</code> 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、<code>RegExp</code>、<code>Error</code> 对象和 <code>undefined</code> 值不能序列化和还原。<code>JSON.stringify()</code> 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>请实现下面用来枚举属性的对象工具函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 把 p 中的可枚举属性复制到 o 中，并返回 o</div><div class="line"> * 如果 o 和 p 中含有同名属性，则覆盖 o 中的属性</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 将 p 中的可枚举属性复制至 o 中，并返回 o</div><div class="line"> * 如果 o 和 p 中有同名的属性，o 中的属性将不受影响</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">o, p</span>) </span>&#123;</div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 如果 o 中的属性在 p 中没有同名属性，则从 o 中删除这个属性</div><div class="line"> * 返回 o</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span>(<span class="params">o, p</span>) </span>&#123;</div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 如果 o 中的属性在 p 中存在同名属性，则从 o 中删除这个属性</div><div class="line"> * 返回 o</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">o, p</span>) </span>&#123;</div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个新对象，这个对象同时拥有 o 的属性和 p 的属性</div><div class="line"> * 如果 o 和 p 中有重名属性，使用 p 中的属性值</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">o, p</span>) </span>&#123; </div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个新对象，这个对象拥有同时在 o 和 p 中出现的属性</div><div class="line"> * 很像求 o 和 p 的交集，但 p 中属性的值被忽略</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">o, p</span>) </span>&#123; </div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回一个数组，这个数组包含的是 o 中可枚举的自有属性的名字</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="comment">// 请实现函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对象是 JavaScript 的数据类型。它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值，因此我们可以把它看成是从字符串到值的映射。对象是动态的，可以随时新增和删除自有属性。对象除了可以保持自有的属性，还可以从一个称为原型的对象继承属性，这种「原型式继承（prototypal inheritance）」是 JavaScript 的核心特征。&lt;/p&gt;
&lt;p&gt;对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。&lt;/p&gt;
&lt;p&gt;属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意 JavaScript 值，或者在 ECMAScript 5中可以是 &lt;code&gt;getter&lt;/code&gt; 或 &lt;code&gt;setter&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;除了名字和值之外，每个属性还有一些与之相关的值，称为「属性特性（property attribute）」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可写（writable attribute），表明是否可以设置该属性的值。&lt;/li&gt;
&lt;li&gt;可枚举（enumerable attribute），表明是否可以通过 &lt;code&gt;for-in&lt;/code&gt; 循环返回该属性。&lt;/li&gt;
&lt;li&gt;可配置（configurable attribute），表明是否可以删除或修改该属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 ECMAScript 5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在 ECMAScript 5中则可以对这些特性加以配置。&lt;/p&gt;
&lt;p&gt;除了包含属性特性之外，每个对象还拥有三个相关的「对象特性（object attribute）」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象的类（class），是一个标识对象类型的字符串。&lt;/li&gt;
&lt;li&gt;对象的原型（prototype），指向另外一个对象，本对象的属性继承自它的原型对象。&lt;/li&gt;
&lt;li&gt;对象的扩展标记（extensible flag），指明了在 ECMAScript 5中是否可以向该对象添加新属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，用下面术语来对 JavaScript 的「三类对象」和「两类属性」进行区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置对象（native object），是由 JavaScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。&lt;/li&gt;
&lt;li&gt;宿主对象（host object），是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。&lt;/li&gt;
&lt;li&gt;自定义对象（user-defined object），是由运行中的 JavaScript 代码创建的对象。&lt;/li&gt;
&lt;li&gt;自有属性（own property），是直接在对象中定义的属性。&lt;/li&gt;
&lt;li&gt;继承属性（inherited property），是在对象的原型对象中定义的属性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JavaScript" scheme="http://shisb.com/categories/%E6%8A%80%E6%9C%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://shisb.com/tags/JavaScript/"/>
    
      <category term="《JavaScript 闯关记》" scheme="http://shisb.com/tags/%E3%80%8AJavaScript-%E9%97%AF%E5%85%B3%E8%AE%B0%E3%80%8B/"/>
    
  </entry>
  
</feed>
