<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="劼哥舍"><title>《JavaScript 闯关记》之函数 | 劼哥舍(＞﹏＜)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《JavaScript 闯关记》之函数</h1><a id="logo" href="/.">劼哥舍(＞﹏＜)</a><p class="description">越简单越快乐，越努力越幸运...</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《JavaScript 闯关记》之函数</h1><div class="post-meta">Oct 12, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a><a href="/categories/技术/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数定义"><span class="toc-number">1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没有重载"><span class="toc-number">2.</span> <span class="toc-text">没有重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数声明与函数表达式"><span class="toc-number">3.</span> <span class="toc-text">函数声明与函数表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作为值的函数"><span class="toc-number">4.</span> <span class="toc-text">作为值的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的形参和实参"><span class="toc-number">5.</span> <span class="toc-text">函数的形参和实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的属性和方法"><span class="toc-number">6.</span> <span class="toc-text">函数的属性和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关卡"><span class="toc-number">7.</span> <span class="toc-text">关卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多"><span class="toc-number">8.</span> <span class="toc-text">更多</span></a></li></ol></div></div><div class="post-content"><p>函数是一段代码，它只定义一次，但可以被执行或调用任意次。在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。如果函数嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>在 JavaScript 中，函数实际上是对象，每个函数都是 <code>Function</code> 构造函数的实例，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常有以下3中定义方式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：函数声明（推荐写法）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写法二：函数表达式（推荐写法）</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 写法三：Function 构造函数（不推荐写法）</span></div><div class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</div></pre></td></tr></table></figure>
<p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>));        <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherSum = sum;</div><div class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div><div class="line"></div><div class="line">sum = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<a id="more"></a> 
<h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>将函数名想象为指针，也有助于理解为什么 JavaScript 中没有函数重载的概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);    <span class="comment">// 300</span></div></pre></td></tr></table></figure>
<p>显然，这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际上与下面的代码没有什么区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);    <span class="comment">// 300</span></div></pre></td></tr></table></figure>
<p>通过重写代码之后可以很容易明白，在创建第二个函数时，实际上覆盖了引用第一个函数的变量 <code>addSomeNumber</code>。</p>
<h2 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h2><p>解析器在向执行环境中加载数据时，对「函数声明」和「函数表达式」并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 20</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完全可以正常运行。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。把上面的「函数声明」改为等价的「函数表达式」，就会在执行期间导致错误。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// Uncaught TypeError: sum is not a function</span></div><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了上述区别之外，「函数声明」与「函数表达式」的语法是等价的。</p>
<h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为 JavaScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。来看一看下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> someFunction(someArgument);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(result1);   <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</div><div class="line"><span class="built_in">console</span>.log(result2);   <span class="comment">// "Hello, Nicholas"</span></div></pre></td></tr></table></figure>
<p>这里的 <code>callSomeFunction()</code> 函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号。因此上面例子中传递给 <code>callSomeFunction()</code> 的是 <code>add10</code> 和 <code>getGreeting</code>，而不是执行它们之后的结果。</p>
<p>当然，还可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 <code>sort()</code> 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">        <span class="keyword">if</span> (value1 &lt; value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个 <code>return</code> 操作符。在内部函数接收到 <code>propertyName</code> 参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上面这个函数可以像在下面例子中这样使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</div><div class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Nicholas</span></div><div class="line"></div><div class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</div><div class="line"><span class="built_in">console</span>.log(data[<span class="number">0</span>].name);  <span class="comment">// Zachary</span></div></pre></td></tr></table></figure>
<p>这里，我们创建了一个包含两个对象的数组 <code>data</code>。其中，每个对象都包含一个 <code>name</code> 属性和一个 <code>age</code> 属性。在默认情况下，<code>sort()</code> 方法会调用每个对象的 <code>toString()</code> 方法以确定它们的次序；但得到的结果往往并不符合人类的思维习惯。因此，我们调用 <code>createComparisonFunction(&quot;name&quot;)</code> 方法创建了一个比较函数，以便按照每个对象的 <code>name</code> 属性值进行排序。而结果排在前面的第一项是 <code>name</code> 为 <code>&quot;Nicholas&quot;</code>，<code>age</code> 是 <code>29</code> 的对象。然后，我们又使用了 <code>createComparisonFunction(&quot;age&quot;)</code> 返回的比较函数，这次是按照对象的age属性排序。得到的结果是 <code>name</code> 值为 <code>&quot;Zachary&quot;</code>，<code>age</code> 值是 <code>28</code> 的对象排在了第一位。</p>
<h2 id="函数的形参和实参"><a href="#函数的形参和实参" class="headerlink" title="函数的形参和实参"></a>函数的形参和实参</h2><p>在函数内部，有两个特殊的对象：<code>arguments</code> 和 <code>this</code>。其中，<code>arguments</code> 是一个类数组对象，包含着传入函数中的所有参数。虽然 <code>arguments</code> 的主要用途是保存函数参数，但这个对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数。请看下面这个非常经典的阶乘函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到递归算法，如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个重写后的 <code>factorial()</code> 函数的函数体内，没有再引用函数名 <code>factorial</code>。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(trueFactorial(<span class="number">5</span>));  <span class="comment">// 120</span></div><div class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));      <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>在此，变量 <code>trueFactorial</code> 获得了 <code>factorial</code> 的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回 <code>0</code> 的函数赋值给 <code>factorial</code> 变量。如果像原来的 <code>factorial()</code> 那样不使用 <code>arguments.callee</code>，调用 <code>trueFactorial()</code> 就会返回 <code>0</code>。可是，在解除了函数体内的代码与函数名的耦合状态之后，<code>trueFactorial()</code> 仍然能够正常地计算阶乘；至于 <code>factorial()</code>，它现在只是一个返回 <code>0</code> 的函数。</p>
<p>函数内部的另一个特殊对象是 <code>this</code>，其行为与 Java 和 C# 中的 <code>this</code> 大致类似。换句话说，<code>this</code> 引用的是函数据以执行的环境对象（当在网页的全局作用域中调用函数时，<code>this</code> 对象引用的就是 <code>window</code>）。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor();     <span class="comment">// "red"</span></div><div class="line"></div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();   <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p>上面这个函数 <code>sayColor()</code> 是在全局作用域中定义的，它引用了 <code>this</code> 对象。由于在调用函数之前，<code>this</code> 的值并不确定，因此 <code>this</code> 可能会在代码执行过程中引用不同的对象。当在全局作用域中调用 <code>sayColor()</code> 时，<code>this</code> 引用的是全局对象 <code>window</code>；换句话说，对 <code>this.color</code> 求值会转换成对 <code>window.color</code> 求值，于是结果就返回了 <code>&quot;red&quot;</code>。而当把这个函数赋给对象 <code>o</code> 并调用 <code>o.sayColor()</code> 时，<code>this</code> 引用的是对象 <code>o</code>，因此对 <code>this.color</code> 求值会转换成对 <code>o.color</code> 求值，结果就返回了 <code>&quot;blue&quot;</code>。</p>
<p>请大家一定要牢记，函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 <code>sayColor()</code> 函数与 <code>o.sayColor()</code> 指向的仍然是同一个函数。</p>
<p>ECMAScript 5也规范化了另一个函数对象的属性 <code>caller</code>。这个属性中保存着「调用当前函数的函数的引用」，如果是在全局作用域中调用当前函数，它的值为 <code>null</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    inner();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</div><div class="line">&#125; </div><div class="line"></div><div class="line">outer();</div></pre></td></tr></table></figure>
<p>以上代码会导致警告框中显示 <code>outer()</code> 函数的源代码。因为 <code>outer()</code> 调用了 <code>inter()</code>，所以 <code>arguments.callee.caller</code> 就指向 <code>outer()</code>。</p>
<p>在严格模式下，访问 <code>arguments.callee</code>属性，或为函数的 <code>caller</code> 属性赋值，都会导致错误。</p>
<h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><p>JavaScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：<code>length</code> 和 <code>prototype</code>。其中，<code>length</code> 属性表示函数希望接收的命名参数的个数，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(sayName.length);      <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(sum.length);          <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(sayHi.length);        <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<p>对于 JavaScript 中的引用类型而言，<code>prototype</code> 是保存它们所有实例方法的真正所在。换句话说，诸如 <code>toString()</code> 和 <code>valueOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，<code>prototype</code> 属性的作用是极为重要的。在 ECMAScript 5中，<code>prototype</code> 属性是不可枚举的，因此使用 <code>for-in</code> 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：<code>apply()</code> 和 <code>call()</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 <code>this</code> 对象的值。首先，<code>apply()</code> 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 <code>Array</code> 的实例，也可以是 <code>arguments</code> 对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);  <span class="comment">// 传入 arguments 对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);  <span class="comment">// 传入数组</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div><div class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>callSum1()</code> 在执行 <code>sum()</code> 函数时传入了 <code>this</code>（因为是在全局作用域中调用的，所以传入的就是 <code>window</code> 对象）和 <code>arguments</code> 对象。而 <code>callSum2</code> 同样也调用了 <code>sum()</code> 函数，但它传入的则是 <code>this</code> 和一个参数数组。这两个函数都会正常执行并返回正确的结果。</p>
<p><code>call()</code> 方法与 <code>apply()</code> 方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 <code>call()</code> 方法而言，第一个参数是 <code>this</code> 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 <code>call()</code> 方法时，传递给函数的参数必须逐个列举出来，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num1 + num2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>));   <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>在使用 <code>call()</code> 方法的情况下，<code>callSum()</code> 必须明确地传入每一个参数。结果与使用 <code>apply()</code> 没有什么不同。至于是使用 <code>apply()</code> 还是 <code>call()</code>，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入 <code>arguments</code> 对象，或者包含函数中先接收到的也是一个数组，那么使用 <code>apply()</code> 肯定更方便；否则，选择 <code>call()</code> 可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓。）<br>事实上，传递参数并非 <code>apply()</code> 和 <code>call()</code> 真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。下面来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</div><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</div><div class="line">&#125;</div><div class="line">sayColor();                <span class="comment">// red</span></div><div class="line"></div><div class="line">sayColor.call(<span class="keyword">this</span>);       <span class="comment">// red</span></div><div class="line">sayColor.call(<span class="built_in">window</span>);     <span class="comment">// red</span></div><div class="line">sayColor.call(o);          <span class="comment">// blue</span></div></pre></td></tr></table></figure>
<p>这个例子是在前面说明 <code>this</code> 对象的示例基础上修改而成的。这一次，<code>sayColor()</code> 也是作为全局函数定义的，而且当在全局作用域中调用它时，它确实会显示 <code>&quot;red&quot;</code>，因为对 <code>this.color</code> 的求值会转换成对 <code>window.color</code> 的求值。而 <code>sayColor.call(this)</code> 和 <code>sayColor.call(window)</code>，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示 <code>&quot;red&quot;</code>。但是，当运行 <code>sayColor.call(o)</code> 时，函数的执行环境就不一样了，因为此时函数体内的 <code>this</code> 对象指向了 <code>o</code>，于是结果显示的是 <code>&quot;blue&quot;</code>。</p>
<p>使用 <code>call()</code> 或 <code>apply()</code> 来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将 <code>sayColor()</code> 函数放到了对象 <code>o</code> 中，然后再通过 <code>o</code> 来调用它的；而在这里重写的例子中，就不需要先前那个多余的步骤了。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战一，合并任意个数的字符串</span></div><div class="line"><span class="keyword">var</span> concat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(concat(<span class="string">'st'</span>,<span class="string">'on'</span>,<span class="string">'e'</span>));  <span class="comment">// stone</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战二，输出指定位置的斐波那契数列</span></div><div class="line"><span class="keyword">var</span> fioacciSequece = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(fioacciSequece(<span class="number">12</span>));  <span class="comment">// 0、1、1、2、3、5、8、13、21、34、55、89</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 挑战三，三维数组或 n 维数组去重，使用 arguments 重写</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">5</span>],<span class="number">3</span>,<span class="number">5</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>],<span class="number">2</span>],<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">    <span class="comment">// 待实现方法体</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(unique(arr)); <span class="comment">// [2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://shisb.com/2016/10/12/javascript-lesson-1.9-FunctionObjects/" data-id="cj7ypl92z002de251dyk7y8go" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/《JavaScript-闯关记》/">《JavaScript 闯关记》</a></div><div class="post-nav"><a href="/2016/10/07/javascript-lesson-1.8-ArrayObjects/" class="pre">《JavaScript 闯关记》之对象</a><a href="/2016/10/17/javascript-lesson-1.10-RegExpObjects/" class="next">《JavaScript 闯关记》之正则表达式</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/stone0090" title="我的「GitHub」" target="_blank">我的「GitHub」</a><ul></ul><a href="http://qn.shisb.com/weixin/xiaomiquan.jpg" title="我的「小密圈」" target="_blank">我的「小密圈」</a><ul></ul><a href="http://qn.shisb.com/weixin/qrcode_for_gh_48ef95800cf5_430.jpg" title="我的「微信公众号」" target="_blank">我的「微信公众号」</a><ul></ul><a href="http://weibo.com/605494869" title="我的「微博」" target="_blank">我的「微博」</a><ul></ul><a href="https://www.zhihu.com/people/stone0090" title="我的「知乎」" target="_blank">我的「知乎」</a><ul></ul><a href="http://www.jianshu.com/u/0005893eaff9" title="我的「简书」" target="_blank">我的「简书」</a><ul></ul><a href="https://juejin.im/user/57b83a6fa633bd0066590d37" title="我的「掘金」" target="_blank">我的「掘金」</a><ul></ul><a href="http://www.cnblogs.com/shi0090" title="我的「博客园」" target="_blank">我的「博客园」</a><ul></ul><a href="http://blog.csdn.net/shi0090" title="我的「CSDN」" target="_blank">我的「CSDN」</a><ul></ul><a href="https://segmentfault.com/u/stone0090" title="我的「SegmentFault」" target="_blank">我的「SegmentFault」</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/NET/">.NET</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/DSOframer/">DSOframer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/算法/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/软件/Parallels/">Parallels</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/VMware/">VMware</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/心情随笔/">心情随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/读书笔记/">读书笔记</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/原型链/" style="font-size: 15px;">原型链</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ASP-NET/" style="font-size: 15px;">ASP.NET</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a> <a href="/tags/断点续传/" style="font-size: 15px;">断点续传</a> <a href="/tags/Amaze-UI/" style="font-size: 15px;">Amaze UI</a> <a href="/tags/开源项目/" style="font-size: 15px;">开源项目</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/EasyUI/" style="font-size: 15px;">EasyUI</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/DSOframer/" style="font-size: 15px;">DSOframer</a> <a href="/tags/心情随笔/" style="font-size: 15px;">心情随笔</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/float/" style="font-size: 15px;">float</a> <a href="/tags/position/" style="font-size: 15px;">position</a> <a href="/tags/样式布局分享/" style="font-size: 15px;">样式布局分享</a> <a href="/tags/frozen-js/" style="font-size: 15px;">frozen.js</a> <a href="/tags/zepto/" style="font-size: 15px;">zepto</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/landscape-plus/" style="font-size: 15px;">landscape-plus</a> <a href="/tags/编程珠玑/" style="font-size: 15px;">编程珠玑</a> <a href="/tags/prototype/" style="font-size: 15px;">prototype</a> <a href="/tags/《JavaScript-闯关记》/" style="font-size: 15px;">《JavaScript 闯关记》</a> <a href="/tags/《编写可维护的JavaScript》/" style="font-size: 15px;">《编写可维护的JavaScript》</a> <a href="/tags/basevalidate-js/" style="font-size: 15px;">basevalidate.js</a> <a href="/tags/微信公众号/" style="font-size: 15px;">微信公众号</a> <a href="/tags/tab-js/" style="font-size: 15px;">tab.js</a> <a href="/tags/PDF转图片/" style="font-size: 15px;">PDF转图片</a> <a href="/tags/DOC转图片/" style="font-size: 15px;">DOC转图片</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/MicroBlog/" style="font-size: 15px;">MicroBlog</a> <a href="/tags/Node-js开发指南/" style="font-size: 15px;">Node.js开发指南</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/时间管理/" style="font-size: 15px;">时间管理</a> <a href="/tags/Windows-10/" style="font-size: 15px;">Windows 10</a> <a href="/tags/Boot-Camp/" style="font-size: 15px;">Boot Camp</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/Parallels/" style="font-size: 15px;">Parallels</a> <a href="/tags/专栏精粹/" style="font-size: 15px;">专栏精粹</a> <a href="/tags/VMware/" style="font-size: 15px;">VMware</a> <a href="/tags/阿里影业/" style="font-size: 15px;">阿里影业</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">劼哥舍(＞﹏＜).</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn/"> 粤ICP备15013245号-2.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>