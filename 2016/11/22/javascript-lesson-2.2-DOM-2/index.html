<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="劼哥舍"><title>《JavaScript 闯关记》之 DOM（下） | 劼哥舍(＞﹏＜)</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《JavaScript 闯关记》之 DOM（下）</h1><a id="logo" href="/.">劼哥舍(＞﹏＜)</a><p class="description">越简单越快乐，越努力越幸运...</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《JavaScript 闯关记》之 DOM（下）</h1><div class="post-meta">Nov 22, 2016<span> | </span><span class="category"><a href="/categories/技术/">技术</a><a href="/categories/技术/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><p>除了 <code>Document</code> 类型之外，<code>Element</code> 类型就要算是 Web 编程中最常用的类型了。<code>Element</code> 类型用于表现 XML 或 HTML 元素，提供了对元素标签名、子节点及特性的访问。<code>Element</code> 节点具有以下特征：</p>
<ul>
<li><code>nodeType</code> 的值为1；</li>
<li><code>nodeName</code> 的值为元素的标签名；</li>
<li><code>nodeValue</code> 的值为 <code>null</code>；</li>
<li><code>parentNode</code> 可能是 <code>Document</code> 或 <code>Element</code>；</li>
<li>其子节点可能是 <code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code> 或 <code>EntityReference</code>。</li>
</ul>
<p>要访问元素的标签名，可以使用 <code>nodeName</code> 属性，也可以使用 <code>tagName</code> 属性；这两个属性会返回相同的值（使用后者主要是为了清晰起见）。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a> 
<p>可以像下面这样取得这个元素及其标签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.tagName); <span class="comment">// "DIV"</span></div><div class="line"><span class="built_in">console</span>.log(div.tagName === div.nodeName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这里的元素标签名是 <code>div</code>，它拥有一个值为 <code>&quot;myDiv&quot;</code> 的ID。可是，<code>div.tagName</code> 实际上输出的是 <code>&quot;DIV&quot;</code> 而非 <code>&quot;div&quot;</code>。在HTML中，标签名始终都以全部大写表示；而在 XML（有时候也包括 XHTML）中，标签名则始终会与源代码中的保持一致。假如你不确定自己的脚本将会在 HTML 还是 XML 文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不能这样比较，很容易出错！</span></div><div class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>)&#123; </div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 这样最好（适用于任何文档）</span></div><div class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>)&#123; </div><div class="line">    <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h4><p>所有 HTML 元素都由 <code>HTMLElement</code> 类型表示，不是直接通过这个类型，也是通过它的子类型来表示。<code>HTMLElement</code> 类型直接继承自 <code>Element</code> 并添加了一些属性。添加的这些属性分别对应于每个 HTML 元素中都存在的下列标准特性。</p>
<ul>
<li><code>id</code>，元素在文档中的唯一标识符。</li>
<li><code>title</code>，有关元素的附加说明信息，一般通过工具提示条显示出来。</li>
<li><code>lang</code>，元素内容的语言代码，很少使用。</li>
<li><code>dir</code>，语言的方向，值为 <code>&quot;ltr&quot;</code>（left-to-right，从左至右）或 <code>&quot;rtl&quot;</code>（right-to-left，从右至左），也很少使用。</li>
<li><code>className</code>，与元素的 <code>class</code> 特性对应，即为元素指定的 CSS 类。没有将这个属性命名为 <code>class</code>，是因为 <code>class</code> 是 JavaScript 的保留字。</li>
</ul>
<p>上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">class</span>=<span class="string">"bd"</span> <span class="attr">title</span>=<span class="string">"Body text"</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>元素中指定的所有信息，都可以通过下列 JavaScript 代码取得：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.id);         <span class="comment">// "myDiv""</span></div><div class="line"><span class="built_in">console</span>.log(div.className);  <span class="comment">// "bd"</span></div><div class="line"><span class="built_in">console</span>.log(div.title);      <span class="comment">// "Body text"</span></div><div class="line"><span class="built_in">console</span>.log(div.lang);       <span class="comment">// "en"</span></div><div class="line"><span class="built_in">console</span>.log(div.dir);        <span class="comment">// "ltr"</span></div></pre></td></tr></table></figure>
<p>当然，像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.className = <span class="string">"ft"</span>;</div><div class="line">div.title = <span class="string">"Some other text"</span>;</div><div class="line">div.lang = <span class="string">"fr"</span>;</div><div class="line">div.dir =<span class="string">"rtl"</span>;</div></pre></td></tr></table></figure>
<p>并不是对所有属性的修改都会在页面中直观地表现出来。对 <code>id</code> 或 <code>lang</code> 的修改对用户而言是透明不可见的（假设没有基于它们的值设置的 CSS 样式），而对 <code>title</code> 的修改则只会在鼠标移动到这个元素之上时才会显示出来。对 <code>dir</code> 的修改会在属性被重写的那一刻，立即影响页面中文本的左、右对齐方式。修改 <code>className</code> 时，如果新类关联了与此前不同的 CSS 样式，那么就会立即应用新的样式。</p>
<h4 id="取得特性"><a href="#取得特性" class="headerlink" title="取得特性"></a>取得特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息。操作特性的 DOM 方法主要有三个，分别是 <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code>。这三个方法可以针对任何特性使用，包括那些以 <code>HTMLElement</code> 类型属性的形式定义的特性。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"id"</span>));     <span class="comment">// "myDiv"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"class"</span>));  <span class="comment">// "bd"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"title"</span>));  <span class="comment">// "Body text"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"lang"</span>));   <span class="comment">// "en"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"dir"</span>));    <span class="comment">// "ltr"</span></div></pre></td></tr></table></figure>
<p>注意，传递给 <code>getAttribute()</code> 的特性名与实际的特性名相同。因此要想得到 <code>class</code> 特性值，应该传入 <code>&quot;class&quot;</code> 而不是 <code>&quot;className&quot;</code>，后者只有在通过对象属性访问特性时才用。如果给定名称的特性不存在，<code>getAttribute()</code> 返回 <code>null</code>。</p>
<p>通过 <code>getAttribute()</code> 方法也可以取得自定义特性（即标准 HTML 语言中没有的特性）的值，以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">my_special_attribute</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个元素包含一个名为 <code>my_special_attribute</code> 的自定义特性，它的值是 <code>&quot;hello!&quot;</code>。可以像取得其他特性一样取得这个值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = div.getAttribute(<span class="string">"my_special_attribute"</span>);</div></pre></td></tr></table></figure>
<p>不过，特性的名称是不区分大小写的，即 <code>&quot;ID&quot;</code> 和 <code>&quot;id&quot;</code> 代表的都是同一个特性。另外也要注意，根据 HTML5 规范，自定义特性应该加上 <code>data-</code> 前缀以便验证。</p>
<p>任何元素的所有特性，也都可以通过 DOM 元素本身的属性来访问。当然，<code>HTMLElement</code> 也会有5个属性与相应的特性一一对应。不过，只有公认的（非自定义的）特性才会以属性的形式添加到 DOM 对象中。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">align</span>=<span class="string">"left"</span> <span class="attr">my_special_attribute</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>因为 <code>id</code> 和 <code>align</code> 在 HTML 中是 <code>div</code> 的公认特性，因此该元素的 DOM 对象中也将存在对应的属性。不过，自定义特性 <code>my_special_attribute</code> 在 Safari、Opera、Chrome 及 Firefox 中是不存在的；但 IE 却会为自定义特性也创建属性，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(div.id);                      <span class="comment">// "myDiv"</span></div><div class="line"><span class="built_in">console</span>.log(div.my_special_attribute);    <span class="comment">// undefined（IE除外）</span></div><div class="line"><span class="built_in">console</span>.log(div.align);                   <span class="comment">// "left"</span></div></pre></td></tr></table></figure>
<p>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过 <code>getAttribute()</code> 返回的值并不相同。第一类特性就是 <code>style</code>，用于通过 CSS 为元素指定样式。在通过 <code>getAttribute()</code> 访问时，返回的 <code>style</code> 特性值中包含的是CSS文本，而通过属性来访问它则会返回一个对象。由于 <code>style</code> 属性是用于以编程方式访问元素样式的，因此并没有直接映射到 <code>style</code> 特性。</p>
<p>第二类与众不同的特性是 <code>onclick</code> 这样的事件处理程序。当在元素上使用时，<code>onclick</code> 特性中包含的是 JavaScript 代码，如果通过 <code>getAttribute()</code> 访问，则会返回相应代码的字符串。而在访问 <code>onclick</code> 属性时，则会返回一个 JavaScript 函数（如果未在元素中指定相应特性，则返回 null）。这是因为 <code>onclick</code> 及其他事件处理程序属性本身就应该被赋予函数值。</p>
<p>由于存在这些差别，在通过 JavaScript 以编程方式操作 DOM 时，开发人员经常不使用 <code>getAttribute()</code>，而是只使用对象的属性。只有在取得自定义特性值的情况下，才会使用 <code>getAttribute()</code> 方法。</p>
<h4 id="设置特性"><a href="#设置特性" class="headerlink" title="设置特性"></a>设置特性</h4><p>与 <code>getAttribute()</code> 对应的方法是 <code>setAttribute()</code>，这个方法接受两个参数：要设置的特性名和值。如果特性已经存在，<code>setAttribute()</code> 会以指定的值替换现有的值；如果特性不存在，<code>setAttribute()</code> 则创建该属性并设置相应的值。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">div.setAttribute(<span class="string">"id"</span>, <span class="string">"someOtherId"</span>);</div><div class="line">div.setAttribute(<span class="string">"class"</span>, <span class="string">"ft"</span>);</div><div class="line">div.setAttribute(<span class="string">"title"</span>, <span class="string">"Some other text"</span>);</div><div class="line">div.setAttribute(<span class="string">"lang"</span>,<span class="string">"fr"</span>);</div><div class="line">div.setAttribute(<span class="string">"dir"</span>, <span class="string">"rtl"</span>);</div></pre></td></tr></table></figure>
<p>通过 <code>setAttribute()</code> 方法既可以操作HTML特性也可以操作自定义特性。通过这个方法设置的特性名会被统一转换为小写形式，即 <code>&quot;ID&quot;</code> 最终会变成 <code>&quot;id&quot;</code>。</p>
<p>因为所有特性都是属性，所以直接给属性赋值可以设置特性的值，如下所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"someOtherId"</span>;</div><div class="line">div.align = <span class="string">"left"</span>;</div></pre></td></tr></table></figure>
<p>不过，像下面这样为 DOM 元素添加一个自定义的属性，该属性不会自动成为元素的特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">div.mycolor = <span class="string">"red"</span>;</div><div class="line"><span class="built_in">console</span>.log(div.mycolor); <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">"mycolor"</span>)); <span class="comment">// null（IE除外）</span></div></pre></td></tr></table></figure>
<p>这个例子添加了一个名为 <code>mycolor</code> 的属性并将它的值设置为 <code>&quot;red&quot;</code>。在大多数浏览器中，这个属性都不会自动变成元素的特性，因此想通过 <code>getAttribute()</code> 取得同名特性的值，结果会返回 <code>null</code>。可是，自定义属性在 IE 中会被当作元素的特性，反之亦然。</p>
<p>要介绍的最后一个方法是 <code>removeAttribute()</code>，这个方法用于彻底删除元素的特性。调用这个方法不仅会清除特性的值，而且也会从元素中完全删除特性，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.removeAttribute(<span class="string">"class"</span>);</div></pre></td></tr></table></figure>
<p>这个方法并不常用，但在序列化 DOM 元素时，可以通过它来确切地指定要包含哪些特性。</p>
<h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用 <code>document.createElement()</code> 方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在 HTML 文档中不区分大小写。例如，使用下面的代码可以创建一个 <code>div</code> 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div></pre></td></tr></table></figure>
<p>在使用 <code>createElement()</code> 方法创建新元素的同时，也为新元素设置了 <code>ownerDocuemnt</code> 属性。此时，还可以操作元素的特性，为它添加更多子节点，以及执行其他操作。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">div.id = <span class="string">"myNewDiv"</span>;</div><div class="line">div.className = <span class="string">"box"</span>;</div></pre></td></tr></table></figure>
<p>在新元素上设置这些特性只是给它们赋予了相应的信息。由于新元素尚未被添加到文档树中，因此设置这些特性不会影响浏览器的显示。要把新元素添加到文档树，可以使用 <code>appendChild()</code>、<code>insertBefore()</code> 或 <code>replaceChild()</code> 方法。下面的代码会把新创建的元素添加到文档的 <code>&lt;body&gt;</code> 元素中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>一旦将元素添加到文档树中，浏览器就会立即呈现该元素。此后，对这个元素所作的任何修改都会实时反映在浏览器中。</p>
<h4 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h4><p>元素可以有任意数目的子节点和后代节点，因为元素可以是其他元素的子节点。元素的 <code>childNodes</code> 属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。不同浏览器在看待这些节点方面存在显著的不同，以下面的代码为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果是 IE8 来解析这些代码，那么 <code>&lt;ul&gt;</code> 元素会有3个子节点，分别是3个 <code>&lt;li&gt;</code> 元素。但如果是在其他浏览器中，<code>&lt;ul&gt;</code> 元素都会有7个元素，包括3个 <code>&lt;li&gt;</code> 元素和4个文本节点（表示 <code>&lt;li&gt;</code> 元素之间的空白符）。如果像下面这样将元素间的空白符删除，那么所有浏览器都会返回相同数目的子节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于这段代码，<code>&lt;ul&gt;</code> 元素在任何浏览器中都会包含3个子节点。如果需要通过 <code>childNodes</code> 属性遍历子节点，那么一定不要忘记浏览器间的这一差别。这意味着在执行某项操作以前，通常都要先检查一下 <code>nodeTpye</code> 属性，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>, len=element.childNodes.length; i &lt; len; i++)&#123;</div><div class="line">    <span class="keyword">if</span> (element.childNodes[i].nodeType == <span class="number">1</span>)&#123;</div><div class="line">        <span class="comment">//执行某些操作</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子会循环遍历特定元素的每一个子节点，然后只在子节点的 <code>nodeType</code> 等于1（表示是元素节点）的情况下，才会执行某些操作。</p>
<p>如果想通过某个特定的标签名取得子节点或后代节点该怎么办呢？实际上，元素也支持 <code>getElementsByTagName()</code> 方法。在通过元素调用这个方法时，除了搜索起点是当前元素之外，其他方面都跟通过 <code>document</code> 调用这个方法相同，因此结果只会返回当前元素的后代。例如，要想取得前面 <code>&lt;ul&gt;</code> 元素中包含的所有 <code>&lt;li&gt;</code> 元素，可以使用下列代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</div><div class="line"><span class="keyword">var</span> items = ul.getElementsByTagName(<span class="string">"li"</span>);</div></pre></td></tr></table></figure>
<p>要注意的是，这里 <code>&lt;ul&gt;</code> 的后代中只包含直接子元素。不过，如果它包含更多层次的后代元素，那么各个层次中包含的 <code>&lt;li&gt;</code> 元素也都会返回。</p>
<h3 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h3><p>文本节点由 <code>Text</code> 类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的 HTML 字符，但不能包含 HTML 代码。<code>Text</code> 节点具有以下特征：</p>
<ul>
<li><code>nodeType</code> 的值为3；</li>
<li><code>nodeName</code> 的值为 <code>&quot;#text&quot;</code>；</li>
<li><code>nodeValue</code> 的值为节点所包含的文本；</li>
<li><code>parentNode</code> 是一个 <code>Element</code>；</li>
<li>不支持（没有）子节点。</li>
</ul>
<p>可以通过 <code>nodeValue</code> 属性或 <code>data</code> 属性访问 <code>Text</code> 节点中包含的文本，这两个属性中包含的值相同。对 <code>nodeValue</code>的修改也会通过 <code>data</code> 反映出来，反之亦然。使用下列方法可以操作节点中的文本。</p>
<ul>
<li><code>appendData(*text*)</code>：将 <code>*text*</code> 添加到节点的末尾。</li>
<li><code>deleteData(*offset*, *count*)</code>：从 <code>*offset*</code> 指定的位置开始删除 <code>*count*</code> 个字符。</li>
<li><code>insertData(*offset, text*)</code>：在 <code>*offset*</code> 指定的位置插入 <code>*text*</code>。</li>
<li><code>replaceData(*offset, count, text*)</code>：用 <code>*text*</code> 替换从 <code>*offset*</code> 指定的位置开始到 <code>*offset*+*count*</code> 为止处的文本。</li>
<li><code>splitText(*offset*)</code>：从 <code>*offset*</code> 指定的位置将当前文本节点分成两个文本节点。</li>
<li><code>substringData(*offset, count*)</code>：提取从 <code>*offset*</code> 指定的位置开始到 <code>*offset+count*</code> 为止处的字符串。</li>
</ul>
<p>除了这些方法之外，文本节点还有一个 <code>length</code> 属性，保存着节点中字符的数目。而且，<code>nodeValue.length</code> 和 <code>data.length</code> 中也保存着同样的值。</p>
<p>在默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。来看几个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 没有内容，也就没有文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 有空格，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 有内容，因而有一个文本节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面代码给出的第一个 <code>&lt;div&gt;</code> 元素没有内容，因此也就不存在文本节点。开始与结束标签之间只要存在内容，就会创建一个文本节点。因此，第二个 <code>&lt;div&gt;</code> 元素中虽然只包含一个空格，但仍然有一个文本子节点；文本节点的 <code>nodeValue</code> 值是一个空格。第三个 <code>div</code> 也有一个文本节点，其 <code>nodeValue</code> 的值为 <code>&quot;Hello World!&quot;</code>。可以使用以下代码来访问这些文本子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textNode = div.firstChild;  <span class="comment">// 或者div.childNodes[0]</span></div></pre></td></tr></table></figure>
<p>在取得了文本节点的引用后，就可以像下面这样来修改它了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">div.firstChild.nodeValue = <span class="string">"Some other message"</span>;</div></pre></td></tr></table></figure>
<p>如果这个文本节点当前存在于文档树中，那么修改文本节点的结果就会立即得到反映。另外，在修改文本节点时还要注意，此时的字符串会经过 HTML（或XML，取决于文档类型）编码。换句话说，小于号、大于号或引号都会像下面的例子一样被转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输出结果是"Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message"</span></div><div class="line">div.firstChild.nodeValue = <span class="string">"Some &lt;strong&gt;other&lt;/strong&gt; message"</span>;</div></pre></td></tr></table></figure>
<p>应该说，这是在向 DOM 文档中插入文本之前，先对其进行 HTML 编码的一种有效方式。</p>
<blockquote>
<p>在 IE8、Firefox、Safari、Chrome 和 Opera中，可以通过脚本访问 <code>Text</code> 类型的构造函数和原型。</p>
</blockquote>
<h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>可以使用 <code>document.createTextNode()</code> 创建新文本节点，这个方法接受一个参数——要插入节点中的文本。与设置已有文本节点的值一样，作为参数的文本也将按照 HTML 或 XML 的格式进行编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt; world!"</span>);</div></pre></td></tr></table></figure>
<p>在创建新文本节点的同时，也会为其设置 <code>ownerDocument</code> 属性。不过，除非把新节点添加到文档树中已经存在的节点中，否则我们不会在浏览器窗口中看到新节点。下面的代码会创建一个 <code>&lt;div&gt;</code> 元素并向其中添加一条消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure>
<p>这个例子创建了一个新 <code>&lt;div&gt;</code> 元素并为它指定了值为 <code>&quot;message&quot;</code> 的 <code>class</code> 特性。然后，又创建了一个文本节点，并将其添加到前面创建的元素中。最后一步，就是将这个元素添加到了文档的 <code>&lt;body&gt;</code> 元素中，这样就可以在浏览器中看到新创建的元素和文本节点了。</p>
<p>一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Yippee!"</span>);</div><div class="line">element.appendChild(anotherTextNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div></pre></td></tr></table></figure>
<p>如果两个文本节点是相邻的同胞节点，那么这两个节点中的文本就会连起来显示，中间不会有空格。</p>
<h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM 文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM 文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由 <code>Node</code> 类型定义的（因而在所有节点类型中都存在），名叫 <code>normalize()</code>。如果在一个包含两个或多个文本节点的父元素上调用 <code>normalize()</code> 方法，则会将所有文本节点合并成一个节点，结果节点的 <code>nodeValue</code> 等于将合并前每个文本节点的 <code>nodeValue</code> 值拼接起来的值。来看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">element.className = <span class="string">"message"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>);</div><div class="line">element.appendChild(textNode);</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherTextNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Yippee!"</span>);</div><div class="line">element.appendChild(anotherTextNode);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(element);</div><div class="line"><span class="built_in">console</span>.log(element.childNodes.length);    <span class="comment">// 2</span></div><div class="line"></div><div class="line">element.normalize();</div><div class="line"><span class="built_in">console</span>.log(element.childNodes.length);    <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(element.firstChild.nodeValue); <span class="comment">// "Hello world!Yippee!"</span></div></pre></td></tr></table></figure>
<p>浏览器在解析文档时永远不会创建相邻的文本节点。这种情况只会作为执行DOM操作的结果出现。</p>
<h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p><code>Text</code> 类型提供了一个作用与 <code>normalize()</code> 相反的方法 <code>splitText()</code>。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割 <code>nodeValue</code> 值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的 <code>parentNode</code> 相同。</p>
<h3 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h3><p>注释在 DOM 中是通过 <code>Comment</code> 类型来表示的。<code>Comment</code> 节点具有下列特征：</p>
<ul>
<li><code>nodeType</code> 的值为8；</li>
<li><code>nodeName</code> 的值为 <code>&quot;#comment&quot;</code>；</li>
<li><code>nodeValue</code> 的值是注释的内容；</li>
<li><code>parentNode</code> 可能是 <code>Document</code> 或 <code>Element</code>；</li>
<li>不支持（没有）子节点。</li>
</ul>
<p><code>Comment</code> 类型与 <code>Text</code> 类型继承自相同的基类，因此它拥有除<code>splitText()</code> 之外的所有字符串操作方法。与 <code>Text</code> 类型相似，也可以通过 <code>nodeValue</code> 或 <code>data</code> 属性来取得注释的内容。</p>
<p>注释节点可以通过其父节点来访问，以下面的代码为例。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="comment">&lt;!--A comment --&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在此，注释节点是 <code>&lt;div&gt;</code> 元素的一个子节点，因此可以通过下面的代码来访问它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">var</span> comment = div.firstChild;</div><div class="line"><span class="built_in">console</span>.log(comment.data);    <span class="comment">// "A comment"</span></div></pre></td></tr></table></figure>
<p>另外，使用 <code>document.createComment()</code> 并为其传递注释文本也可以创建注释节点，如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"A comment "</span>);</div></pre></td></tr></table></figure>
<p>显然，开发人员很少会创建和访问注释节点，因为注释节点对算法鲜有影响。此外，浏览器也不会识别位于 <code>&lt;/html&gt;</code> 标签后面的注释。如果要访问注释节点，一定要保证它们位于 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> 之间。</p>
<h3 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h3><p>元素的特性在 DOM 中以 <code>Attr</code> 类型来表示。在所有浏览器中（包括 IE8），都可以访问 <code>Attr</code> 类型的构造函数和原型。从技术角度讲，特性就是存在于元素的 <code>attributes</code> 属性中的节点。特性节点具有下列特征：</p>
<ul>
<li><code>nodeType</code> 的值为11；</li>
<li><code>nodeName</code> 的值是特性的名称；</li>
<li><code>nodeValue</code> 的值是特性的值；</li>
<li><code>parentNode</code> 的值为 <code>null</code>；</li>
<li>在 HTML 中不支持（没有）子节点；</li>
<li>在 XML 中子节点可以是 <code>Text</code>或 <code>EntityReference</code>。</li>
</ul>
<p>尽管它们也是节点，但特性却不被认为是 DOM 文档树的一部分。开发人员最常使用的是 <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>remveAttribute()</code> 方法，很少直接引用特性节点。</p>
<p><code>Attr</code> 对象有3个属性：<code>name</code>、<code>value</code> 和 <code>specified</code>。其中，<code>name</code> 是特性名称（与 <code>nodeName</code> 的值相同），<code>value</code> 是特性的值（与 <code>nodeValue</code> 的值相同），而 <code>specified</code> 是一个布尔值，用以区别特性是在代码中指定的，还是默认的。</p>
<p>使用 <code>document.createAttribute()</code> 并传入特性的名称可以创建新的特性节点。例如，要为元素添加 <code>align</code> 特性，可以使用下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">"align"</span>);</div><div class="line">attr.value = <span class="string">"left"</span>;</div><div class="line">element.setAttributeNode(attr);</div><div class="line"><span class="built_in">console</span>.log(element.attributes[<span class="string">"align"</span>].value);       <span class="comment">// "left"</span></div><div class="line"><span class="built_in">console</span>.log(element.getAttributeNode(<span class="string">"align"</span>).value); <span class="comment">// "left"</span></div><div class="line"><span class="built_in">console</span>.log(element.getAttribute(<span class="string">"align"</span>));           <span class="comment">// "left"</span></div></pre></td></tr></table></figure>
<p>添加特性之后，可以通过下列任何方式访问该特性：<code>attributes</code> 属性、<code>getAttributeNode()</code> 方法以及 <code>getAttribute()</code> 方法。其中，<code>attributes</code> 和 <code>getAttributeNode()</code> 都会返回对应特性的 <code>Attr</code> 节点，而 <code>getAttribute()</code> 则只返回特性的值。</p>
<h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><p>很多时候，DOM 操作都比较简明，因此用 JavaScript 生成那些通常原本是用 HTML 代码生成的内容并不麻烦。不过，也有一些时候，操作 DOM 并不像表面上看起来那么简单。由于浏览器中充斥着隐藏的陷阱和不兼容问题，用 JavaScript 代码处理 DOM 的某些部分要比处理其他部分更复杂一些。</p>
<h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>使用 <code>&lt;script&gt;</code> 元素可以向页面中插入 JavaScript 代码，一种方式是通过其 <code>src</code> 特性包含外部文件，另一种方式就是用这个元素本身来包含代码。而这一节要讨论的动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加的脚本。跟操作 HTML 元素一样，创建动态脚本也有两种方式：插入外部文件和直接插入 JavaScript 代码。</p>
<p>动态加载的外部 JavaScript 文件能够立即运行，比如下面的 <code>&lt;script&gt;</code> 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"client.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>创建这个 DOM 节点的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    script.src = url;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是调用这个函数的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadScript(<span class="string">"client.js"</span>);</div></pre></td></tr></table></figure>
<p>另一种指定 JavaScript 代码的方式是行内方式，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"></span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span></span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>从逻辑上讲，下面操作的 DOM 代码是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>));</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<p>在 Firefox、Safari、Chrome 和 Opera 中，这些 DOM 代码可以正常运行。但在 IE 中，则会导致错误。IE 将 <code>&lt;script&gt;</code> 视为一个特殊的元素，不允许 DOM 访问其子节点。不过，可以使用 <code>&lt;script&gt;</code> 元素的<code>text</code> 属性来指定 JavaScript 代码，像下面的例子这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">script.type = <span class="string">"text/javascript"</span>;</div><div class="line">script.text = <span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(script);</div></pre></td></tr></table></figure>
<p>整个过程可以用以下函数来表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">    script.type = <span class="string">"text/javascript"</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        script.text = code;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是调用这个函数的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadScriptString(<span class="string">"function sayHi()&#123;alert('hi');&#125;"</span>);</div></pre></td></tr></table></figure>
<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 <code>eval()</code> 是一样的。</p>
<h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>能够把 CSS 样式包含到 HTML 页面中的元素有两个。其中，<code>&lt;link&gt;</code> 元素用于包含来自外部的文件，而 <code>&lt;style&gt;</code> 元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。</p>
<p>我们以下面这个典型的 <code>&lt;link&gt;</code> 元素为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用 DOM 代码可以很容易地动态创建出这个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</div><div class="line">    link.rel = <span class="string">"stylesheet"</span>;</div><div class="line">    link.type = <span class="string">"text/css"</span>;</div><div class="line">    link.href = url;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(link);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码在所有主流浏览器中都可以正常运行。需要注意的是，必须将 <code>&lt;link&gt;</code> 元素添加到 <code>&lt;head&gt;</code> 而不是 <code>&lt;body&gt;</code> 元素，才能保证在所有浏览器中的行为一致。调用函数的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadStyles(<span class="string">"styles.css"</span>);</div></pre></td></tr></table></figure>
<p>加载外部样式文件的过程是异步的，也就是加载样式的过程没有固定的次序。一般来说，知不知道样式已经加载完成并不重要。</p>
<p>另一种定义样式的方式是使用 <code>&lt;style&gt;</code> 元素来包含嵌入式 CSS，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">background-color</span>: red; &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>按照相同的逻辑，下列 DOM 代码应该是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">style.type = <span class="string">"text/css"</span>;</div><div class="line">style.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"body&#123;background-color:red&#125;"</span>)); </div><div class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">head.appendChild(style);</div></pre></td></tr></table></figure>
<p>以上代码可以在 Firefox、Safari、Chrome 和 Opera 中运行，在 IE 中则会报错。IE将 <code>&lt;style&gt;</code> 视为一个特殊的、与 <code>&lt;script&gt;</code> 类似的节点，不允许访问其子节点。事实上，IE 此时抛出的错误与向 <code>&lt;script&gt;</code> 元素添加子节点时抛出的错误相同。解决 IE 中这个问题的办法，就是访问元素的 <code>styleSheet</code> 属性，该属性又有一个 <code>cssText</code> 属性，可以接受 CSS 代码），如下面的例子所示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">    style.type = <span class="string">"text/css"</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</div><div class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">        style.styleSheet.cssText = css;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</div><div class="line">    head.appendChild(style);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用这个函数的示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loadStyleString(<span class="string">"body&#123;background-color:red&#125;"</span>);</div></pre></td></tr></table></figure>
<p>这种方式会实时地向页面中添加样式，因此能够马上看到变化。</p>
<h3 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h3><p>理解 <code>NodeList</code> 及其“近亲” <code>NamedNodeMap</code> 和 <code>HTMLCollection</code>，是从整体上透彻理解 DOM 的关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上说，所有 <code>NodeList</code> 对象都是在访问 DOM 文档时实时运行的查询。例如，下列代码会导致无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i,div,divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; divs.length; i++)&#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一行代码会取得文档中所有 <code>&lt;div&gt;</code> 元素的 <code>HTMLCollection</code>。由于这个集合是“动态的”，因此只要有新 <code>&lt;div&gt;</code> 元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将创建的所有集合都保存在一个列表中，而是在下一次访问集合时再更新集合。结果，在遇到上例中所示的循环代码时，就会导致一个有趣的问题。每次循环都要对条件 <code>i &lt; divs.length</code> 求值，意味着会运行取得所有 <code>&lt;div&gt;</code> 元素的查询。考虑到循环体每次都会创建一个新 <code>&lt;div&gt;</code> 元素并将其添加到文档中，因此 <code>divs.length</code> 的值在每次循环后都会递增。既然<code>i</code>和 <code>divs.length</code> 每次都会同时递增，结果它们的值永远也不会相等。</p>
<p>如果想要迭代一个 <code>NodeList</code>，最好是使用 <code>length</code> 属性初始化第二个变量，然后将迭代器与该变量进行比较，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i,len,div,divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"><span class="keyword">for</span> (i=<span class="number">0</span>, len=divs.length; i &lt; len; i++)&#123;</div><div class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中初始化了第二个变量 <code>len</code>。由于 <code>len</code> 中保存着对 <code>divs.length</code> 在循环开始时的一个快照，因此就会避免上一个例子中出现的无限循环问题。在本章演示迭代 <code>NodeList</code> 对象的例子中，使用的都是这种更为保险的方式。</p>
<p>一般来说，应该尽量减少访问 <code>NodeList</code> 的次数。因为每次访问 <code>NodeList</code>，都会运行一次基于文档的查询。所以，可以考虑将从 <code>NodeList</code> 中取得的值缓存起来。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DOM 是语言中立的 API，用于访问和操作 HTML 和 XML 文档。DOM1 级将 HTML 和 XML 文档形象地看作一个层次化的节点树，可以使用 JavaScript 来操作这个节点树，进而改变底层文档的外观和结构。</p>
<p>DOM 由各种节点构成，简要总结如下。</p>
<ul>
<li>最基本的节点类型是 <code>Node</code>，用于抽象地表示文档中一个独立的部分；所有其他类型都继承自 <code>Node</code>。</li>
<li><code>Document</code> 类型表示整个文档，是一组分层节点的根节点。在 JavaScript 中，<code>document</code> 对象是 <code>Document</code> 的一个实例。使用 <code>document</code> 对象，有很多种方式可以查询和取得节点。</li>
<li><code>Element</code> 节点表示文档中的所有 HTML 或 XML 元素，可以用来操作这些元素的内容和特性。</li>
<li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA 区域和文档片段。</li>
</ul>
<p>访问 DOM 的操作在多数情况下都很直观，不过在处理 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用 <code>innerHTML</code> 时，以及在创建新元素时的一些问题。</p>
<p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的部分，而因访问 <code>NodeList</code> 导致的问题为最多。<code>NodeList</code> 对象都是“动态的”，这就意味着每次访问 <code>NodeList</code> 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p>
<h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><p>仔细想想，下面代码块会输出什么结果呢？前3个挑战相比前一章节，代码仅仅是多了换行，结果会有什么不一样呢？</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战一 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.firstChild.innerHTML);  <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.lastChild.innerHTML);   <span class="comment">// ???   </span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战二 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);  </div><div class="line">    <span class="built_in">document</span>.writeln(d.childNodes[<span class="number">1</span>].innerHTML); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.parentNode.getAttribute(<span class="string">"name"</span>)); <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战三 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">"ddd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"t"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).childNodes[<span class="number">1</span>];  </div><div class="line">    <span class="built_in">document</span>.writeln(d.nextSibling.innerHTML);      <span class="comment">// ???</span></div><div class="line">    <span class="built_in">document</span>.writeln(d.previousSibling.innerHTML);  <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 挑战四 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"t"</span> <span class="attr">class</span>=<span class="string">"content"</span> <span class="attr">style</span>=<span class="string">"background: red;"</span> <span class="attr">wife</span>=<span class="string">"sophie"</span> <span class="attr">onclick</span>=<span class="string">"alert('123');"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> </span></div><div class="line">    <span class="keyword">var</span> t = <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>);    </div><div class="line">    <span class="built_in">console</span>.log(t.class);                   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"class"</span>));   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.className);               <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"className"</span>)); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.style);                   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"style"</span>));   <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.style.background);        <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"style.background"</span>)); <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.wife);                    <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"wife"</span>));    <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.onclick);                 <span class="comment">// ???</span></div><div class="line">    <span class="built_in">console</span>.log(t.getAttribute(<span class="string">"onclick"</span>)); <span class="comment">// ???</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。<br>关注 <a href="https://github.com/stone0090/javascript-lessons" target="_blank" rel="external">https://github.com/stone0090/javascript-lessons</a>，获取最新动态。</p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://shijiajie.com/2016/11/22/javascript-lesson-2.2-DOM-2/" data-id="cj2cy52vb002mr951l5p7tkop" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/《JavaScript-闯关记》/">《JavaScript 闯关记》</a></div><div class="post-nav"><a href="/2016/11/15/javascript-lesson-2.2-DOM-1/" class="pre">《JavaScript 闯关记》之 DOM（上）</a><a href="/2016/11/29/javascript-lesson-2.3-Event/" class="next">《JavaScript 闯关记》之事件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/stone0090" title="我的「GitHub」" target="_blank">我的「GitHub」</a><ul></ul><a href="http://qiniu.shijiajie.com/weixin/xiaomiquan.jpg" title="我的「小密圈」" target="_blank">我的「小密圈」</a><ul></ul><a href="http://qiniu.shijiajie.com/weixin/qrcode_for_gh_48ef95800cf5_430.jpg" title="我的「微信公众号」" target="_blank">我的「微信公众号」</a><ul></ul><a href="http://weibo.com/605494869" title="我的「微博」" target="_blank">我的「微博」</a><ul></ul><a href="https://www.zhihu.com/people/stone0090" title="我的「知乎」" target="_blank">我的「知乎」</a><ul></ul><a href="http://www.jianshu.com/u/0005893eaff9" title="我的「简书」" target="_blank">我的「简书」</a><ul></ul><a href="https://juejin.im/user/57b83a6fa633bd0066590d37" title="我的「掘金」" target="_blank">我的「掘金」</a><ul></ul><a href="http://www.cnblogs.com/shi0090" title="我的「博客园」" target="_blank">我的「博客园」</a><ul></ul><a href="http://blog.csdn.net/shi0090" title="我的「CSDN」" target="_blank">我的「CSDN」</a><ul></ul><a href="https://segmentfault.com/u/stone0090" title="我的「SegmentFault」" target="_blank">我的「SegmentFault」</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NET/">.NET</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/NET/">.NET</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/DSOframer/">DSOframer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/算法/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/软件/Parallels/">Parallels</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/VMware/">VMware</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/心情随笔/">心情随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/读书笔记/">读书笔记</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/原型链/" style="font-size: 15px;">原型链</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/ASP-NET/" style="font-size: 15px;">ASP.NET</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/Amaze-UI/" style="font-size: 15px;">Amaze UI</a> <a href="/tags/开源项目/" style="font-size: 15px;">开源项目</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a> <a href="/tags/断点续传/" style="font-size: 15px;">断点续传</a> <a href="/tags/EasyUI/" style="font-size: 15px;">EasyUI</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/DSOframer/" style="font-size: 15px;">DSOframer</a> <a href="/tags/心情随笔/" style="font-size: 15px;">心情随笔</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/float/" style="font-size: 15px;">float</a> <a href="/tags/position/" style="font-size: 15px;">position</a> <a href="/tags/样式布局分享/" style="font-size: 15px;">样式布局分享</a> <a href="/tags/frozen-js/" style="font-size: 15px;">frozen.js</a> <a href="/tags/zepto/" style="font-size: 15px;">zepto</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/landscape-plus/" style="font-size: 15px;">landscape-plus</a> <a href="/tags/编程珠玑/" style="font-size: 15px;">编程珠玑</a> <a href="/tags/prototype/" style="font-size: 15px;">prototype</a> <a href="/tags/《JavaScript-闯关记》/" style="font-size: 15px;">《JavaScript 闯关记》</a> <a href="/tags/《编写可维护的JavaScript》/" style="font-size: 15px;">《编写可维护的JavaScript》</a> <a href="/tags/basevalidate-js/" style="font-size: 15px;">basevalidate.js</a> <a href="/tags/微信公众号/" style="font-size: 15px;">微信公众号</a> <a href="/tags/tab-js/" style="font-size: 15px;">tab.js</a> <a href="/tags/PDF转图片/" style="font-size: 15px;">PDF转图片</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/MicroBlog/" style="font-size: 15px;">MicroBlog</a> <a href="/tags/Node-js开发指南/" style="font-size: 15px;">Node.js开发指南</a> <a href="/tags/DOC转图片/" style="font-size: 15px;">DOC转图片</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/时间管理/" style="font-size: 15px;">时间管理</a> <a href="/tags/专栏精粹/" style="font-size: 15px;">专栏精粹</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/Parallels/" style="font-size: 15px;">Parallels</a> <a href="/tags/VMware/" style="font-size: 15px;">VMware</a> <a href="/tags/Windows-10/" style="font-size: 15px;">Windows 10</a> <a href="/tags/Boot-Camp/" style="font-size: 15px;">Boot Camp</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/阿里影业/" style="font-size: 15px;">阿里影业</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">劼哥舍(＞﹏＜).</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.miitbeian.gov.cn/"> 粤ICP备15013245号-2.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>