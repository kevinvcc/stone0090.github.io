<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="劼哥舍"><title>劼哥舍(＞﹏＜) | 越简单越快乐，越努力越幸运...</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">劼哥舍(＞﹏＜)</h1><a id="logo" href="/.">劼哥舍(＞﹏＜)</a><p class="description">越简单越快乐，越努力越幸运...</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2016/12/29/javascript-lesson-2.6-GC&amp;MemoryManagement/">《JavaScript 闯关记》之垃圾回收和内存管理</a></h1><div class="post-meta">2016-12-29</div><div class="post-content"><h1 id="垃圾回收和内存管理"><a href="#垃圾回收和内存管理" class="headerlink" title="垃圾回收和内存管理"></a>垃圾回收和内存管理</h1><p>JavaScript 具有自动垃圾收集机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。</p>
<p>在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：<strong>找出那些不再继续使用的变量，然后释放其占用的内存。</strong>为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。</p>
<p>正因为垃圾回收器的存在，许多人认为 JavaScript 不用太关心内存管理的问题，但如果不了解 JavaScript 的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="内存的分配场景"><a href="#内存的分配场景" class="headerlink" title="内存的分配场景"></a>内存的分配场景</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.对象</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(); </div><div class="line"><span class="keyword">new</span> MyConstructor(); </div><div class="line">&#123; <span class="attr">a</span>: <span class="number">4</span>, <span class="attr">b</span>: <span class="number">5</span> &#125; </div><div class="line"><span class="built_in">Object</span>.create();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2.数组 </span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(); </div><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ];</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3.字符串，JavaScript 的字符串和 .NET 一样，使用资源池和 copy on write 方式管理字符串。</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello hyddd"</span>); </div><div class="line"><span class="string">"&lt;p&gt;"</span> + e.innerHTML + <span class="string">"&lt;/p&gt;"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 4.函数</span></div><div class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125; </div><div class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(code);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 5.闭包 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> x = name; </div><div class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123; </div><div class="line">        <span class="keyword">return</span> <span class="string">"Hi, "</span> + name; </div><div class="line">     &#125; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3><p>下面我们来分析一下函数中局部变量的正常生命周期。</p>
<ul>
<li>内存分配：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。</li>
<li>内存使用：然后在函数中使用这些变量，直至函数执行结束。</li>
<li>内存回收：此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。</li>
</ul>
<p>通常，很容易判断变量是否还有存在的必要，但并非所有情况下都这么容易就能得出结论（例如：使用闭包的时）。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：<strong>标记清除</strong> 和 <strong>引用计数</strong>。</p></div><p class="readmore"><a href="/2016/12/29/javascript-lesson-2.6-GC&amp;MemoryManagement/">阅读更多</a></p></div><div class="post"><h1 class="post-title"><a href="/2016/12/21/javascript-lesson-2.5-Prototype/">《JavaScript 闯关记》之原型及原型链</a></h1><div class="post-meta">2016-12-21</div><div class="post-content"><p>原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 <code>__proto__</code> 属性指向创建它的构造函数的 <code>prototype</code>（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从<strong>函数对象</strong>、<code>constructor</code>、<code>new</code>、<code>prototype</code>、<code>__proto__</code> 这五个概念入手。</p>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。下面示例代码对「普通对象」和「函数对象」进行了区分。</p>
<p>普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure>
<p>函数对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</div></pre></td></tr></table></figure>
<p>简单的说，凡是使用 <code>function</code> 关键字或 <code>Function</code> 构造函数创建的对象都是函数对象。而且，只有函数对象才拥有  <code>prototype</code> （原型）属性。</p>
<h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a><code>constructor</code> 构造函数</h2><p>函数还有一种用法，就是把它作为构造函数使用。像 <code>Object</code> 和 <code>Array</code> 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Stone"</span>, <span class="number">28</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Sophie"</span>, <span class="number">29</span>, <span class="string">"English Teacher"</span>);</div></pre></td></tr></table></figure>
<p>在这个例子中，我们创建了一个自定义构造函数 <code>Person()</code>，并通过该构造函数创建了两个普通对象 <code>person1</code> 和 <code>person2</code>，这两个普通对象均包含3个属性和1个方法。</p>
<p>你应该注意到函数名 <code>Person</code> 使用的是大写字母 <code>P</code>。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他面向对象语言，主要是为了区别于 JavaScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</p></div><p class="readmore"><a href="/2016/12/21/javascript-lesson-2.5-Prototype/">阅读更多</a></p></div><div class="post"><h1 class="post-title"><a href="/2016/12/13/javascript-lesson-2.4-Scope&amp;Closure/">《JavaScript 闯关记》之作用域和闭包</a></h1><div class="post-meta">2016-12-13</div><div class="post-content"><p>作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。</p>
<h3 id="全局作用域（Global-Scope）"><a href="#全局作用域（Global-Scope）" class="headerlink" title="全局作用域（Global Scope）"></a>全局作用域（Global Scope）</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：</p>
<p>1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global = <span class="string">"global"</span>;     <span class="comment">// 显式声明一个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>;   <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    <span class="keyword">return</span> global;         <span class="comment">// 返回全局变量的值</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);       <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(checkscope()); <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);        <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，<code>global</code> 是全局变量，不管是在 <code>checkscope()</code> 函数内部还是外部，都能访问到全局变量 <code>global</code>。</p>
<p>2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> local = <span class="string">"local"</span>; <span class="comment">// 显式声明一个局部变量</span></div><div class="line">    global = <span class="string">"global"</span>;   <span class="comment">// 隐式声明一个全局变量(不好的写法)</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(global);     <span class="comment">// "global"</span></div><div class="line"><span class="built_in">console</span>.log(local);      <span class="comment">// error: local is not defined.</span></div></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>global</code> 未用 <code>var</code> 关键字定义就直接赋值，所以隐式的创建了全局变量 <code>global</code>，但这种写法容易造成误解，应尽量避免这种写法。</p>
<p>3.所有 <code>window</code> 对象的属性拥有全局作用域</p>
<p>一般情况下，<code>window</code> 对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p></div><p class="readmore"><a href="/2016/12/13/javascript-lesson-2.4-Scope&amp;Closure/">阅读更多</a></p></div><div class="post"><h1 class="post-title"><a href="/2016/12/04/wechat-public-platform-layout-designer2/">如何排版 微信公众号「代码块」之 MarkEditor</a></h1><div class="post-meta">2016-12-04</div><div class="post-content"><p>前段时间写过一篇文章 <a href="http://www.jianshu.com/p/ffeb5ceac32b">如何排版微信公众号「代码块」</a>，讲的是如何使用浏览器插件 <a href="http://markdown-here.com/index.html">Markdown Here</a> 来排版代码块。虽然用 <a href="http://markdown-here.com/index.html">Markdown Here</a> 排版出来的样式还不错，但存在一个问题，就是代码之间的换行会全部丢失，需要手动进行调整。如果文章中代码较多的话，调整起来还是挺费劲的。</p>
<p>而我近期写的文章，常常会罗列大量代码，导致每次在公众号发文，都要花1个多小时来调整样式，真是难受想哭。</p>
<p>双11期间，看到 <a href="https://www.zhihu.com/people/sagacity">池建强老师</a> 公众号 <code>MacTalk</code> 的文章 <a href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MjM5ODQ2MDIyMA==#wechat_webview_type=1&amp;wechat_redirect">如何优雅的购买 Mac 软件</a>。不出我意料，他果然推荐了一家专卖正版 Mac 软件的淘宝店铺 <a href="https://digitalychee.taobao.com/?spm=a1z10.1-c-s.0.0.Lc7ddI">数码荔枝</a>。秉承「老池推荐必精品」的原则，我如愿的淘到了微信公众号排版神器 <a href="http://markeditor.com/app/markeditor">MarkEditor</a>。当时，该软件有着「双11特惠」和「老池特惠」双重加持，我仅用了 76.5 就拿下了官网售价 128 的 Pro 版本（得意的笑）。</p>
<p><img src="http://qiniu.shijiajie.com/blog/wechat-public-platform-layout-designer2/WechatIMG98.jpeg" alt=""></p></div><p class="readmore"><a href="/2016/12/04/wechat-public-platform-layout-designer2/">阅读更多</a></p></div><div class="post"><h1 class="post-title"><a href="/2016/11/29/javascript-lesson-2.3-Event/">《JavaScript 闯关记》之事件</a></h1><div class="post-meta">2016-11-29</div><div class="post-content"><p>JavaScript 程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web 浏览器就会产生事件（event）。例如，当 Web 浏览器加载完文档、用户把鼠标指针移到超链接上或敲击键盘时，Web 浏览器都会产生事件。如果 JavaScript 应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。请注意，这种风格并不只应用于 Web 编程，所有使用图形用户界面的应用程序都采用了它，它们静待某些事情发生（即，它们等待事件发生），然后它们响应。</p>
<p>请注意，事件本身并不是一个需要定义的技术名词。简而言之，事件就是 Web 浏览器通知应用程序发生了什么事情，这种在传统软件工程中被称为观察员模式。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>当浏览器发展到第四代时（IE4 及 Netscape Communicator 4），浏览器开发团队遇到了一个很有意思的问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。两家公司的浏览器开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。</p>
<p><strong>事件流</strong>描述的是从页面中接收事件的顺序。但有意思的是，IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 的事件流叫做<strong>事件冒泡</strong>（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。以下面的HTML页面为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你单击了页面中的 <code>&lt;div&gt;</code> 元素，那么这个 <code>click</code> 事件会按照如下顺序传播：</p>
<ol>
<li><code>&lt;div&gt;</code></li>
<li><code>&lt;body&gt;</code></li>
<li><code>&lt;html&gt;</code></li>
<li><code>document</code></li>
</ol>
<p>也就是说，<code>click</code> 事件首先在 <code>&lt;div&gt;</code> 元素上发生，而这个元素就是我们单击的元素。然后，<code>click</code> 事件沿 DOM 树向上传播，在每一级节点上都会发生，直至传播到 <code>document</code> 对象。下图展示了事件冒泡的过程。</p>
<p><img src="http://qiniu.shijiajie.com/blog/javascript-lesson/2.3/1.jpg" alt=""></p></div><p class="readmore"><a href="/2016/11/29/javascript-lesson-2.3-Event/">阅读更多</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/stone0090" title="我的「GitHub」" target="_blank">我的「GitHub」</a><ul></ul><a href="http://qiniu.shijiajie.com/weixin/qrcode_for_gh_48ef95800cf5_430.jpg" title="我的「微信公众号」" target="_blank">我的「微信公众号」</a><ul></ul><a href="http://weibo.com/605494869" title="我的「微博」" target="_blank">我的「微博」</a><ul></ul><a href="https://www.zhihu.com/people/stone0090" title="我的「知乎」" target="_blank">我的「知乎」</a><ul></ul><a href="http://www.jianshu.com/u/0005893eaff9" title="我的「简书」" target="_blank">我的「简书」</a><ul></ul><a href="https://juejin.im/user/57b83a6fa633bd0066590d37" title="我的「掘金」" target="_blank">我的「掘金」</a><ul></ul><a href="http://www.cnblogs.com/shi0090" title="我的「博客园」" target="_blank">我的「博客园」</a><ul></ul><a href="http://blog.csdn.net/shi0090" title="我的「CSDN」" target="_blank">我的「CSDN」</a><ul></ul><a href="https://segmentfault.com/u/stone0090" title="我的「SegmentFault」" target="_blank">我的「SegmentFault」</a></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/NET/">.NET</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/DSOframer/">DSOframer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/算法/">算法</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/软件/Parallels/">Parallels</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/VMware/">VMware</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/心情随笔/">心情随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/读书笔记/">读书笔记</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/zepto/" style="font-size: 15px;">zepto</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/NET/" style="font-size: 15px;">.NET</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/Socket/" style="font-size: 15px;">Socket</a> <a href="/tags/断点续传/" style="font-size: 15px;">断点续传</a> <a href="/tags/ASP-NET/" style="font-size: 15px;">ASP.NET</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/EasyUI/" style="font-size: 15px;">EasyUI</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/开源项目/" style="font-size: 15px;">开源项目</a> <a href="/tags/Amaze-UI/" style="font-size: 15px;">Amaze UI</a> <a href="/tags/Visual-Studio/" style="font-size: 15px;">Visual Studio</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/DSOframer/" style="font-size: 15px;">DSOframer</a> <a href="/tags/心情随笔/" style="font-size: 15px;">心情随笔</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/position/" style="font-size: 15px;">position</a> <a href="/tags/float/" style="font-size: 15px;">float</a> <a href="/tags/样式布局分享/" style="font-size: 15px;">样式布局分享</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/landscape-plus/" style="font-size: 15px;">landscape-plus</a> <a href="/tags/frozen-js/" style="font-size: 15px;">frozen.js</a> <a href="/tags/编程珠玑/" style="font-size: 15px;">编程珠玑</a> <a href="/tags/原型链/" style="font-size: 15px;">原型链</a> <a href="/tags/prototype/" style="font-size: 15px;">prototype</a> <a href="/tags/《JavaScript-闯关记》/" style="font-size: 15px;">《JavaScript 闯关记》</a> <a href="/tags/《编写可维护的JavaScript》/" style="font-size: 15px;">《编写可维护的JavaScript》</a> <a href="/tags/basevalidate-js/" style="font-size: 15px;">basevalidate.js</a> <a href="/tags/微信公众号/" style="font-size: 15px;">微信公众号</a> <a href="/tags/tab-js/" style="font-size: 15px;">tab.js</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/MicroBlog/" style="font-size: 15px;">MicroBlog</a> <a href="/tags/Node-js开发指南/" style="font-size: 15px;">Node.js开发指南</a> <a href="/tags/DOC转图片/" style="font-size: 15px;">DOC转图片</a> <a href="/tags/PDF转图片/" style="font-size: 15px;">PDF转图片</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/时间管理/" style="font-size: 15px;">时间管理</a> <a href="/tags/专栏精粹/" style="font-size: 15px;">专栏精粹</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/虚拟机/" style="font-size: 15px;">虚拟机</a> <a href="/tags/Parallels/" style="font-size: 15px;">Parallels</a> <a href="/tags/Windows-10/" style="font-size: 15px;">Windows 10</a> <a href="/tags/Boot-Camp/" style="font-size: 15px;">Boot Camp</a> <a href="/tags/VMware/" style="font-size: 15px;">VMware</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">劼哥舍(＞﹏＜).</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>